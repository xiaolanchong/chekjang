<>
천리안 리눅스 강좌

	끝으로, 행사를 위해 좋은 장소를 제공한 <데이콤(천리안)>, "Informix-SE for Linux"를 제공해 준 <한국 인포믹스>, 강의를 위한 시스템을 지원해준 <에이시스 정보통신>, 정품 리눅스 CD를 제공해 준 <지그재그 소프트>, 리눅스용 "글/X R4"를 제공해준 <미지리서치>, 본 교재를 발간 해준 <(주) 예지각>, 그리고 이 행사를 기획하고 총 진행을 맡아준 <SmartMate Co., Ltd.>의 [가우스] 김민수님께
감사와 찬사를 띄운다.

              				                        1998년 8월 29일
		                     		               호나비 안길성 드림

만든이들(천리안 ID: 이름 전자우편 주소)
가우스 : 김민수 gauss@smartmate.com
가을향기 : 황상진 hackers@smartmate.com
낙엽 : 박상완 webadmin@webadmin.net
둥둥이 : 박경인 kyungins@chollian.net
무릉도원 : 김완희 hwinnt@chollian.net
바보미역 : 최민혁 magic23@chollian.net
사바세계 : 박혜연
선이 : 정선이 jung0911@chollian.net
요셉 : 정재형 jjh7100@chollian.net
은빛연어 : 장덕희 sauro@chollian.net
이승 : 이승 lvl@chollian.net
나마스카 : 채병철 dataeng@chollian.net
캐수퍼 : 임통규 casper@smartmate.com
파랑이 : 전석병 zsdeer@chollian.net
푸른달 : 박승훈 hdb14@chollian.net
호준 : 이호준 nel78@chollian.net
< 目 次 >

Ⅱ. 리눅스의 구조
	1. 리눅스의 기본구조
	2. 리눅스의 Kernel에 관하여
	3. X-Window System에 관하여

Ⅲ. 리눅스의 활용
	1. 리눅스 & Networking
	2. 리눅스 & Internet Service
	3. 리눅스 & Database
	4. 리눅스 & Security

<부록>
● 리눅스(RedHat 5.1) 설치하기
● 리눅스 상에서의 한글구현
● X-Window 설정하기
● 리눅스 상에서의 컴퓨터통신과 인터넷 사용하기
● 리눅스 관련 Internet Site 모음
Ⅱ. 리눅스의 구조

   1. 리눅스의 기본구조

	[디렉토리 구조]
/bin	: Linux에서 사용하는 기본 명령어들이 위치하는 디렉토리.
/boot	: Linux boot에 필요한 booting 지원 파일들이 위치하는 디렉토리.
/dev	: Linux에서 사용하는 각 장치에 대한 Device들이 위치하는 디렉토리.
	 용량을 차지하지 않는 가상의 디렉토리.
/etc	: Linux에서 사용되는 모든 어플리케이션 및 Linux 환경 설정에 필요한
	  설정 파일들의 총 집합체. 
/home	: Linux user 들의 기본 디렉토리이며, web server 및 ftp server,
	  Samba server 의 디렉토리가 위치하는 디렉토리.
/lib	: Linux에서 사용하는 기본 라이브러리가 위치하는 디렉토리.
/mnt	: cd-rom 및 floppy 장치에 대한 mount pointer가 위치하는 디렉토리. 
/proc	: 가상의 디렉토리로 Linux kernel설정에서 필요한 디바이스들이
	  위치하는 디렉토리.
/root	: system user의 홈디렉토리.
/sbin	: Linux kernel에서 필요한 module설정 파일이 위치하는 디렉토리.
/tmp	: 각 장치에 필요한  socket 및 log 파일들이 위치하는 디렉토리.
/usr	: Linux에서 사용하는 모든 어플리케이션 및 시스템 파일들이 위치하는
         디렉토리로써,  Library화일, 실행파일들이 들어있다. 

	[shell의 구조]
	★ 쉘(shell)이란?
	사용자와 리눅스 커널 사이의 인터페이스로 사용되는 프로그램을 통칭한다. 즉, 사용자가 프롬프트에서 어떠한 행위를 하면 그것이 리눅스 커널에 전달이 되고 리눅스 커널은 입력된 명령어들에 대한 결과치를 출력을 해주게 되는 형태를 말한다. shell은 명령어 변환기이며 자신 고유의 내부적인 shell 명령어의 집합을 가지고 있다. 이러한 명령을 수행케 해주는 shell에는 다양한 형태가 있는데, bash, csh, tcsh, ksh, pdksh, zsh 등 다양한 종류의 shell이 존재한다.



                                                   리눅스


                                       리눅스        커널
          사용자                          쉘
   2. 리눅스 Kernel에 관하여 [커널 소스 디렉터리 중심으로]

☞ Documentations : Linux kernel에서 지원하는 모든 하드웨어 설정 및 정보 등 kernel을 설정하는데 있어서 모든 정보를 담고 있는 subdirectory 이다.

☞ arch
 Additional platform support
 → Linux kernel runs on the following platforms.
   O alpha
   O i386
   O mips
   O ppc
   O sparc
   O M68K(Amiga)

☞ Include
  → Include 서브디렉토리는 기본적인 커널 코드의 헤더 파일들을 포함하는
    디렉토리이다.
  → Include/ 밑의 Linux system에서 지원하는 OS(operating system) 
     header file 들을 /usr/include으로 soft Link 주는 구조를 가지고 있다.
 
☞ init (system startup and Initialization)
   → Intel기반으로 하는 시스템 구조에서, loadlin.exe & LILO프로그램으로써
      system boot 할 때에 arch/i386/kernel/head.S파일이 커널 내부의 메모리 및
      시스템 컨트롤을 하는 파일들의 집합체.
   → Head.S란.? init/main.c코드의 main()함수의 일련의 명령군을 통제 및 제어를
      하는 특수한 구조를 가졌다.

☞ mm (Memory Management)
   → 잘못된 연산을 수행하는 코드를 제어하는 memory.c code 및 메모리 매핑 및
      캐쉬역할을 하는 filemap.c code, 불안정한 버퍼 코드를 제어하는 buffer.c
      code, swap를 제어하는 ?swap_state.c, swapfile.c" code로 구분된다.

☞ Kernel
   → The Scheduler is in kernel/sched.c and the fork code is in kernel/fork.c.
   → The bottom half handling code is in include/linux/interrupt.h.
   → The task_struct data structure can be found in include/linux/sched.h.
☞ IPC (Interprocess Communication)
   → ipc_perm 데이터 구조 및 include/linux/ipc.h 헤더 파일들을 이용하여 모든 
      System V IPC 오브젝트를 포함한 헤더 및 소스 코드를 포함한다.

☞ fs (File Systems)
   → Linux에서 사용하는 ext2파일 시스템의 모든 헤더파일 및 소스코드를 내포
      하고, include/linux/ext2_fs.h, ext2_fs_i.h, ext2_fs_sb.h헤더파일을 내포하며
      ext2파일 시스템의 데이터 구조를 정의하는 디렉토리이다.

☞ net (Network)
   → Linux networking에 필요한 include/net헤더 파일 및 소스 코드를 포함하며,
      BSD 소켓을 지원하는 net/socket.c, IPV4 소켓 코드를 지원하는
      net/ipv4/af_inet.c 및 네트웍 디바이스 드라이브를 포함하고 있다.
   → The network devices drivers are in drivers/net.

☞ modules
   → Linux kernel에서의 모듈 기능을 구현하는 디렉토리.
   → Linux kernel에서 모듈 기능을 컴파일 하면 정적으로 링크를 시켜주는
      디렉토리.

☞ lib (kernel Library)
   → 커널 설정에 필요한 라이브러리 코드를 내포하는 디렉토리.

☞ Scripts
   → 커널을 설정하는데 있어서, make xconfig 및 make menuconfig에 필요한
      awk 및 tk스크립트를 포함하고 있는 디렉토리.

☞ Drivers
   → Linux System's 에 필요한 디바이스 드라이버를 포함하는 디렉토리.


   3. X-Window System에 관하여) http://kldp.linux-kr.org/ 참고


	[역사]
	유닉스용 GUI interface라고 할 수 있는 X-windows는 MIT와 DEC사에 의한 Athena 프로젝트에 의해 처음으로 개발되었다. X-windows라는 이름은 스탠포드 대학에서 개발한 W 윈도우 시스템을 따라 그 다음 알파벳인 X를 사용한 것이라고 한다. X-windows는 1985년 MIT의 라이센스 포기 이후 많이 보급되었다. 현재는 유닉스 등의 운영체제에 기본적인 시스템으로 도입되어있다. 또한 MIT의 XFree86 프로젝트는 일반 개인용 운영체제에서도 돌아갈 수 있도록 하였다.

	X-windows의 X11 Revision 6는 1994년 4월에 발표되었고, 지금은 유닉스계에서는 거의 표준으로 자리잡았다. 현재는 컴퓨터 회사들로 결성된 X컨소시엄에서 개발을 맡고 있다. X-windows는 자유롭게 배포될 수 있는 라이센스를 갖고 있다. 리눅스에서의 X-windows도 그 중에 하나이다. 리눅스가 사용하는 것의 정확한 이름은 XFree86이다. 이것은 MIT의 X386서버로부터 발전한 것이다.

	[구조]
	X-windows가 유닉스용 GUI이므로 네트워크 시스템에 알맞게 되어있어야 한다. 즉, 여러 가지 다른 시스템을 하나의 방식으로 묶어 관리할 수 있도록 할 필요가 있었다. 그래서 서버와 클라이언트 개념을 도입했고, 이에따라 프로그램 개발자는 각각의 아키텍쳐를 신경쓰지 않고도 개발을 할 수 있으며 각각의 아키텍쳐에 맞도록 운용되므로 그 시스템 나름의 장점을 활용할 수 있다. 이것이 바로 프로그램에 높은 이식성을 부여하는 원인이 된다.
	 X-windows 시스템을 이루는 것을 다음 4가지로 나눌 수 있다.
	 >> X 서버
	 >> X 클라이언트
	 >> X 프로토콜
	 >> X 라이브러리

	Server-Client : 기본적으로, 클라이언트는 응용프로그램을 말한다. X 윈도우 클라이언트는 직접적으로 사용자와 통신할 수 없다. 클라이언트는 서버로부터 키보드 누름이나 마우스 버튼의 누름같은 사용자의 입력을 얻을 수 있다. 클라이언트는 서버가 그림을 그리도록 요구하는 X 윈도우 명령을 실행한다. X 서버란 애플리케이션 사용자의 컴퓨터에서 작동하며 그래픽 디스플레이 하드웨어를 제어하고 입출력을 담당한다. X 서버는 X 클라이언트 애플리케이션이 스크린에 무엇인가를 그리거나 키보드와 마우스로부터 입력을 받으라는 요청을 받아 처리한다. 마우스 이동과 버튼 눌림 같은 입력 신호를 클라이언트 프로그램에 전달도 한다. 또한 복잡한 데이타 구조체들을 관리한다. 서버의 이들 구조체 관리는 클라이언트의 저장 장치와 프로세싱을 감소시킨다. 이것은 네트웍을 통한 데이타의 전송량을 줄이기 위해 필요하다.  하드웨어와 밀접한 X 서버는 각각의 하드웨어마다 다른 서버가 존재한다.

	X protocol : X Window에서 각종 처리는 클라이언트와 서버라는 두가지 프로그램이 나누어서 하고 있다. 즉 클라이언트는 IPC를 이용하여 서버의 장치 입출력을 제어한다. 이러한 X 서버와 X 클라이언트의 상호 작용은 메세지 교환을 통해 이루어지는데, 메세지 형태와 사용법을 X 프로토콜이라 한다. X-windows의 중요한 특징 중 하나가 이러한 메세지 교환이 같은 컴퓨터 뿐이 아닌 네트워크를 통해서도 이루어질 수 있다는 것이다. 그렇기에, 시스템 사양이 낮은 컴퓨터 사용자도 네트워크 컴퓨터에 존재하는 X 클라이언트 프로그램을 자신의 화면에 표시하여 실행시키는 것이 가능한 것이다. X protocol은 서버와 클라이언트 사이에서 통신되는 Request, Reply, Event, Error 의 기본 메시지이다. 클라이언트가 윈도우를 생성해달라거나 도형을 출력해달라는 요구를 request queue에 넣어 서버에게 보내면, 서버는 하드웨어를 제어, 화면에 디스플레이한 후 답신을 보낸다. 또한 서버는 하드웨어로부터 들어오는 입력(예를 들어, 마우스나 키보드의 입력)을 받아들여 event queue에 넣어 클라이언트에 보내면 클라이언트가 그에 따른 처리를 한다.
	리눅스 IPC(Inter-process communication)은 여러 프로세스들이 다른 프로세스와 통신할 수 있는 방법을 제공한다. 리눅스 C 프로그래머들이 이용할 수 있는 IPC 방법에는 아래와 같은 몇가지가 있다. 

       반이중 유닉스 파이프 (Half-duplex UNIX pipes) 
       FIFOs (named pipes) 
       SysV 스타일 메세지 큐 (SysV style message queues) 
       SysV 스타일 세마퍼 집합 (SysV style semaphore sets) 
       SysV 스타일 공유메모리 세그멘트 (SysV style shared memory segments) 
       네트워킹 소켓 (버클리 스타일) (Networking sockets (Berkeley style)) 
       전이중 파이프 (Full-duplex pipes (STREAMS pipes) 

이러한 방법들이 효과적으로 사용될 때, 리눅스를 포함한 모든 유닉스 시스템에서의 클라이언트/서버 개발을 위한 견고한 프레임웍크(framework)를 제공한다.

	Xlib, X toolkit : X에서의 프로그램 개발은 시스템의 OS나 하드웨어에 의존적인 조작을 처리해주는 서버와 대화할 수 있도록 X protocol을 이해해야 한다. 그런데 이 X protocol은 Xlib라는 라이브러리 루틴으로부터 발생시킨다. 그러나 Xlib의 기능은 그다지 많지 않다. 화면에 그림을 그리고 마우스에 반응하는 등의 기능만을 갖고 있다. 즉, 저수준 인터페이스이다. 그래서 이것보다 상위 라이브러리인 X toolkit을 사용한다. Xt Intrinsics, Xaw, XView, Motif, Qt, GTK 등이 그것이다. 

	[X 실행순서]
	우리는 X-windows를 구동하기 위해 startx라는 명령어를 사용한다. 그런데, 이 startx 명령은 바이너리로 된 파일이 아니라 스크립트 파일이다. 즉 편집기로 불러서 편집을 할 수 있다. 이 파일은 xinit을 실행시킨다. 그러면 xinit프로세스는 xinitrc의 설정을 참조하여 X 서버를 구동시킨다.

	[활용]
디렉토리 구조와 파일의 역할
① 디렉토리
[실행 파일 디렉토리 : /usr/X11R6/bin]
	 : 기본적으로 X 윈도우 서버와 기본적인 바이너리 파일이 저장되어있다.
[헤더 파일과 라이브러리 : /usr/X11R6/include, /usr/X11R6/lib]
	 : X 윈도우 프로그래밍을 위한 기본 라이브러리 XLIB, X11,
	 Xt intrinsics,Xaw(3d) 가 존재한다. 그리고 Motif까지 설치했다면 Xm
	 헤더 파일 및 라이브러리 파일이 존재한다.
[리소스와 설정 파일 : /usr/X11R6/lib/X11, /var/X11R6/lib]
	 : 두 개의 디렉토리는 링크로 연결되어있다. 이 안에는 여러개의
	 디렉토리가 있는데, 그중 app-defaults라는 디렉토리가 여러 가지
	 프로그램의 리소스 파일이 들어있는 디렉토리이다.
	 xinit디렉토리에는 X 윈도우를 구동할 때 필요한 기본 설정 파일들이 	 저장되어있다. 또한 윈도우 매니져 설정 파일, 지역화와 국제화를 위한
	 locale 데이터도 저장되어있다.
[글꼴 디렉토리 : /usr/X11R6/lib/fonts]
	 : X 윈도우와 프로그램들에 필요한 글꼴들이 저장되어있다.
[메뉴얼 페이지: /usr/X11R6/man]
	 : X 윈도우에 필요한 man 페이지(도움말)가 저장되어있다.

② 파일들의 역할
XF86Config (/etc/X11/XF86Config, /usr/X11R6/lib/X11/XF86Config)
	: X를 설치하고 xf86config를 실행시키면 생성되는 파일로 XFree86의
	 설정파일이다. 폰트의 경로, 마우스, 비디오카드, 모니터 클럭, 해상도 같은
	 것을 설정한다.
xinitrc (/etc/X11/xinit/xinitrc, $HOME/.xinitrc)
	: X 서버를 띄울 때 참조하는 설정파일이다. 홈디렉토리의 .xinitrc파일을 
	 우선적으로 적용하고, 그 파일이 없으면 /etc/X11/xinit/xinitrc을 참조한다.
	 이 파일에는 사용자 정의 파일인 Xresources 파일 정의와 사용할 윈도우
	 매니저, 응용 프로그램을 적어둔다.
Xdefaults ($HOME/.Xdefaults)
	: Xdefaults 파일은 홈 디렉토리에 있어야하며, 특정 프로그램이 요구하는
	 환경 변수를 지정한다. 
Xmodemap ($HOME/.Xmodmap)
	: 키보드를 정의하는 파일로 키 코드를 Ascii 코드로 바꾼다.

	이외에도 각각의 클라이언트는 /usr/lib/X11/app-defaults라는 디렉토리에
	각각의 리소스 파일을 가지고 있다.

	[윈도우 메니저에 대하여]
	윈도우 메니져는 X 윈도우 시스템의 외형을 결정짓는 프로그램이다. 윈도우 메뉴의 구성, 마우스 버튼의 동작, 스크롤바, 아이콘 등을 이 윈도우 메니져가 결정하는 것이다. Shell의 종류가 여러 가지가 있고, MS-Windows에서도 프로그램 매니저 외에 다른 프로그램들을 shell로 사용할수 있듯이 XFree86에서도 사용하는 윈도우 메니저가 여러 가지가 있다. 많이 사용되는 것으로 twm, fvwm(가장 널리 사용됨), olvwm(Xview[TM] package로부터 사용), mwm(Motif[TM]의 부분), WindowMaker, AfterStep, NeXTSTEP 등이 있다. 윈도우 메니저마다 모양과 기능의 차이가 있고, 마우스 버튼을 사용하는 것도 차이가 있다. XFree86이 실행되면 위의 윈도우 매니저 중 하나로, 혹은 2개 이상의 매니저로 실행된다. 각각의 매니저별로 약간의 구성과 마우스 키, 메뉴 등에 차이가 있다. 만약, 이 매니저 중 아무것도 실행이 안된다면 윈도우 같은 것이 뜨지만 한 쪽 구석에 single tasking 모듈의 화면 하나가 나올 뿐이다. 이 상태에서는 단지 하나의 콘솔 상태와 비슷한 상황인데, 여기에서 'fvwm&'이라고 치면 매니저가 실행된다.

① fvwm
	가장 많이 사용되는 윈도우 매니저로 'startx'로 X윈도우를 구동하면 나타나는 윈도우 매니저이다. 마우스 버튼 3개를 모두 사용한다.
  # 왼쪽 버튼 : 윈도우의 백그라운드에서 X용 프로그램 메뉴를 부른다.
  # 가운데 버튼 : 윈도우 메뉴를 호출한다. 백그라운드에서 부를 수 있고,
                 윈도우의 타이틀 바에서 윈도우 메뉴를 호출할수 있다.
                 백그라운드에서 윈도우 메뉴를 호출하면 선택된 것은
                 어느 윈도우에 지정할 수 있고, 타이틀 바에서는 그
                 윈도우에 한정된다. 가운데 버튼이 없는 마우스는
                 두 개의 버튼을 동시에 누르면 된다.
  # 오른쪽 버튼 : 현재 실행되고 있는 윈도우의 리스트를 보여준다.
                 MS-Windows의 작업관리자와 같은 역할이다.

② olvwm, olwm
	olvwm은 openwin으로 윈도우를 실행했을 때 사용되는 윈도우 매니저이다. 이것은 썬 스팍스테이션의 OpenWindow와 비슷한 인터페이스이다. 화면이 단순하고 화려하지 않다. 마우스 오른쪽 버튼으로 프로그램을 호출한다. olvwm은 olwm에 가상 화면을 사용하도록 기능을 추가한 것이다. 마우스의 오른쪽 버튼으로 프로그램을 호출한다. 여기에 등록된 메뉴로 거의 모든 어플리케이션을 실행할 수 있다.

③ mwm
	mwm은 Motif의 윈도우매니저로 리눅스에 기본적으로 들어 있는 것은 아니다. Motif는 상용이며 X윈도우의 하나의 표준이다. Moif용으로 개발된 프로그램은 컴퓨터의 기종에 상관없이 소스를 가져와 컴파일하는 것만으로 다른 기종의 컴퓨터에 이식할 수 있다는 장점이 있다.
  mwm은 fvwm과 비슷하게 오른쪽 마우스 버튼으로 프로그램 매니저를 대신 하지만 fvwm에 비해 기능이 현저히 적다. 프로그램을 실행하기 위해서는 xterm을 하나 실행할 수 프롬프트 상태에서 입력하거나 파일 매니저에서 실행해야 한다.

④ WindowMaker
	WindowMaker는 최근에 나온 윈도우 매니저이다. NeXTSTEP의 모습과 비슷한 윈도우 매니저이기도 하다. 설치와 설정이 간단하고 메뉴편집이나 여러가지 면에서 간단하고 쉬우며 또 멋진 화면을 구성할 수 있다. 설정파일은 설치하고 난 후 홈디렉토리에서 wmaker.inst를 실행하면 생기는 GNUstep 디렉토리에 모여있다. $HOME/GNUstep/Defaults/ 안에 있는 네 개의 파일(WMRootMenu,WMState, WMWindowAttributes,WindowMaker)과 $HOME/GNUstep/Library/WindowMaker안에 있는 menu파일이 그것이다.

	[XDM(X Display Manager)]
	Login하고 나서 자동적으로 X를 실행시키려면 사용하는 쉘에 따라, .profile이나  .login같은 파일에 startx 명령어를 적어두면 되지만, 아예 처음부터 X 터미널처럼, 부팅하자마자 X로 로그인하려면 xdm을 이용하면 된다.
 /etc/inittab 파일에서

	# Default runlevel. The runlevels used by RHS are:
	#   0 - halt (Do NOT set initdefault to this)
	#   1 - Single user mode
	#   2 - Multiuser, without NFS (The same as 3, if you do not have networking)
	#   3 - Full multiuser mode
	#   4 - unused
	#   5 - X11
	#   6 - reboot (Do NOT set initdefault to this)
	id:3:initdefault:

라는 줄이 있는데, 보시다시피 5번 레벨이 X 전용모드이다. 따라서 이것을 id:5:initdefault:로 바꿔주고 리부팅시키면, X가 실행되면서 로그인 화면이 나온다. xdm을 사용할때에는 사용하려는 윈도우 매니저 등의 설정을 /usr/lib/X11/xdm 디렉토리의 Xsession 파일이나 홈디렉토리의 .Xsession 파일에 적으면 된다. 단, 홈디렉토리의 .Xsession파일을 사용할때에는 실행퍼미션이 주어져있는지 보아야 한다. 실행퍼미션이 없으면 동작하지 않는다.

	[개발 환경(GUI library)]
	예전에는 GUI환경이 중요시되지 않았으나 시간이 지나면서 윈도우가 생기고, 더욱 편한 인터페이스에 대한 사용자의 요구가 늘어남에 따라 GUI를 위한 라이브러리가 필요해졌다. 모티프가 나오면서 유닉스계에서는 모티프를 많이 사용하였고, 그러한 추세는 현재까지 이어진다. 그러나 리눅스에서는 모티프가 상용이어서 널리 쓰이지 못하고 Xlib, Xt, Xaw, XView등을 사용하거나 모티프 클론인 lesstif를 사용하였다. 하지만 모티프 스타일도 세련되지 못한 인터페이스로 새로운 라이브러리 개발이 요구되며 이미 활발히 진행되고 있다. 또한 라이브러리와 윈도우 매니저, 이를 뒷받침하는 어플리케이션 집합으로 구성된 데스크탑 프로젝트의 개발이 활발하다. Qt-KDE, GTK-GNOME 등이 그 예이다.
Ⅲ. 리눅스의 활용
   1. 리눅스 & Networking
	일반적으로 네트워크 설정은 콘솔상에서 가능하지만 레드햇의 netcfg툴(X윈도우 환경)을 사용하면 설정하기 쉽다. 이를 알아보자. 설명에 앞서 커널내에서 네트워크카드(일반적으로 말하는 랜카드)설정은 되어 있는 걸로 한다.
 
















우선 위의 그림을 참고로 설명을 해보자 이 부분에서 설정하는 것은 컴퓨터의 Hostname, Domain과 Search domain name 그리고 중요한 Nameserver 설정부분이다.

 Hostname
	이 부분은 네트워크에 물린 컴퓨터의 네임설정 탭이다. 이 부분에 자신의 호스트 네임을 써주자.
  예) host.yourname.com

 Domain
	도메인 네임 설정 부분이다. 할당된 도메인부분의 도메인만 적으면 된다. 위에 호스트 네임의 뒷부분을 적어주면 되는 것이다.
  예) yourname.com

 Search for hostnames in additional domains
	일반적으로 네트워크에 물린 컴퓨터는 각자 도메인 네임을 받을수 있다. 이럴 때 호스트네임만을 쳐주기만 해도 그 컴퓨터를 네트워크 억세스 할 수 있는데 이것은 이 설정부분에 도메인 네임 뒷부분에 붙을 도메인을 적어줌으로써 가능하다. 순차적으로 검색을 한다.

 예) clug.net
    domain.net
이라고 설정되어 있고 자신의 컴퓨터의 호스트네임을 hostname이라고 할 때,

# telnet hostname

이라고 친다면 우선 clug.net을 붙여서 검색을 한다. hostname.clug.net이 액세스하고자 하는 도메인 네임이 되는 것이다. 만일 hostname.clug.net이 검색대상에 없다면 hostname.domain.net을 찾게 된다. 이런식으로 하면 사용자가 도메인 서브에 물린 상태에서 일일이 도메인을 다 칠 필요없이 호스트네임만을 쳐줌으로써 액세스 가능하다. 따라서 설정을 안하여도 상관은 없다는 것이다.

 Nameservers
	이부분은 위의 도메인네임을 검색하는 네임서버를 지정하는 것이다. 간단하게 도메인 네임이 등록되어 있는 서버를 지정하여도 좋고 좀더 빠른 도메인 서버가 있다면 추가하여도 무방하다. 이곳에는 당연히 ip를 적어주어야 한다.
 

















이 화면은 로컬 컴퓨터내에 ip와 닉네임을 적어줄수 있다. alias이라고 생각하여도 무방하다.
예를 들어

 ip:200.200.200.200	Name:moon	Nicknames: dall

이었을 경우 ip부분을 네임 서버에서 찾기전에 우선 이 설정 부분을 먼저 검색하게 되어서

# telnet moon

이라고 명령을 주었을 경우 ip를 바로 찾게 되는 것이다.
간단하게 말하면 로컬 네임 서버의 기능이라고 볼 수도 있을 것이다. 이부분은 /etc/hosts파일에 저장된다.
 

















이 화면은 네트워크가 나가는 interface를 설정하게 되어 있다. 즉 컴퓨터에 꼽힌 카드를 액세스 할 수 있는 부분을 설정하게 되어 있다.
일반적으로 랜카드가 없다면 lo부분(localhost)부분만이 설정되어 있다. 로컬넷만을 접속하려면 이것을 써도 무방하다. 가상 랜카드의 역할을 하기 때문이다. 
 만일 랜카드가 커널내에 잡혀있다면 이를 네트워크 인터페이스 설정으로 억세스할수 있게 해야한다. 그러기 위해서 추가를 하려면 add탭을 누르고 ethernet부분 탭을 선택(ppp와 기타 타입을 설정하는 부분)하면 eth*이름으로 나오게 되어 있다. 첫 번째 카드라면 eth0가 될 것이다. 두 번째 카드라면 eth1 이런식으로 이름이 생성된다. 
이 부분에서 설정할 것을 정리해보면
 ip: 컴퓨터에 할당된 ip를 적는다.
 netmask: 네트워크 억세스 대역을 설정하는 것으로 일반적으로 255.255.255.0으로 설정하면 될 것이다.
그 다음에 부팅할 때마다 이 인터페이스를 자동으로 활성화시키기 위하여 Activate를 체크해준다. 일반사용자가 인터페이스를 (비)활성화 시킬 수 있는 옵션을 설정(안하는 것이 좋을듯)할 수 있다. 
 protocol: configuration하는 protocol을 설정하는 것으로 보통은 none으로 하지만 dhcp나bootp를 설정할 수 있다.
 
















아래화면은 gateway 디바이스와 ip를 설정할 수 있다. 
Network Packet Forwarding(IPv4): Packet Forwarding의 유무를 체크, 일반적으로 No
Default Gateway: 실제 게이트웨이 ip를 설정한다. 일반적으로 AAA.BBB.CCC.1
Default Gateway Device: 게이트웨이로 나가는 디바이스 설정 eth*식으로 하면 된다.
추가적으로 설정하려면 Add버튼을 누르고 추가하면 된다.
Save로 저장한다.
만일 netcfg를 쓰지 않고 설정을 하려면(수정을 가하기 위해서) 다음 파일을 참조하라.
/etc/hosts, /etc/sysconfig/network, /etc/sysconfig/network-scripts/ifcfg-eth*

   2. 리눅스 & Internet Service

o apache 설정하기.
 --> httpd.conf 설정.
서버 유형(ServerType)은 inetd 또는 standalone 둘 중의 하나입니다. 특별한 이유가 없는 한 standalone 즉 독립형으로 실행합니다.

ServerType standalone

만약 수퍼 서버인 inetd 로부터 실행하는 것이라면 "ServerAdmin" 을 참고한다.

Port: standalone 모드인 경우 경청하는 포트를 가리킵니다. 1023 이하의 포트를 사용하려면 초기에 httpd 를 루트로 실행해야만 합니다.

Port 80

호스트 이름 조회(HostnameLookups): 클라이언트의 이름 또는 IP 주소 중 어떤 것을 기록할 것인가 결정합니다.

  예)   www.apache.org (on) 또는 204.62.129.132 (off)

기록 파일의 정보를 실제로 사용하거나 CGI 용도로 사용하기 위해서는 off로 해두어야 좋습니다.  on 이라고 해두면 여러분의 사이트로 접근하는 속도를 느리게 만드는 단점이 있습니다.

HostnameLookups off

httpd 가 다른 사용자, 다른 그룹으로 실행되길 원한다면 일단 httpd를 루트 권한으로 실행한 후 주어진 사용자, 그룹으로 전환해야 합니다.

사용자/그룹(User/Group): httpd 가 실행될 때 프로세스의 소유 권한을 갖는 사용자/그룹에 대한 이름을 정합니다.

HostnameLookups off
httpd 가 다른 사용자, 다른 그룹으로 실행되길 원한다면 일단 httpd를 루트 권한으로 실행한 후 주어진 사용자, 그룹으로 전환해야 합니다.

사용자/그룹(User/Group): httpd 가 실행될 때 프로세스의 소유 권한을 갖는 사용자/그룹에 대한 이름을 정합니다.

User nobody
Group nobody

다음 지시자(directive)들은  스푸핑을 하는 네스케이프 2.x 와 기타 브라우져들에 대하여 keepalive와 헤더 플러쉬를 끄도록 합니다.

BrowserMatch Mozilla/2 nokeepalive
BrowserMatch Java1.0 force-response-1.0
BrowserMatch JDK/1.0 force-response-1.0

서버관리자(ServerAdmin): 서버에 문제가 발생했을 때 연락을 취할 메일 주소를 정합니다.

ServerAdmin root@localhost

서버루트(ServerRoot): 서버의 설정, 에러, 로그 파일 등이 놓일 기본 상위 디렉토리이다.

ServerRoot /etc/httpd

결합주소(BindAddress): 이 옵션을 가지고 가상 호스트를 지원할 수 있습니다. 이 옵션은 서버가 어느 IP 주소에 귀기울일 것인지 통보할 때 사용합니다. "*" 이거나 또는 IP 주소 그리고 완전한 형식의 도메인 이름을 사용할 수 있습니다.  VirtualHost 지시자도 함께 참고하시기 바랍니다.

#BindAddress *

에러기록(ErrorLog): 에러 기록 파일의 위치. / 로 시작하지 않으면 ServerRoot 가 경로명 앞에 붙습니다.

ErrorLog /var/log/httpd/error_log
전송기록(TransferLog): 전송 기록 파일의 위치. / 로 시작하지 않으면 ServerRoot 가 경로명 앞에 붙습니다.

TransferLog /var/log/httpd/access_log

PID 파일(PidFile): 서버가 자신의 PID를 기록해 둘 파일 

PidFile /var/run/httpd.pid

ScoreBoardFile: 서버의 내부 처리 정보를 기록해 둘 파일. 모든 아키텍쳐에서 이를 필요로 하지는 않습니다.  만약 필요하다면 (이 파일을 아파치가 실행되면 생성된다는 것을 알게 될 겁니다.) 이 점은 잘 알아두어야 합니다.  아파치를 여러 개 실행시키는 경우에는 이 파일이 중복 사용되지 않도록 유의해야 합니다.

ScoreBoardFile /var/run/apache_status

서버이름(ServerName)은 프로그램이 받게 되는 호스트 이름과 다른 서버 이름을 클라이언트에게 보내려 할 때 설정합니다. 여기서 정의하는 이름은 여러분의 호스트에 대하여 정확히 설정되어 있는 DNS 이름이어야 합니다.  

#ServerName new.host.name

CacheNegotiatedDocs: 기본적으로 아파치는 내용을 기준으로 하여 협상한 문서에 대해서는 Pragma: no-cache 를 각 문서마다 보냅니다. 이 메시지는 프록시 서버로 하여금 문서를 캐쉬하지 않도록 요청합니다. 다음 행의 주석을 풀면 이 기능을 해제하고 프록시 서버가 문서를 캐쉬할 수 있도록 허용합니다.

#CacheNegotiatedDocs

Timeout: 받고 보내는데 타임 아웃이 걸리도록 하는 시간 (초)

Timeout 300

KeepAlive: 지속적인 접속을 허용할 것인지 말 것인가 결정하는 부분이다. "Off"로 하면 이 기능을 정지시킵니다.

KeepAlive On
MaxKeepAliveRequests: 지속적인 접속 동안 허용할 최대 요청 수 이 값을 0 으로 하면 제한을 두지 않습니다.  최대 효율을 위해서는 이 값을 가능한 높게 두길 권장합니다.

MaxKeepAliveRequests 100

# KeepAliveTimeout: 다음 번 요청을 기다리다 타임 아웃이 걸리게 하는 시간(초)

KeepAliveTimeout 15

서버-풀 크기 조정.  몇 개의 서버 프로세스가 필요한지 계산할 필요없이 아파치는 자동으로 부하량에 따라 적응합니다. 현재의 부하 상태를 처리할 수 있을 정도의 충분한 서버 프로세스를 유지하며 일시적으로 치솟는 부하를 예상하여 여분의 프로세스를 만들어둡니다.

아파치는 정기적으로 얼마나 많은 서버가 요청을 기다리고 있는지 점검합니다. 만약 MinSpareServers 보다 작으면 여분의 서버를 만들어 둡니다. MaxSpareServers 보다 많으면 나머지 서버를 종료시킵니다. 대부분의 사이트에 대하여 다음 값이면 충분하다고 봅니다.

MinSpareServers 8
MaxSpareServers 20

# 시작할 때의 서버 갯수 - 적절한 값으로 어림잡아 계산합니다.

StartServers 10

서버 실행 총 갯수를 제한합니다.  즉 클라이언트들이 동시에 접속할 수 있는 수를 제한합니다.  이 값에 도달하게 되면 클라이언트들은 무작정 기다리는 상태로 빠지므로 너무 낮게 책정해서는 안됩니다. 급격하게 부하가 많아짐으로써 웹 서버가 유닉스와 함께 나락에 빠지지 않도록 브레이크를 걸어두기 위한 용도로 사용된다.

MaxClients 150

자식당 최대 요청수(MaxRequestsPerChild): 자식 프로세스가 죽기 전에 처리할 최대 요청의 개수 아파치(또는 아파치가 사용하는 라이브러리)를 장시간 사용함으로써 생기는 문제들을 막기 위해 자식 프로세스가 종료합니다. 대부분의 시스템에서는 이것이 필요치 않지만 몇몇(예를 들어 Solaris) 시스템 의 경우 라이브러리로부터 발생하는 메모리 유출이 높기 때문에 필요합니다.

MaxRequestsPerChild 100

프록시 서버 지시자.  프록시 서버 기능을 작동시키시려면 다음 행의 주석을 풀어주십시오.

#ProxyRequests On

캐쉬 기능을 작동시키려면 다음 행들의 주석을 풀고 적절하게 편집하십시오.

#CacheRoot /var/httpd/proxy
#CacheSize 5
#CacheGcInterval 4
#CacheMaxExpire 24
#CacheLastModifiedFactor 0.1
#CacheDefaultExpire 1
#NoCache a_domain.com another_domain.edu joes.garage_sale.com

Listen: 아파치를 기본값에 추가하여 특정 IP 주소들 또는 포트와 결합(bind) 시키려 할 때 사용합니다.  VirtualHost 명령 또한 참고하십시오.

#Listen 3000
#Listen 12.34.56.78:80

가상호스트(VirtualHost): 서버 머신이 여러 주소에 대하여 IP 패킷을 받을 수 있도록 설정한 상태에서 아파치 데몬이 하나의 이상의 서버 주소에 대하여 요청을 처리할 수 있도록 해줍니다.
ifconfig alias 플래그 또는 VIF 와 같은 커널 패치를 통해 할 수 있습니다.

모든 httpd.conf, srm.conf 지시자를 VirtualHost 명령 안에 적을 수 있습니다.
BindAddress 항목 또한 참고하시기 바랍니다.

#<VirtualHost host.some_domain.com>
#ServerAdmin webmaster@host.some_domain.com
#DocumentRoot /www/docs/host.some_domain.com
#ServerName host.some_domain.com
#ErrorLog logs/host.some_domain.com-error_log
#TransferLog logs/host.some_domain.com-access_log
#</VirtualHost>

 --> srm.conf 설정.
DocumentRoot: 여러분의 문서를 제공할 디렉토리 기본적으로 모든 요청은 이 디렉토리로부터 제공됩니다.  하지만 심볼릭 링크나 alias를 사용하여 다른 위치를 가리킬 수 습니다. 

DocumentRoot /home/httpd/html

사용자 디렉토리(UserDir): ~user 요청을 받았을 대 사용자의 홈 디렉토리 뒤에 붙일 디렉토리의 이름

UserDir public_html

디렉토리 인덱스(DirectoryIndex): 약속된 HTML 디렉토리 인덱스로 사용할 파일의 이름이다. 여러 개를 적을 때는 스페이스로 구분합니다.

DirectoryIndex index.html index.htm index.shtml index.cgi

FancyIndexing 항목은 디렉토리를 예쁘게 인덱스해서 보여 줄 것인지 아니면 기본적인 형식으로만 보여 줄 것인지 결정합니다.

FancyIndexing on

AddIcon 지시자는 서로 다른 파일, 파일 확장자에 대하여 어떤 아이콘을 사용할 것인지 결정합니다.

AddIconByEncoding (CMP,/icons/compressed.gif) x-compress x-gzip

AddIconByType (TXT,/icons/text.gif) text/*
AddIconByType (IMG,/icons/image2.gif) image/*
AddIconByType (SND,/icons/sound2.gif) audio/*
AddIconByType (VID,/icons/movie.gif) video/*

AddIcon /icons/binary.gif .bin .exe
AddIcon /icons/binhex.gif .hqx
AddIcon /icons/tar.gif .tar
AddIcon /icons/world2.gif .wrl .wrl.gz .vrml .vrm .iv
AddIcon /icons/compressed.gif .Z .z .tgz .gz .zip
AddIcon /icons/a.gif .ps .ai .eps
AddIcon /icons/layout.gif .html .shtml .htm .pdf
AddIcon /icons/text.gif .txt
AddIcon /icons/c.gif .c
AddIcon /icons/p.gif .pl .py
AddIcon /icons/f.gif .for
AddIcon /icons/dvi.gif .dvi
AddIcon /icons/uuencoded.gif .uu
AddIcon /icons/script.gif .conf .sh .shar .csh .ksh .tcl
AddIcon /icons/tex.gif .tex
AddIcon /icons/bomb.gif core

AddIcon /icons/back.gif ..
AddIcon /icons/hand.right.gif README
AddIcon /icons/folder.gif ^^DIRECTORY^^
AddIcon /icons/blank.gif ^^BLANKICON^^

DefaultIcon은 위에서 명시적으로 설정되어 있지 않은 파일에 대하여 사용하는 아이콘입니다.

DefaultIcon /icons/unknown.gif

AddDescription 은 서버가 생성한 인덱스 파일 뒤에 간단한 설명을 추가하고자 할 때 사용합니다.

ReadmeName 은 서버가 기본적으로 찾는 README 파일의 이름을 나타냅니다.

HeaderName 은 디렉토리 인덱스 앞에 붙는 파일의 이름을 나타냅니다.

ReadmeName README
HeaderName HEADER

IndexIgnore 는 디렉토리 인덱스에서 제외될 파일 이름을 정합니다.

형식: IndexIgnore name1 name2...

IndexIgnore */.??* *~ *# */HEADER* */README* */RCS

AccessFileName: 접근 제어 정보를 관리하기 위해 각 디렉토리에서 찾아 볼 파일 이름을 정합니다.

AccessFileName .htaccess
DefaultType 은 서버가 파일명 확장자로부터 파일 유형을 판단할 수 없을 때 문서에 대하여 가정할 기본 MIME 유형입니다.

DefaultType text/plain

AddEncoding 은 몇몇 브라우저(Mosaic/X 2.1+)가 전송받으면서 내용의 압축을 풀 수 있도록 허용할 때 씁니다.  

AddEncoding x-compress Z
AddEncoding x-gzip gz

AddLanguage 는 문서의 언어를 명시할 수 있게 해줍니다.  이 기능을 사용하면 브라우져가 이해할 수 있는 언어로 된 파일 내용에 대한 협상을 할 수 있습니다. 파일접미사가 언어 키워드와 똑같을 필요는 없습니다.

AddLanguage ko .ko
AddLanguage en .en
AddLanguage fr .fr
AddLanguage de .de
AddLanguage da .da
AddLanguage el .el
AddLanguage it .it

언어우선권(LanguagePriority)은 내용 협상 중 동률을 차지하는 경우 언어의 우선권을 정합니다. 우선권이 먼저인 것을 먼저 적습니다.

LanguagePriority ko en fr de
Redirect 를 사용하면 클라이언트에게 예전에는 있었던 문서가 지금은 존재하지 않는다고 통보할 수 있습니다.  클라이언트로 하여금 다른 위치에서 문서를 찾도록 말해줄 때 사용합니다.

형식: Redirect fakename url

Aliases: 필요한 만큼 별명을 만들어 사용할 수 있습니다.(제한 없음) 기본 형식은 다음과 같습니다.

Alias fakename realname

만약 fakename 다음에 / 이 붙어 있다면 서버는 그 fakename 이 URL 안에 존재해야 한다고 간주합니다. 따라서 다음 예에서 "/icons"는 별명화되지 않습니다.

Alias /icons/ /home/httpd/icons/

ScriptAlias: 서버 스크립트를 포함한 디렉토리를 제어합니다.

형식: ScriptAlias fakename realname

ScriptAlias /cgi-bin/ /home/httpd/cgi-bin/

AddType은 mime.types 파일을 수정하지 않고도 원하는 작업을 할 수 있게 해줍니다.  또는 어떤 특정 파일을 특정 유형이 되도록 할 수 있습니다.

형식: AddType type/subtype ext1

AddHandler는 특정 파일 확장자에 대하여 화일 유형과는 연관되어 있지 않은 처리가 이뤄지도록 "처리기(handler)"를 결합시킬 수 있도록 해줍니다. 서버 안에 내장하거나 또는 Action 명령을 통해 추가할 수 있습니다. 

형식: AddHandler action-name ext1

다음을 풀어주면 /cgi-bin/ 이외의 모든 디렉토리에서도 .cgi 로 끝나기만 하면 CGI 로 간주하여 실행가능케 하므로 보안 상 좋지 않습니다.

#AddHandler cgi-script .cgi
서버 처리 HTML 파일을 사용하기 위해서.

#AddType text/html .shtml
#AddHandler server-parsed .shtml

아파치의 send-asis HTTP 파일 기능을 사용하려면 다음 행의 주석을 풉니다.

#AddHandler send-as-is asis

서버 해석 이미지맵 파일을 사용하려면.

AddHandler imap-file map

유형 지도(type maps)을 사용하려면.

#AddHandler type-map var

펄 모듈을 사용하려면 다음 섹션의 #를 제거합니다.

#Alias /perl/ /home/httpsd/perl/
#<Location /perl>
#SetHandler perl-script
#PerlHandler Apache::Registry
#Options +ExecCGI
#</Location>

php 모듈을 작동시키기 위해서

AddType application/x-httpd-php .phtml

Action 은 매치되는 파일이 읽혀질 때마다 스크립트를 실행하게 할 MIME 타입을 정의합니다.  특정 MIME 타입에 대한 요청이 있을 때마다 CGI 스크립트를 실행시키도록 전처리 용도로 매번 똑같은 URL 은 반복하는 것을 덜어줍니다.

형식: Action media/type /cgi-script/location
형식: Action handler-name /cgi-script/location

MetaDir: 아파치가 메타 정보 파일을 찾을 디렉토리 이름을 정합니다. 문서를 보낼 때 HTTP 헤더에 포함할 추가 정보를 가지고 있습니다.

#MetaDir .web

메타접미사(MetaSuffix): 메타 정보를 포함하고 있는 파일에 대한 접미사를 명시합니다.

#MetaSuffix .meta

    o. 평범한 텍스트 파일
#ErrorDocument 500 "The server made a boo boo.
  주의(n.b.) (") 표시는 텍스트임을 표시하며 출력되지 않습니다.

    o. 지역적인 방향전환
#ErrorDocument 404 /missing.html
지역 URL /missing.html 로 전환

#ErrorDocument 404 /cgi-bin/missing_handler.pl
주의: 스크립트 또는 서버 측 포함을 사용한 문서로 전환할 수 있습니다.

    o. 외부 방향전환
#ErrorDocument 402 http://some.other_server.com/subscription_info.html


 --> access.conf 설정.
<Directory /home>
Options Indexes IncludesNOEXEC
AllowOverride None
</Directory>

다음 설정은 여러분이 DocumentRoot 로 설정한 디렉토리로 조정해야 합니다.

<Directory /home/httpd/html>

"None", "All", 또는 "Indexes",
"Includes", "FollowSymLinks", "ExecCGI", "MultiViews"의 자유로운 조합이 가능합니다.

"MultiViews"는 명시적으로 적어야만 작동합니다.
"Options All"이라 할 지라도 "MultiViews"는 현재로서는 자동 설정되지 않도록 되어 있습니다.

Options Indexes Includes ExecCGI FollowSymLinks

다음은 각 디렉토리에 놓여 있는 .htaccess 파일에서 어떤 옵션에 대하여 재설정할 수 있는지 허가해줍니다.
"All", 또는 "Options", "FileInfo", "AuthConfig", "Limit" 의 자유로운 조합이 가능합니다.

AllowOverride None

서버로부터 정보를 취할 수 있는 위치를 제어합니다.

order allow,deny
allow from all

</Directory>

여기서 /home/httpd/cgi-bin 은 ScriptAlias 로 설정한 CGI 디렉토리가 있는 경우 알맞게 설정하기 바랍니다. /cgi-bin/ 의 스크립트가 제대로 작동하려면 ExecCGI 옵션이 필요합니다.

<Directory /home/httpd/cgi-bin>
AllowOverride None
Options ExecCGI
</Directory>

http://servername/server-status 을 열면 서버의 상태를 보여주도록 합니다. .your_domain.com 을 실제 여러분이 속한 도메인으로 변경하시기 바랍니다.

#<Location /server-status>
#SetHandler server-status

#order deny,allow
#deny from all
#allow from .your_domain.com
#</Location>

1.1 이전의 버전에 있던 버그를 악용하는 사람들이 있습니다. 이 버그는 아파치와 함께 배포되었던 CGI 스크립트와 관련된 버그입니다. 다음 행들의 주석 처리를 풀어주면 이 버그에 대한 공격 방향을 phf.apache.org 의 기록 스크립트로 방향전환 시킬 수 있습니다. 또는 support/phf_abuse_log.cgi 를 사용하여 여러분 스스로 기록해 둘 수도
있습니다.

<Location /cgi-bin/phf*>
deny from all
ErrorDocument 403 http://phf.apache.org/phf_abuse_log.cgi
</Location>

 O. ftp 설정하기.
Linux상에서 ftp 서비스를 하려면, wu-ftp 프로그램을 설치하거나 아니면, 다음과 같은 같은 방법으로 설정을 할수가 있다. 
먼저, /home 밑에 ftp 라는 디렉토리를 생성한다.

# mkdir /home/ftp

다음에 ftp 에 필요한 디렉토리를 만든다.

# mkdir /home/ftp/bin
# mkdir /home/ftp/lib
# mkdir /home/ftp/etc
# mkdir /home/ftp/pub

다 만들었으면 자신의 Linux 에 있는 /bin 디렉토리하의 compress, cpio, gzip, ls, sh, tar 를 /home/ftp/bin 으로 카피를 한다.

# cd /bin
# cp compress cpio gzip ls sh tar /home/ftp/bin

다음으로 /etc/ 디렉토리하의 group, ld.so.cache, passwd 파일을 /home/ftp/etc로 복사를 한다.

# cd /etc
# cp group ld.so.cache passwd /home/ftp/etc/

library 파일들도 복사를 한다.

# cd /lib
  
기본적으로 필요한 ld 라이브러리 및 libc, libnsl, libnss 라이브러리를 모두 복사한다.
나머지 필요한 부분은 ftp 사용자를 만든다.

# adduser ftp

패스워드는 * 로 코멘트한다.

# chown -R root.ftp /home/ftp 하여 ftp 사용자에게 엑세스 권한을 부여한다.


--> ftp 사용자 엑세스 제한.
class   anony   real.anonymous  *

             (최대 접숙자수) 
limit   anony   1       Any             /etc/msgs/msg.toomany
     (클래스명)   (언제나 허용) (접속 허용자수가 넘었을경우 보여주는 메세지) 
  
email hackers@smartmate.com --> ftp admin 이메일 주소

loginfails 1

readme  README*    login
readme  README*    cwd=*
message /welcome.msg            login (로긴을 하였을경우 보여주는 메세지)
message .message                cwd=*

compress        yes             all
tar             yes             all
chmod           no              guest,anonymous
delete          no              guest,anonymous
overwrite       no              guest,anonymous
rename          no              guest,anonymous

log transfers anonymous,real inbound,outbound
 
shutdown /etc/msg/shutmsg

passwd-check rfc822 enforce (enforce는 정확한 이메일주소를 적지 않을 경우
                            접속을 허가하지 않는 명령어)


 O. sendmail 설정하기.
* sendmail.cf
# Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
# Copyright (c) 1983, 1995 Eric P. Allman.  All rights reserved.
# Copyright (c) 1988, 1993
#       The Regents of the University of California.  All rights reserved.
#
# By using this file, you agree to the terms and conditions set
# forth in the LICENSE file which can be found at the top level of
# the sendmail distribution.
#
#

######################################################################
######################################################################
#####
#####           SENDMAIL CONFIGURATION FILE
#####
##### built by root@linux.sarang.net on Sun Aug 16 03:26:55 KST 1998
##### in /pkg/BUILD/sendmail-8.9.0/cf/cf
##### using ../ as configuration include directory
#####
######################################################################
######################################################################
#####  @(#)cfhead.m4    8.22 (Berkeley) 5/19/98  #####
#####  @(#)cf.m4        8.29 (Berkeley) 5/19/98  #####
#####  @(#)redirect.m4  8.10 (Berkeley) 5/19/98  #####
#####  @(#)always_add_domain.m4 8.6 (Berkeley) 5/19/98  #####
#####  @(#)use_cw_file.m4       8.6 (Berkeley) 5/19/98  #####
#####  @(#)local_procmail.m4    8.11 (Berkeley) 5/19/98  #####
#####  @(#)mailertable.m4       8.9 (Berkeley) 5/19/98  #####
#####  @(#)access_db.m4 8.8 (Berkeley) 5/19/98  #####
#####  @(#)proto.m4     8.223 (Berkeley) 6/30/98  #####

# level 8 config file format
V8/Berkeley

# override file safeties - setting this option compromises system security
# need to set this now for the sake of class files
#O DontBlameSendmail=safe

##################
#   local info   #
##################

--> sendmail 설정에 있어서 대부분의 사용자는 Cw, Fw, Dj 설정만 봐주면 메일
    설정은 된다. 

Cwlocalhost : C 는 클래스 정의 명령어이다. Cw 는 w라는 클래스에 값을
              대입하는 형식이다.
              이 형식에 값을 주기보다는 sendmail.cw 에 적어주는 편이 좋다.
              sendmail.cw 에 대해서는 밑에 부분에서 설명이 나온다.
    
# file containing names of hosts for which we receive email
Fw/etc/sendmail.cw --> w 클래스에 속한 호스트로 메일이 날라오면 메일서버는
                       수신을 하게된다.

# my official domain name
# ... define this only if sendmail cannot automatically determine your
domain
#Dj$w.Foo.COM --> 샌드메일이 여러분의 호스트를 제대로 인식을 하지
¸                 못하는 경우에 # 주석을 없애주고 나서 자신의 호스트를
                  적어준다
                  예) Dj$hackers.smartmate.com
     

CP.

# "Smart" relay host (may be null)
DS


# operators that cannot be in local usernames (i.e., network indicators)
CO @ % !

# a class with just dot (for identifying canonical names)
C..

# a class with just a left bracket (for identifying domain literals)
C[[

# Mailer table (overriding domains)
Kmailertable hash -o /etc/mailertable






# Access list database (for spam stomping)
Kaccess hash -o /etc/mail/access --> sendmail-8.9.1 부터는 relay 허용 및
                                     스팸메일 차단기능이 relay_domians 에서
                                     access 로 바뀌었다.


# Resolve map (to check if a host exists in check_mail)
Kresolve host -a<OK> -T<TEMP>

# Hosts that will permit relaying ($=R)
FR-o /etc/mail/relay-domains

# who I send unqualified names to (null means deliver locally)
DR

# who gets all local email traffic ($R has precedence for unqualified names)
DH
# dequoting map
Kdequote dequote

# class E: names that should be exposed as from this host, even if we
masquerade
# class L: names that should be delivered locally, even if we have a relay
# class M: domains that should be converted to $M
#CL root
CE root

# who I masquerade as (null for no masquerading) (see also $=M)
DM

# my name for error messages
DnMAILER-DAEMON


CPREDIRECT

O MaxMimeHeaderLength=256/128

# Configuration version number
DZ8.9.1a
###############
#   Options   #
###############

# strip message body to 7 bits on input?
O SevenBitInput=False

# 8-bit data handling
O EightBitMode=pass8


# wait for alias file rebuild (default units: minutes)
O AliasWait=10

# location of alias file
O AliasFile=/etc/aliases 

# minimum number of free blocks on filesystem
O MinFreeBlocks=100

# maximum message size
#O MaxMessageSize=1000000

# substitution for space (blank) characters
O BlankSub=.

# avoid connecting to "expensive" mailers on initial submission?
O HoldExpensive=False

# checkpoint queue runs after every N successful deliveries
#O CheckpointInterval=10

# default delivery mode
O DeliveryMode=background

# automatically rebuild the alias database?
O AutoRebuildAliases

# error message header/file
#O ErrorHeader=/etc/sendmail.oE

# error mode
#O ErrorMode=print

# save Unix-style "From_" lines at top of header?

#O SaveFromLine

# temporary file mode
O TempFileMode=0600

# match recipients against GECOS field?
#O MatchGECOS

# maximum hop count
#O MaxHopCount=17

# location of help file
O HelpFile=/usr/lib/sendmail.hf

# ignore dots as terminators in incoming messages?
#O IgnoreDots

# name resolver options
#O ResolverOptions=+AAONLY

# deliver MIME-encapsulated error messages?
O SendMimeErrors=True

# Forward file search path
O ForwardPath=$z/.forward.$w:$z/.forward

# open connection cache size
O ConnectionCacheSize=2

# open connection cache timeout
O ConnectionCacheTimeout=5m

# persistent host status directory
#O HostStatusDirectory=.hoststat

# single thread deliveries (requires HostStatusDirectory)?
#O SingleThreadDelivery

# use Errors-To: header?
O UseErrorsTo=False

# log level
O LogLevel=9

# send to me too, even in an alias expansion?

#O MeToo

# verify RHS in newaliases?
O CheckAliases=False

# default messages to old style headers if no special punctuation?
O OldStyleHeaders=True

# SMTP daemon options
#O DaemonPortOptions=Port=esmtp

# privacy flags
O PrivacyOptions=authwarnings

# who (if anyone) should get extra copies of error messages
#O PostMasterCopy=Postmaster

# slope of queue-only function
#O QueueFactor=600000

# queue directory
O QueueDirectory=/var/spool/mqueue
# timeouts (many of these)
#O Timeout.initial=5m
#O Timeout.connect=5m
#O Timeout.iconnect=5m
#O Timeout.helo=5m
#O Timeout.mail=10m
#O Timeout.rcpt=1h
#O Timeout.datainit=5m
#O Timeout.datablock=1h
#O Timeout.datafinal=1h
#O Timeout.rset=5m
#O Timeout.quit=2m
#O Timeout.misc=2m
#O Timeout.command=1h
#O Timeout.ident=30s
#O Timeout.fileopen=60s
O Timeout.queuereturn=5d
#O Timeout.queuereturn.normal=5d
#O Timeout.queuereturn.urgent=2d
#O Timeout.queuereturn.non-urgent=7d
O Timeout.queuewarn=4h
#O Timeout.queuewarn.normal=4h
#O Timeout.queuereturn.urgent=2d
#O Timeout.queuereturn.non-urgent=7d
O Timeout.queuewarn=4h
#O Timeout.queuewarn.normal=4h
#O Timeout.queuewarn.urgent=1h
#O Timeout.queuewarn.non-urgent=12h
#O Timeout.hoststatus=30m

# should we not prune routes in route-addr syntax addresses?
#O DontPruneRoutes

# queue up everything before forking?
O SuperSafe=True

# status file
O StatusFile=/var/log/sendmail.st

# time zone handling:
#  if undefined, use system default
#  if defined but null, use TZ envariable passed in
#  if defined and non-null, use that info
#O TimeZoneSpec=
# default UID (can be username or userid:groupid)
O DefaultUser=8:12

# list of locations of user database file (null means no lookup)
#O UserDatabaseSpec=/etc/userdb

# fallback MX host
#O FallbackMXhost=fall.back.host.net

# if we are the best MX host for a site, try it directly instead of config
err
#O TryNullMXList

# load average at which we just queue messages
#O QueueLA=8

# load average at which we refuse connections
#O RefuseLA=12

# maximum number of children we allow at one time
#O MaxDaemonChildren=12

# maximum number of new connections per second
#O ConnectionRateThrottle=3

# work recipient factor
#O RecipientFactor=30000

# deliver each queued job in a separate process?
#O ForkEachJob

# work class factor
#O ClassFactor=1800

# work time factor
#O RetryFactor=90000

# shall we sort the queue by hostname first?
#O QueueSortOrder=priority

# minimum time in queue before retry
#O MinQueueAge=30m

# default character set
#O DefaultCharSet=iso-8859-1

# service switch file (ignored on Solaris, Ultrix, OSF/1, others)
#O ServiceSwitchFile=/etc/service.switch

# hosts file (normally /etc/hosts)
#O HostsFile=/etc/hosts

# dialup line delay on connection failure
#O DialDelay=10s

# action to take if there are no recipients in the message
#O NoRecipientAction=add-to-undisclosed

# chrooted environment for writing to files
#O SafeFileEnvironment=/arch

# are colons OK in addresses?
#O ColonOkInAddr

# how many jobs can you process in the queue?
#O MaxQueueRunSize=10000

# shall I avoid expanding CNAMEs (violates protocols)?
#O DontExpandCnames
# SMTP initial login message (old $e macro)
O SmtpGreetingMessage=$j Sendmail $v/$Z; $b

# UNIX initial From header format (old $l macro)
O UnixFromLine=From $g  $d

# From: lines that have embedded newlines are unwrapped onto one line
#O SingleLineFromHeader=False

# Allow HELO SMTP command that does not include a host name
#O AllowBogusHELO=False

# Characters to be quoted in a full name phrase (@,;:\()[] are automatic)
#O MustQuoteChars=.

# delimiter (operator) characters (old $o macro)
O OperatorChars=.:%@!^/[]+

# shall I avoid calling initgroups(3) because of high NIS costs?
#O DontInitGroups

# are group-writable :include: and .forward files (un)trustwort
#O UnsafeGroupWrites

# where do errors that occur when sending errors get sent?
#O DoubleBounceAddress=postmaster

# what user id do we assume for the majority of the processing?
#O RunAsUser=sendmail

# maximum number of recipients per SMTP envelope
#O MaxRecipientsPerMessage=100

# shall we get local names from our installed interfaces?
#O DontProbeInterfaces

###########################
#   Message precedences   #
###########################

Pfirst-class=0
Pspecial-delivery=100
Plist=-30
Pbulk=-60
Pjunk=-100
#####################
#   Trusted users   #
#####################

# this is equivalent to setting class "t"
#Ft/etc/sendmail.ct
Troot
Tdaemon
Tuucp

* sendmail.cw
# sendmail.cw - include all aliases for your machine here.

이 설정은 사용자의 Linux 시스템이 가리키는 모든 별칭과 메일을 처리하고자 하는 호스트를 가리키는 내용이다. 이 항목에 해당하는 호스트의 이름을 적어주면 해당 호스트의 메일도 처리하는 기능을 가지고 있다.

 O. telnet 사용법.
지역 호스트와 네트워트상의 호스트를 연결하는 시스쳄 프로그램으로써 텔넷을 많이 사용하는데, 주로 다른 호스트로의 로긴 작업을 하는 경우에 많이 사용한다.

telnet으로의 로긴 후 작업은 로컬 호스트에서의 작업과 동일한 효과를 낸다. telnet은 파일 전송 및 파일 받기 기능이 없는 프로토콜이다. 파일 받기 및 파일 전송 프로그램으로는 주로 사용하는 ztelnet이라는 프로그램이 있다.

ztelnet(zmodem + telnet)으로써 파일 전송 및 파일 받기에 많이 쓰이는 텔넷 프로그램이다.

* 파일 받기
통신상에서 자료를 받고자 할 때, 자료 받기를 선택한 다음에 

PgDn키를 치시고 ZMODEM을 선택하십시오. 수신을 중단하시려면 ESC키를 치시고 CTRL-X를 여러번 치십시오. 둷wB00000000000000

이런 화면이 나온후에 Ctrl + ] 키를 같이 누르면 다음과 같은 항목이 나온다.

ztelnet> 

이런 화면에 rz 를 치면 다운이 된다.

* 파일 전송 
업로드 하는 파일을 전송을  할 시에는

ztelnet> 

다음과 같은 항목이 나타나면 이런 형식으로 명령어를 친다.
sz 파일명 -w 1024 이런 형식으로 적어준다.

 O. Samba 설정하기.
* smb.conf
 [global]
workgroup = NT 도메인 이름 또는 워크그룹 이름
   workgroup = MYGROUP
server string 은 란 NT 설명 필드와 같은 것입니다.
   server string = Samba Server

이 옵션은 보안과 관련하여 중요한 것입니다.  이 옵션을 통해 여러분의 근거리 네트웍에 있는 호스트에게만 접근을 허용할 수 있습니다. 다음 예는 2 개의 C 클래스 네트웍과 "loopback" 인터페이스에 대해서만 접근을 허용한다.  

;   hosts allow = 192.168.1. 192.168.2. 127.

프린터 설정을 개별적으로 하지 않고 자동으로 프린터 목록을 포함시키길 원한다면 다음 옵션을 사용합니다. printcap 에서 정의한 프린터 목록이 자동으로 등록됩니다.
load printers = no 이면 하나하나 정해주셔야 합니다.

   load printers = yes

printcap 파일의 위치를 새롭게 지정하고 싶을 때 사용한다.

;   printcap name = /etc/printcap

SystemV 시스템에서는 printcap name 을 lpstat 으로 해주면 SystemV 스풀 시스템으로부터 프린터 목록을 자동으로 얻게 해줍니다.

;   printcap name = lpstat

여러분의 프린팅 시스템이 표준에서 벗어난 것이 아니라면 다음 옵션의 주석을 풀 필요가 없습니다. 

;   printing = bsd

손님 사용자를 허가하고 싶을 때는 다음 행의 주석을 풀어줍니다. nobody 가 아닌 경우에는 /etc/passwd 항목에 설정한 손님 사용자 계정을 추가해야 합니다.
useradd 명령으로 설정하십시오.

;  guest account = pcguest

다음은 삼바로 하여금 자신에 접속하는 호스트 별로 개별적인 기록 파일을 만들도록 지시합니다.

"/var/log/samba/log.접근호스트이름"과 같은 파일명을 가집니다.

%m 은 삼바 설정에서 사용되는 특수한 변수입니다.

   log file = /var/log/samba/log.%m

로그 파일 크기의 상한선을 Kb 단위로 설정합니다.

   max log size = 50

보안 모드입니다.  대부분의 사람들에겐 user 레벨의 보안이 맞습니다. 자세한 내용은 security_level.txt 문서를 참고하십시오. 참고로 user 는 유닉스 계정이름/패스워드 방식의 보안 등급이며 share는 워크그룹 포 윈도우즈(WfW)와 윈도95의 기본 모드입니다. server의 경우에는 인증을 위해 NT 서버가 필요합니다.

   security = user

security = server 인 경우에만 패스워드 서버를 설정합니다.

;   password server = <NT 서버 이름>

패스워드 레벨에서는 대소문자 모든 조합에 대하여 _n_ 개의 문자로 이뤄진 패스워드를 사용하도록 합니다.

;  password level = 8

패스워드 암호화를 사용하고 싶을 때가 있을 겁니다.  삼바 문서 중에서 ENCRYPTION.txt, Win95.txt, WinNT.txt 를 꼭 읽어보시기 바랍니다. 이 문서를 착실히 읽지 않은 상태에서 다음 옵션을 설정하지 마십시오. 윈도우즈NT 4.0 서비스 팩 3 번 이상인 시스템에서는 패스워드 암호화가 필요합니다.

;  encrypt passwords = yes
;  smb passwd file = /etc/smbpasswd

유닉스 사용자 이름과 SMB 사용자 이름이 달라 둘 간의 연관 테이블을 필요할 때 사용합니다.

;  username map = /etc/smbusers

다음 옵션은 접속하는 각 머신마다 서로 다른 설정을 원할 때 사용합니다. 여기서 %m 은 접속하는 호스트의 NetBIOS 이름으로 대체됩니다.

;   include = /etc/smb.conf.%m

대부분의 경우 다음 옵션을 주면 성능 향상 효과를 볼 수 있습니다. 자세한 사항은 speed.txt 와 맨 페이지를 참고하십시오.

   socket options = TCP_NODELAY

삼바가 여러 개의 인터페이스를 사용하도록 설정합니다. 여러 개의 네트웍 인터페이스를 가지고 있다면 그 인터페이스들을 모두 나열하십시오.  자세한 사항은 맨 페이지를 참고하십시오.

다음 예는 삼바 서버가 192.168.12.2, 192.168.13.2 이렇게 두 개의 주소를 가지고 있고 24 비트 즉 넷매스크 255.255.255.0 를 사용하여 192.168.12.0, 192.168.13.0 네트웍의 호스트에 대해서 받아들입니다.

;   interfaces = 192.168.12.2/24 192.168.13.2/24

원격 브라우즈 목록과의 동기화에 관한 설정입니다. 공표 요청을 하거나 또는 브라우즈 목록 동기화해 줄 대상이나 특정 호스트 또는 전체 서브넷을 지정할 수 있습니다.
       
;   remote browse sync = 192.168.3.25 192.168.5.255

지역적인 서브넷에 자기 자신을 가시화 하도록 설정합니다. 윈도우즈 네트웍 환경에서 삼바 서버가 잘 보이도록 할 때 유용합니다.

;   remote announce = 192.168.1.255 192.168.2.44

브라우져 제어 옵션: 삼바가 네트웍에 대한 매스터가 되길 바라지 않으면 local master 설정을 no 로 하십시오.  

;   local master = no

OS 레벨은 매스터 브라우져 선거 과정에서 서버의 우선권을 결정합니다. 기본값이 적절합니다.  

;   os level = 33

domain master 는 삼바로 하요금 도메인 매스터 브라우져가 되도록 해줍니다. 삼바는 서브넷들로부터 브라우즈 목록을 모으는 작업을 하게 됩니다. 이미 이 기능을 담당하고 있는 윈도우즈 NT 도메인 컨트롤러가 있다면 이것을 사용해서는 안됩니다.
;   domain master = yes

preferred master 옵션을 켜두면 시동할 때 지역 브라우져 선거를 하도록 만들고 선거에서 이길 수 있는 좀 더 높은 기회를 부여받습니다.

;   preferred master = yes

설치할 때 주 도메인 컨트롤러로 설정된 NT 서버가 존재할 때만 사용합니다.

;   domain controller = <NT 도메인 컨트롤러 SMB 이름>

삼바가 윈도우즈95 워크스테이션에 대한 도메인 로그온 서버 역할을 하길 원하는 경우 켜둡니다.

;   domain logons = yes

도메인 로그온을 선택했고 각 머신 별로 또는 각 사용자 별로 로그온 스크립트를 구분하여 특정 배치 파일을 작동시키길 원하는 경우 사용합니다.

;   logon script = %m.bat

사용자 이름에 의거하여 서로 다른 로그온 배치 파일을 실행시킬 때

;   logon script = %U.bat
;   logon path = \\%L\Profiles\%U

윈도우즈 인터넷 네임 서비스 WINS 지원 섹션:
참고)  /etc/lmhosts를 만들어 마치 /etc/hosts와 같이 적습니다.

예) 192.168.0.1   쨖inux

;   wins support = yes

WINS 서버 - 삼바의 NMBD 로 하여금 WINS 클라이언트가 되도록 합니다. 삼바는 WINS 서버 또는 클라이언트 중 하나만 될 수 있다.

;   wins server = w.x.y.z
WINS 프록시 - 삼바로 하여금 WINS 기능을 갖추지 못한 클라이언트를 대신하여 이름에 해당하는 주소 찾기 질문을 대신 답하도록 합니다. 이를 위해서는 네트웍 상에 적어 한 개 이상의 WINS 서버가 있어야 합니다. 기본값은 NO

;   wins proxy = yes

DNS 프록시 - 삼바로 하여금 DNS nslookup 을 사용하여 NetBIOS 이름을 찾을 것인지 아닌지 지시합니다. 1.9.17 버전에서는 내부 기본값이 yes 였으나 1.9.18 버전에서는 no 로 변경되었습니다.

   dns proxy = no

대소문자 보존이 필요할 때가 있습니다.  시스템 기본값은 NO 입니다.


   preserve case = yes
   short preserve case = yes

# 도스 파일에 대한 기본 문자는 대문자입니다.

;  default case = lower

# 대소문자 구별은 주의를 요합니다. - 문제를 일으킬 수도 있습니다!

;  case sensitive = no

#======================== 공유 정의==================================
[homes]
   comment = 홈 디렉토리
   browseable = no
   writable = yes

도메인 로그온을 위한 netlogin 디렉토리를 만들고 주석 해제합니다. 물론 도메인 로그온 기능을 지원할 때만 필요합니다.

; [netlogon]
;   comment = Network Logon Service
;   path = /home/netlogon
;   guest ok = yes
;   writable = no
;   share modes = no


특정한 로우빙 프로파일(roving profile) 공유를 제공하고자 한다면 다음의 주석을 풀어주십시오. the default is to use the user's home directory 기본값은 사용자의 홈 디렉토리입니다.

;[Profiles]
;    path = /home/profiles
;    browseable = no
;    guest ok = yes

[printers]
   comment = 모든 프린터
   path = /var/spool/samba
   browseable = no
guest ok = yes 라고 하면 'guest account'로 지정한 사용자들이 프린팅을 할 수 있습니다.  public = yes 도 같은 표현입니다.
   guest ok = no
   writable = no
   printable = yes


;[tmp]
;   comment = 임시 파일 공간
;   path = /tmp
;   read only = no
;   public = yes

공개적으로 접근 가능한 디렉토리이지만 읽기만 가능하고 "staff" 그룹에 속한 사용자들만이 쓰기를 할 수 있는 설정의 예입니다.

;[public]
;   comment = Public Stuff
;   path = /home/samba
;   public = yes
;   writable = yes
;   printable = no
;   write list = @staff

fred 라는 사용자만 이용할 수 있는 개인적인 프린터 설정. 스풀 자료는 fred 의 홈 디렉토리에 씌여집니다. fred 는 지정한 스풀 디렉토리에 쓰기 권한을 가지고 있는 상태여야 합니다.

;[fredsprn]
;   comment = Fred 전용 프린터
;   valid users = fred
;   path = /homes/fred
;   printer = freds_printer
;   public = no
;   writable = no
;   printable = yes

fread 만이 이용할 수 있는 개인적인 디렉토리 설정입니다. 디렉토리에 대하여 fred 의 쓰기 권한이 있는 상태여야 합니다.

;[fredsdir]
;   comment = Fred 개인 서비스
;   path = /usr/somewhere/private
;   valid users = fred
;   public = no
;   writable = yes
;   printable = no

접속하는 머신에 따라 서로 다른 디렉토리를 제공하는 서비스의 좋은 예입니다. 이렇게 함으로써 접속 머신에 따라 실제 설정 내용이 달라지는 효과를 얻을 수 있습니다.  사용자 이름으로 구별하려면 %u 옵션을 대신 사용하면 됩니다. %m 은 접속하는 머신의 이름으로 치환됩니다.

;[pchome]
;  comment = PC 디렉토리
;  path = /usr/pc/%m
;  public = no
;  writable = yes

모든 사용자가 읽고 쓸 수 있는 공개 접근 디렉토리의 예입니다. 생성되는 모든 파일은 기본 사용자의 소유가 되므로 다른 사용자가 여러분이 만든 파일을 지울 수 있습니다.  당연히 주어진 디렉토리에 대하여 기본 사용자가 쓰기 권한을 가지고 있어야 합니다.  다른 사용자를 명시하면 기본 사용자가 아닌 그 사용자의 소유가 됩니다.

;[public]
;   path = /usr/somewhere/else/public
;   public = yes
;   only guest = yes
;   writable = yes
;   printable = no

다음 항목은 두 사용자가 어떻게 한 디렉토리를 공유하여 사용하게 할 수 있는지 예시하고 있습니다.  이 설정이 제대로 작동하려면 디렉토리는 두 사용자에 의해 쓰기 가능해야 하며 스틱키(sticky) 비트를 설정하여 서로의 파일에 대하여 악의적인 행동을 취할 수 없도록 해줘야 합니다.  이런 방법으로 여러 사용자가 한 디렉토리를 안전하게 공유하도록 확장할 수 있습니다.

;[myshare]
;   comment = Mary & fred 디렉.
;   path = /usr/somewhere/shared
;   valid users = mary fred
;   public = no
;   writable = yes
;   printable = no
;   create mask = 0765

O. 윈98 과 윈NT 와의 삼바 공유할때.
다음과 같은 명령을 내줍니다.

# cat /etc/passwd | mksmbpasswd.sh >/etc/smbpasswd

라는 명령을 내려주면 /etc/ 디렉토리하에 smbpasswd 라는 파일이 만들어집니다.  위와 같은 사항은 윈98 과 NT 에서는 패스워드 암호화 기능이 들어있기 때문입니다.
만약, linux 사용자에 대한 삼바공유 암호를 지정하려면 다음과 같이 해줍니다.

# smbpasswd linux 라고 치면 패스워드를 지정하도록 요구합니다.

패스워드를 지정한 다음에 삼바 데몬을 띄우면 암호화 기능으로써 삼바 공유가 지정이 됩니다.

# /etc/rc.d/init.d/smb stop   (삼바 데몬 중지)
# /etc/rc.d/init.d/smb start  (삼바 데몬 시작)
  
   3. 리눅스 & Database
	 Linux상에서의 Database구축에 필요한 Application에는 PostgreSQL, mSQL, MySQL, Informix for Linux, Oracle for Linux등이 있다. 금년 말에 출시될 예정인 Oracle은 아직 프로그램이 출시가 안된 상태이므로 여기에서는 소개 정도로 마칠까 한다.

▶ PostgreSQL(http://www.postgresql.org/) : PostgreSQL은 객체-관계형 DBMS로서 Berkeley Postgres 데이터베이스 관리시스템에서 파생되었다.  PostgreSQL은 객체-관계형 데이터 모델과 풍부한 데이터 타입 쉬운 확장성을 가지고 있으며, PostQuel 의 언어를 확장된 SQL의 부분집합으로 대체하고 있는 데이터베이스이다.

▶ mSQL(http://www.hughes.com.au/) : Mini SQL(mSQL)은 구조적 질의 언어(structured Query Language)를 사용하는 관계형 데이터베이스이다. 경량급의 데이터베이스로써, ANSI 표준 SQL를 전부다 지원하지 않는게 단점이며 빠른 속도가 장점이다.
    
▶ MySQL(http://www.tcx.se/) : MySQL은 가장 일반적인 데이터베이스 언어인 SQL(Structured Query Language) 문법을 사용하는 데이터베이스 서버이다. MySQL은 특징적인 Programs/libraries 와 자체적인 mysqld 서버데몬을 구성하며 클라이언트 & 서버로써 충족시켜주는 Database 이다. MySQL의 주 목적은 속도와 안정성에 둔다.

▶ Informix : 미국 시애틀에서 열린 인포믹스 월드와이드 유저 컨퍼런스를 통해 "인포믹스SE" DB제품과 "다이나믹 4GL" 개발툴을 리눅스에 이식, 조만간 상용화할 계획이라고 발표했다. 특히 인포믹스의 경우 당초 자사제품을 리눅스로 이식하지 않겠다는 방침을 전격 바꾼 것은 최근 리눅스 플랫폼에 대한 기업 고객들의 관심과 상용화 가능성이 급증하고 있는데 따른 것으로 풀이된다. (전자신문 발췌)
▶ Oracle : 오라클사는 최근 자사 "오라클8.1" DB와 "오라클 어플리케이션 스위트"를 리눅스용으로 개발할 방침이라고 밝혔다. 이 회사의 팀 페인 DB 마케팅 담당 책임자는 "멀티 프로세싱 시스템에서 리눅스의 확장성에 만족한다."며 이 시장이 엄청난 성장 잠재력을 가질 것이라고 기대 했다. (전자신문 발췌)

	[PostgreSQL 설치 및 활용법]

● PostgreSQL  설치시 필요한 파일.
===========================================================
  PostgreSQL Homepage : http://www.postgresql.org/
  Source & patch : ftp://ftp.sra.co.jp/pub/cmd/postgres/6.3.2/ 
===========================================================

o postgresql-6.3.2.tar.gz --> PostgreSQL 설치 파일.
o jumbo.patch.gz --> 한글 사용을 위한 패치 파일.

● PostgreSQL 설치.
먼저, postgres 라는 PostgreSQL를 엑세스하는 사용자를 만든다.

# adduser postgres 
# cd /etc/
# vi passwd 하여 postgres 사용자의 홈디렉토리를 /usr/local/pgsql로 바꾸어준다.
  root 사용자로써 다음과 같은 postgres 사용자의 엑세스 권한을 부여한다.
# chown -R postgres.postgres /usr/local/pgsql     

그러면, 받아온 postgresql-6.3.2.tar.gz 과 jumbo.patch.gz을 /usr/local/pgsql로 복사하여 압축을 푼다.

# tar xvfz postgresql-6.3.2.tar.gz
# cd postgresql-6.3.2
# cp jumbo.patch.gz /usr/local/pgsql/postgresql-6.3.2
# gzip -dc jumbo.patch.gz | patch -p0
   
jumbo.patch.gz 은 한글 사용을 위한 패치화일이다.
src 디렉토리로 이동하여 Makefile.custom 파일을 만들고 다음의 한줄을 적는다.(한글 사용을 위한)

# jumbo=1

저장한 후에 posrgres 사용자로 로긴을 한다.

# su - postgres
# cd src
# ./configure
# make
# make all

설치가 다 되었으면 시스템이 공유 라이브러리를 찾을수 있도록 /etc/ld.so.conf에 다음의 한줄을 적는다.

# /usr/local/pgsql/lib

이라고 적는 다음에 

/sbin/ldconfig 

명령을 한번 실행해준다.

● PostgreSQL 환경 변수 설정.
postgres 사용자로 로긴을 하여 PostgreSQL을 사용할수 있도록 환경 변수를 설정을 해준다. 이제부터는 모든 PostgreSQL 작업은 postgres 라는 사용자로써 이루어진다.

	<bash 사용자>
bash 사용자라면 .bash_profile에 설정화일을 적어준다.
------------------< .bash_profile >--------------------------
PATH=/usr/local/pgsql/bin
MANPATH=/usr/local/pgsql/man
PGLIB=/usr/local/pgsql/lib
PGDATA=/usr/local/pgsql/data
export PATH MANPATH PGLIB PGDATA
----------------------------------------------------------
저장한 후에 source 명령을 사용하여 환경변수를 적용시킨다.
 
# source .bash_profile

	 <csh 사용자>
csh 사용자라면 .cshrc 파일에 설정화일을 적어준다.
-----------------------< .cshrc >--------------------------
 setenv PATH=/usr/local/pgsql/bin
 setenv MANPATH=/usr/local/pgsql/man
 setenv PGLIB=/usr/local/pgsql/lib
 setenv PGDATA=/usr/local/pgsql/data
 setenv PATH MANPATH PGLIB PGDATA
----------------------------------------------------------
똑같은 방법으로 source  명령을 내려준다.
		→ 데이터베이스의 초기화를 내려준다.

# initdb 

● Daemon 띄우기
postmaster 의 데몬을 수행하는 명령어는 
		→ postmaster > server.log 2>& 1 &

시스템 부팅시 자동적으로 데몬을 수행시키기 위해서는 /etc/rc.d/rc.local에 다음의 한줄을 적는다.

→ su postgres -c "/usr/local/pgsql/bin/postmaster -S -D /usr/local/pgsql/data"

이렇게 적어주고 나면 시스템 부팅시마다 데몬을 띄우게 된다.


 
	[mSQL 설치 및 활용법.]
● mSQL 설치시 필요한 파일.
============================================================
     Mini SQL Homepage : http://www.hughes.com.au/
============================================================ 
  
    o msql-2.0.4.1.tar.gz --> mSQL 설치 파일.

    
● mSQL 설치.
먼저, mSQL 홈페이지에 가서 msql-2.0.4.1.tar.gz을 받아온다. 그리고 나서, 받아온 파일의 압축을 풀어보자.

# tar xvfz msql-2.0.4.1.tar.gz
# cd msql-2.0.4.1
# make target --> 하면 자신의 시스템에 맞게 설정을 해준다.
---------------------------------------------------------
   Making target directory for Linux-2.1.116-i586

   Building directory tree.
        Adding common
        Adding conf
        Adding lang-common
        Adding lite
        Adding makedepend
        Adding makegen
        Adding msql
        Adding regexp
        Adding tests
        Adding tests/rtest.src
        Adding w3-msql
        Adding w3-msql/tests
                                                                         ................................................................................................................................................

    Build of target directory for Linux-2.1.116-i586 complete
--------------------------------------------------------------
  다 되었으면 자신의 시스템과 커널 버전에 맞는 targets 디렉토리가 생긴다.
  필자의 커널은 2.1.116이다. 
  
# cd targets/Linux-2.1.116-i586
# ./setup
# make all
# make install

하면은 설치가 완료된다. 먼저, msql 이라는 사용자를 만든다.

# adduser msql 

/usr/local/Hughes 디렉토리는 msql이라는 사용자의 소유권한이 되어야한다. 다음과 같은 명령으로 /usr/local/Hughes 디렉토리를 msql 사용자가 읽/쓰기가 가능하도록 권한을 부여해준다.
# chown -R msql.msql /usr/local/Hughes

● 접근 제한 설정 파일.
msql이 설치가 되고 나면 msql 사용자로 로긴을 하여 msql.acl.sample 파일을 msql.acl 이라는 파일로 복사를 한다.

# su - msql
# cp msql.acl.sample msql.acl

다 하였다면, msql.acl 파일을 설정함으로써 접근 제한을 설정해보자.
------------------< vi msql.acl >----------------------------
# Access control for mSQL
#
# Entries are of the form
#

database=test  --> Database table name.
read=bambi,-root --> test라는 테이블을 읽는 권한은 bambi 라는 사용자이고
                        root 사용자는 읽는 권한을 제한한다,
write=root  --> test라는 테이블은 오직 root 사용자만 권한이 있다.     
host=*
access=local,remote
option=rfc931

database=minerva
read=*
write=minerva
access=local
-------------------------------------------------------------
설정이 끝나면 msql 의 데몬을 띄워보자.

# cd bin
# ./msql2d &    

[msql@hackers bin]$ 

Mini SQL Version 2.0.4.1
Copyright (c) 1993-94 David J. Hughes
Copyright (c) 1995-98 Hughes Technologies Pty Ltd.
All rights reserved.

        Loading configuration from '/usr/local/Hughes/msql.conf'.
        Server process reconfigured to accept 200 connections.
        Server running as user 'msql'.
        Server mode is Read/Write.

서버 데몬은 msql 사용자로 데몬을 시작한다. 하지만, 앞 부분에서 사용자가 데몬실행중 msql.acl 파일을 바꾸었다면, 데이터베이스 관리자가 다음 명령을 수행한다.

# /usr/local/Hughes/bin/msqladmin reload

하고 나서 다시 데몬을 실행시키면 된다.
그리고, 시스템 부팅과 함께 msql 데몬을 구동시키려면 /etc/rc.d/rc.local에 다음 한줄을 적어주면 된다.

→ /usr/local/Hughes/bin/msql2d &
 
이로써 mSQL 설치법에 대해서 알아보았다.

	[MySQL 설치 및 활용법]

● MySQL 을 설치할 경우 필요한 것
	MySQL 을 설치할 경우 필요한 것이 있다. 그것은 다음과 같다.
	- 압축되어진 배포판을 풀기위한 GNU gzip 프로그램
	- tar 프로그램
	- ANSI C++ 컴파일러. 
	- gcc 컴파일러 : 버전은 2.7 이상인것

● MySQL 의 설치방법.
===============================================================
MySQL Homepage : http://www.tcx.se/
===============================================================  

다음의 명령으로 압축을 푼다.

# gzip mysql-VERSION.tar.gz

여기서 mysql-VERSION.tar.gz 은 방금 받은 압축파일의 이름이다. tar 명령을 이용하여 묶여있는 소스를 다시 풀어야 한다. 이경우 mysql-VERSION 이라는 디렉토리가 생성되면서 그 안에 모든 소스와 파일이 풀리게 된다.

# tar -xvf mysql-VERSION.tar

생성된 디렉토리로 이동한다.

# cd mysql-VERSION

환경을 설정한다. 만일 어떤 옵션을 추가하기를 원한다면 다음과 같아 한다.

# ./Configure --help

이 경우 각종 옵션이 나오므로 이 내용을 보고 변경하기 바란다. 더 자세한 사항은 영문 메뉴얼을 읽어 보기 바란다. 일반적으로 그냥 아래의 명령을 실행하면 된다.
	
#./Configure
# make
# make install

컴파일된 모든 실행 가능한 파일이 설치가 되고 환경이 설정된다. 설치가 끝난후 아래의 명령을 실행하여 기초 테이블과 admin 유저를 설치한다. 이 명령은 단 한번하는 것으로서 두번 실행하면 않된다. 

# ./scripts/mysql_install_db

이것은 스크립트로서 실행하여 기초작업을 한후 MySQL을 실행시켜 준다. 설치 디렉토리를 디폴트로 하였다면 /usr/local/bin/ 디렉토리에 실행파일이 모두 설치되었을 것이다. 디폴트로 설치하였다고 가정하고 다음의 명령을 수행하여 본다.

# /usr/local/bin/mysqladmin version

MySQL 버전 정보가 아래와 비슷하게 출력될 것이다.

mysqladmin  Ver 6.8 Distrib 3.21.27-gamma, for unknown-freebsd2.2.1 on i386
TCX Datakonsult AB, by Monty

Server version        	3.21.27-gamma-log
Protocol version      	10
Connection       	localhost via TCP/IP
TCP port             	3306
Uptime:              	22 hours 20 min 9 sec

Running threads:1 Questions: 20  Opened_tables: 8  Reloads: 2  Open tables: 4

이제 mysql 프로그램을 아래와 같이 실행하여 기본적인 동작을 테스트하자.

# mysql mysql

혹은 mysql -u root mysql (실행시키는 유저가 root가 아닐 경우) 아래의 sql문장을 mysql 상에서 수행시켜보자

select * from user

mysql 의 사용방법은 mysql이 실행된 상태에서 다음의 명령을 주면 알수 있다.

\h

각종 명령을 잘 읽어 보고 사용하면 된다. SQL문도 표준 SQL을 모두 지원하며 MySQL만의 확장 SQL문을 알고 싶다면 영문 메뉴얼을 참조하라.

● MySQL Server의 실행과 종료
MySQL Server을 실행 시키거나 종료시키려면 다음의 명령을 root 가 사용하면 된다.

	mysql.server start	--> mysql Server의 시작
	mysql.server stop	--> mysql Server의 종료

MySQL Server가 실행시 두개의 프로세서가 실행되므로 확인해 보기 바란다.
	/usr/local/bin/safe_mysqld
	/usr/local/libexec/mysqld

	[Informix-SE for Linux]

지금부터 Informix-SE for Linux를 설치하시는 법에 대하여 설명을 드리겠습니다...
자.. 먼저 다음의 내용을 적어 놓으시고 시작합시다..

Serial Number : ACN#A287337
Software Key : BECZJK

1. root로 login합니다...

2. "informix"란 group과 user를 새로 만듭니다...
  (#adduser informix  하시면 한번에 O.K.~!)

3. 그다음엔 당연히 informix의 password를 정하셔야겠지요?
  (#passwd informix)

4. 자.. 그 다음엔... informix를 어디에 설치할 것인가를 결정합니다...
   문서상으론 /usr/informix를 기준으로 설명이 되어 있으니까 그곳을
   기준으로 설명을 드리지요.. 만일 다른 위치에 설치하시구 싶으시다면
   얼마든지 가능하니까 걱정마시구요.. :-)
   그럼 전 여기서 /usr/informix를 기준으로 설명드릴께요..

5. /usr/informix를 기준으로 설치하려고 했으니까... 받으신 파일을 /usr
   아래로 옮기세요... 
  (#mv [파일이 있는 디렉터리]/informix.zip /usr )

6. 이젠 /usr로 위치를 이동합니다...
  (#cd /usr )

7. 그 다음엔 압축을 풉니다...
  (#unzip informix.zip )

8. 그러면 다음과 같이 나오게 됩니다...
  (Archive:  informix.zip
      creating: LINUX_se_bundle724UC5/
      creating: LINUX_se_bundle724UC5/ESQLC/
     inflating: LINUX_se_bundle724UC5/ESQLC/ESQL.TAR  
      creating: LINUX_se_bundle724UC5/ICONNECT/
     inflating: LINUX_se_bundle724UC5/ICONNECT/CONNECT.TAR  
     inflating: LINUX_se_bundle724UC5/README.TXT  
     inflating: LINUX_se_bundle724UC5/README.UNX  
      creating: LINUX_se_bundle724UC5/SE/
     inflating: LINUX_se_bundle724UC5/SE/SE.TAR)

9. 앞에 LINUX_se_bundle724UC5 훗... 이름이 길죠? ^^
   이 이름을 좀 짧게 바꾸죠..
  (#mv LINUX_se_bundle724UC5 informix )

10. 자.. 이젠 소유권을 바꾸겠습니다...
  (#chown -R informix:informix informix )

11. 그 다음엔 각 서브 디렉터리마다 가셔서 각각의 TAR압축을 풀어야합니다...
  (#cd /usr/informix/ESQLC 
   #tar xvopf ESQL.TAR 
   #cd /usr/informix/ICONNECT 
   #tar xvopf CONNECT.TAR 
   #cd /usr/informix/SE 
   #tar xvopf SE.TAR  )

12. 이제부턴 본격적인 설치를 시작합니다... 먼저 ESQL/C부터..
  (#cd /usr/informix/ESQLC 
   #INFORMIXDIR=/usr/informix/ESQLC 
   #export INFORMIXDIR 
   #./installesql 
   INFORMIX EMBEDDED SQL for C Version 7.24.UC5
   Copyright (C) 1991-1998 Informix Software, Inc.


   Installation Script

   This installation procedure must be run by root (super-user).
   It will change the owner, group, and mode of all files of this
   package in this directory.  There must be a user "informix" and a 
   group "informix" known to the system.


   Press RETURN to continue,
   or the interrupt key (usually CTRL-C or DEL) to abort.

   (요기서 그냥  하심되겠죠? -^^-)

   Enter your serial number (for example, INF#X999999) > 
   ACN#A287337 (<-요기다가는 아까 위에서 적으신 시리얼 번호를 넣으세요..)

   Enter your serial number KEY (uppercase letters only) >
   BECZJK (<-요기다가는 아까 위에서 적으신 소프트웨어 키를 넣으세요...)

   WARNING!
            This software, and its authorized use and number of users, are
   subject to the applicable license agreement with Informix Software, Inc.
   If the number of users exceeds the licensed number, the excess users may
   be prevented from using the software.  UNAUTHORIZED USE OR COPYING     MAY
   SUBJECT YOU AND YOUR COMPANY TO SEVERE CIVIL AND CRIMINAL     LIABILITIES.


   Press RETURN to continue,
   or the interrupt key (usually CTRL-C or DEL) to abort.

   (요기서 역시 그냥  하심 되겠죠? -^^-)
   (여기까지 하시면 알아서 자동으로 설치를 시작합니다...))

13. 다음은 ICONNECT입니다...
  (#cd /usr/informix/ICONNECT 
   #INFORMIXDIR=/usr/informix/ICONNECT 
   #export INFORMIXDIR 
   #./installconn 

   (나머지 부분은 12번 뒷부분과 동일합니다..))

14. 다음은 SE입니다...
  (#cd /usr/informix/SE 
   #INFORMIXDIR=/usr/informix/SE 
   #export INFORMIXDIR 
   #./installse 

   (역시 나머지 부분은 12번 뒷부분과 동일합니다...))

자... 여기까지가 바로 informix의 설치입니다...

   4. 리눅스 & Security
  4.1 물리적인 시스템의 보안
     4.1.1 HardWare를 이용
     현재 우리가 사용하는 많은 컴퓨터에는 열쇠로 잠글 수 있는 기능을 가지고 있어서 이것을 이용하여 사용하는 방법이다. 또한 부팅을 제한할 수 있는 기능도 있고 시스템내의 BIOS를 이용하면은 시스템의 부팅시 패스워드를 물어 볼 수 있게 설정을 할 수도 있을 것이다. 
    
     4.1.2 Lock(xlock & vlock)
     만약에 리눅스를 관리하는 도중에 자리를 비울 일이 생길 것이다. 그러면 다른 사람이 이 컴퓨터를 건들지 못하도록 방지를 할 수가 있다. xlock은 엑스윈도우의 화면은 잠그는 것이고 vlock은 가상 터미널을 잠그는데 사용을 하는데 둘 다 그냥 터미널에서 실행을 함으로써 잠궈지는 것이다. 우선 vlock를 먼저 살펴보자 아래의 예처럼 실행을 하면 간단하게 잠글 수 있다.
[hwinnt@linux:~$]vlock  *** This tty is not a VC (virtual console). ***  *** It may not be securely locked. ***  This TTY is now locked. Please enter the password to unlock. hwinnt's Password:
  
  위의 두줄은 네트윅 상에서 텔넷으로 접속을 해서 이 터미널이 가상 터미널이 아니라고 나온것인데 직접 리눅스에서 명령어를 주게 되면 alt + function key 로 터미널을 바꾸어서 사용할수 있다는 말이 나올 것이다. 이렇게 vlock 이라는 명령어를 주게 되면은 가상 콘솔을 잠궈 버린다. 다시 프롬프트로 돌아갈려면은 패스워드를 알아야 할 것이다. vlock 의 기본적인 옵션은 다음과 같다.
       -a,--all       모든 가상 터미널을 잠그고 싶을때에 사용하는 옵션이다.
       -c,--current   현제의 터미널을 잠글수 있는 옵션인데 이것은 기본 옵션이다..
       -h,--help     도움말 출력
       -v,--version   vlock에 대한 버전을 출력 한다.
   xlock은 터미널에서와는 달리 사운드 지정 배경 선정 등 많은 옵션을 가지고 있는데 이것은 맨 페이지를 참고 해야 할 것이다(옵션이 너무 많으므로). 또한 엑스 윈도우에서 화면 잠금 이라는 메뉴를 찾아 보면 있을 것이다. 이것은 엑스 윈도우 관리자에 따라 모양이 많이 틀릴 것이다.

     4.1.3 System의 Log 파일 처리
  리눅스에서 침입자의 가 있었는지 알아보는 것이 간단하게 로그 파일을 보는 것으로도 알 수 있다. 당신이 log 파일에서 확인해야 할 사항은 다음과 같다. 
      1. 짧거나 불완전한 기록. 
      2. 이상한 시간 표시를 가진 기록. 
      3. 잘못된 허가권이나 소유권을 가진 기록. 
      4. 재부팅이나 서비스의 재시작에 대한 기록. 
      5. 없어진 기록. 
      6. su 사용기록과 이상한 곳으로부터의 접속 기록. 

  4.2 설치시 기본적인 보안 관련 네트윅 환경변수
   < 필요 없는 서버는 실행되지 못하도록 원천 봉쇄한다! >
   여기서 설명하는 바는 유닉스/리눅스에 공통되는 사항이다. 네트워크 서버들은 크게 2 가지 방식으로 실행되는데 하나는 inetd 수퍼 서버에 의해 자동 관리되는 방식이며 나머지 하나는 유닉스의 여타 프로세스와 마찬가지로 직접 실행시키는 방식이다. 후자의 경우에는 부팅 과정을 면밀히 살펴보고 필요 없는 서버들이 작동하지 않도록 시스템 초기화 파일을 수정하면 된다. 보안 문제에 관하여 극도로 예민한 사람은 간단히 그 서버를 시스템에서 삭제하면 그만이다. 리눅스의 경우 그리고 레드햇, 데비안 등의 배포판에서는 서버 설치/삭제가 자유로우므로 괜한 하드디스크 공간을 차지하게 할 필요 없이 삭제하는 것이  좋다고 본다. 원할 때는 언제든지 시스템 운영 도중 설치하고 그 즉시 가동 가능하기 때문이다. 우리가 놓치기 쉬운 부분이 바로 inetd 수퍼 서버에 의해  관리되는 서버들이다. 
      4.2.1 /etc/inetd.conf 에 관하여
  /etc/inetd.conf 청소하기 각 행은 하나의 서비스를 정의한다.  형식은 다음과 같다.
 <서비스명> <소켓 타입> <프로토콜> <플래그> <사용자> <서버 경로> <전달 인수>
# # These are standard services. # ftp    stream  tcp  nowait  root /usr/sbin/tcpd  in.ftpd -l -a telnet  stream  tcp  nowait  root /usr/sbin/tcpd  in.telnetd gopher stream  tcp  nowait  root /usr/sbin/tcpd  gn
   ftp,telnet 등의 서비스는 아주 기본적인 서비스이다. 하지만 마지막 줄에 있는 고퍼(gohper) 서비스는 웹의 등장으로 인해 요즘 별 인기도  없어 대부분 사용하지 않을 것이라고 본다. 잘  모른다면 여러분은 이것을 사용하고  있지 않는 것이며 서비스를 제공할 능력도 되지 않으므로 줄  맨 앞에 샵(#) 문자를 넣어 주석 처리해버리기 바란다. 
# # Shell, login, exec and talk are BSD protocols. # #shell   stream  tcp  nowait  root /usr/sbin/tcpd  in.rshd #login   stream  tcp  nowait  root /usr/sbin/tcpd  in.rlogind #exec    stream  tcp  nowait  root /usr/sbin/tcpd in.rexecd talk     dgram   udp  wait    root /usr/sbin/tcpd in.talkd
 
   위에서 나열한 서비스들은 아주 끔찍한(?)  서비스들이다. 패스워드 없이 원격 로그인하거나 원격에서 서버 상에 프로그램을 실행시킬 수 있는 기능을 제공하기 때문이다. 이런 서비스에 의해  공격당하면 범인도 못 잡는다.  shell, login, exec 등은 개인용 서버가 아닌 이상 위에서처럼 주석처리하기 바란다.
## Finger, systat and netstat give out user information          # which may be valuable to potential "system crackers."   # Many sites choose to disable  # some or all of these services to improve security. # # cfinger is for GNU finger, which is currently not  # in use in RHS Linux # # finger  stream tcp  nowait  root    /usr/sbin/tcpd  in.fingerd #cfinger stream  tcp  nowait  root    /usr/sbin/tcpd  in.cfingerd #systat stream   tcp  nowait  guest   /usr/sbin/tcpd  /bin/ps -auwwx #netstat stream  tcp  nowait  guest   /usr/sbin/tcpd  /bin/netstat
   이미 inetd.conf 설정 파일에 잘 적어놓고  있는 내용이다. 여기에 있는 서비스 들은 외부에게 여러분  서버, 사용자에 관한  정보를 누출한다. finger,  systat, netstat은 주석 처리할 것인가 말 것인가? finger의 예를 들어보자.
[hwinnt@linux:~$]finger linux Login: hwinnt                           Name: Red Hat Linux User Directory: /home/hwinnt                 Shell: /bin/bash On since Mon Aug 17 22:27 (KST) on ttyp1 from carrot    39 minutes 39 seconds idle On since Mon Aug 17 22:28 (KST) on ttyp0 from carrot    1 minute 36 seconds idle No mail. No Plan.  Login: Administrator                    Name: Red Hat Linux User Directory: /home/Administrator          Shell: /bin/bash Never logged in. No mail. No Plan.
 보기 에서 보다시피 도대체 어떤 사람들이 로컬 호스트에서 작업하고 있는지 아주 분명하게 정보를 누출하고 있다. 다음은 헬싱키 대학 서버에서 어떤 사람이 작업하고 있는지 보여주는 예이다. 리눅스 배포판들은 대부분 finger를 할  수 있도록 해두었는데 이는 보안에 관심 없기 때문이 아니다. 리눅스는 상호 신뢰에 의해 개발되는 운영체계이기 때문이다. 하지만 중요한 임무를 수행하고 침입자를 막아야 하는 공개 서버들은 이를 막아야 한다. finger를 막은 호스트인 경우에는 다음과 같은 메시지가 나온다.
[hwinnt@linux:~$]finger linux [linux.klug.org] finger: connect: 연결이 거부됨

     4.2.2 /etc/ftpuser
    이 파일을 들여다 보면은 사용자 계정 이 죽 나열 되어있는데 이것은 FTP로 접속을 하지 못하도록 하는데에 쓰이는 파일 이다 vi 편집기로 열어서 보시면 알겠지만 전부 시스템 관리 계정이다. 이계정들은 ftp 접속을 왜 제안을 하는지 알 것이다. 또한 텔넷으로도 들어오면 안되는 계정들이다.

     4.2.3 /etc/securetty
    이 파일에는 tty1 - 8 번 까지 쭉 나열 되어 있을 것이다. 이것은 가상 콘솔을 나타내는데 리눅스는 기본으로 8개의 가상 콘솔을 사용할수 있도록 설정이 되어 있는데 여기서 터미널 수를 줄이는 것도 보안의 한 방법이라고 할수 있다. 그리고 간혹 텔넷으로 왜 루트가 접속이 안되냐고 하시는 분들이 있는데 이것은 비정적인 것이 아니다. 위에서도 설명한 바와 같이 리눅스의 시스템 계정들은 외부 인터넷 상에서 접속을 하지 못하도록 기본적으로 세팅이 되어 있기 때문이다. 만약 루트 권한이 필요하다면 su 라는 명령어를 사용하여 루트 권한을 빌려서 사용하는 것이 더 효과적이다.

     4.2.3 /usr/sbin/tcpd
   위의 inetd.conf 파일을 보면 서버경로에 /usr/sbin/tcpd 라고 되어 있는 것을 보았을 것이다. inetd.conf 파일에서 인터넷 서비스를 정의 해 놓았는데 이 tcpd 라는 프로그램이 서버에대해서 접근 할수 있도록 해주는 것이다. 이때에 시스템에대한 접근 허락(/etc/hosts.allow) 및 접근 거부(/etc/hosts.deny) 등의 설정을 할 수가 있다. /etc/hosts.allow 파일은 허용 규칙을 정의한다. 설정 형식은 매우 간단하다.

<서비스 목록>: <호스트 목록> [: 명령]

  <서비스 목록>은 규칙을 적용할 서비스의 목록으로서 각각의 항목은 콤마(,)로 구분하여 나열한다. 서버명으로는 ftpd, telnetd, fingerd 등을 들 수 있다.<호스트 목록>은 호스트명을 나열한 것인데  역시 콤마로 구분한다. 호스트명 이외에도 IP 주소를 사용할 수 있다. 또한  호스트명과 IP 주소에 대하여 와일드 카드 문자를 사용하는 것이  가능하다. 예를 들어 gw.vk2ktj.ampr.org와 같이 하나의 호스트를 지정하는 방법도 있고 .uts.edu.au와 같이 호스트명이 저렇게 끝나는 모든 호스트에 대하여 일괄 지정하는 것도 가능하다. 만약 44.이라고 표현하면 이 숫자로 시작하는 모든 IP주소를 가진 호스트를 가리키는 것이다. 이외에는 특별한 심볼이 있는데 ALL은 글자 그대로 인터넷 상의 모든 호스트를 의미하며 LOCAL은 도트(.) 문자를 포함하지 않는 모든 호스트명을 가리키는데 즉 여러분의 호스트 머신과 같은 도메인에 속한 모든 호스트들을 가리킨다. PARANOID는 많이 사용되지 않지만 주소 위조자들을 경계하기 위하여 주소와 호스트명이  일치하지 않는  호스트를 가리킬 때 사용한다. 마지막으로 EXCEPT는 영어 뜻 그대로 전체 호스트에서 어떤 호스트를 제외할 때 사용되는 키워드이다.
    <명령> 부분은 일반적으로 적어주지 않는데 적어준다면 tcpd에 의해  그 규칙이 적용될 때마다 주어진 명령을 수행하도록 하도록 되어 있다. 명령은 완전한 패스명으로 적어주어야 한다. 보통 누가 호스트에 접속하려고 시도하는지 확인하는 명령, 특정인 접속할 때 시스템 관리자에게 자동으로 메일이나 경고 메시지를 보내도록 하는 명령을 적는다.  
  # /etc/hosts.allow   #   # 메일을 모든 사람에게 허용   in.smtpd: ALL   # telnet과 ftp는 같은 도메인에 속한 사람과 집에 있는 본인의 호스트   # 에만 허용   telnetd, ftpd: LOCAL, linux.klug.org   # finger를 허용하되 누가 요청했는지 기록을 남긴다.   fingerd: ALL: (finger @%h | mail -s "finger from %h" root)
   /etc/hosts.deny 파일은 서비스 거부에 대한 파일이다. 일반적으로  ALL: ALL이라는 줄 하나를 넣어서 /etc/hosts.allow에서 허가되지 않는 모든 것에 대하여 기본적으로 거부 정책을 사용하는  것이 좋다고 본다.  /etc/hosts.deny에서 기본 정책으로 모든 서비스에 대하여  그리고 모든  사용자에 대하여  거부를 해놓는  이유는 tcpd가 /etc/hosts.allow와 /etc/hosts .deny에서 어떠한 알맞은 규칙도 발견하지 못할 때는 허가한다는 정책을 가지고 있기 때문이다. 기본적인 거부 정책 다음에 /etc/hosts.allow에 하나씩 허가하는 것이 올바른 절차라고 본다. 주의할 것은 절대 /etc/hosts.allow에  ALL: ALL과 같은  무지한 설정은 하지 말아달라는 것이다. 그리고 tcpd의 규칙 점검 특성  상 특수한 규칙을 앞에 두고 일반적인 규칙을 뒤에 둔다. 순서가 중요하기 때문이다. 여러분이 tcpd 설정만 잘해두어도 훌륭한 관리자라는 평가를  받을 수 있으며 크래커  입장에서는 아주 신경 쓰이는 서버 축에 들것이다. 인터넷 상에 수많은 서버 중 뚫기 힘든 여러분의 서버 주위에서 더 이상 배회하려 들지 않을 것이다.

  4.3 리눅스에서의 셰도우 패스워드
     4.3.1 왜 /etc/passwd 파일을 숨겨야 하나?
    Shadow Suite를 깔지 않은 Linux system에서는, password를 포함한 사용자 정보는/etc/passwd에 보관되어 있다. password는 암호화되어서 (encrypted) 저장된다. 만일 암호학의 전문가에게 묻는다면, 그는 password는 encrypt된 형식이라기 보다는encode된 형식으로 되어 있다. 이유는 crypt(3)을 적용할 때, text는 null로 하고 password를 key로 사용하기 때문이라고 한다. 따라서 이 문서에서는 encode된이라는 말을 쓸 것이다. (역자주 : 사전에는 encode와 encrypt를 같은 뜻으로 사용하고 있읍니다. - 암호로 바꿔쓰다 - 라는 뜻입니다만, 암호학을 전공하신 분들에게는 뉘앙스가 다를 것같습니다. 이에 대한 보충 바랍니다.)  password를 encode하는 데 사용되는 algorithm은 기술적으로는 단방향 hash function과 같은 방법으로 간주되고 있다. 이 것은 순방향으로는 계산하기 편하게 되어 있지만 역방향은 연산이 매우 힘들게 되어 있다. 사용된 algorithm에 대한 자세한 설명은 section 2.4나 crypt(3) manual page에 있다.
  사용자가 password를 선택하거나 할당받을 때, password는 salt(소금?)라고 불리는 무작위로 생성된 값과 같이 encode된다. 이것은 어떤 password든지 4096가지의 다른 방법으로 저장될 수 있다라는 얘기다. salt 값은 encode된 password와 같이 저장된다.
  사용자가 login하고 password를 사용하면, salt는 encode되어 저장된 password에서 뽑혀져 나온다. 그다음 입력된 password와 salt가 같이 encode된다. 그리고,encode되어 저장된 password와 비교한다. 그 결과, 서로 같다면 사용자는 인증된다.
  무질서하게 encode된 password를 획득해서 원래의 password로 되돌리는 것은 계산상으로는 힘들다(그러나 불가능하지는 않다). 그러나, 적지 않은 사용자가 사용하는 system이라면, 적어도 몇몇 password는 일상단어로 이루어져 있다 (또는간단한 변종이다).
  system cracker들는 이런 것을 알고, 자주 쓰이는 password들과 단어의 사전과 가능한 4096가지 salt 값을 사용해서 encrypt을 행할 것이다. 그다음에 그들은 그들의database에 있는 당신의 /etc/passwd file의 encode된 password와 비교할 것이다. 일단 하나라도 일치한다면 그들은 또다른 계정의 password를 가지게 되는 셈이다. 이는 dictionary attack(사전 공격?)이라 고 불리우고, system에 허가되지 않은 접속을 얻을 때 쓰는 가장 보편적인 방법중 하나이다.
  생각해보라, 8문자된 password가 4096 * 13문자열로 encode된다. 그리고, 400,000개의 일반 단어, 이름, password, 약간의 변형들로 이루어진 사전은 4G Byte hard를 쉽게 채울 것이다. 공격자들은 이런 종류의 것이 필요하고, 맞는 지 검사해 볼 필요가 있다. 만일 10000 달러이하로 이런 4G byte짜리 hard를 가질 수 있다면, 대부분의 system cracker들에게는 충분하다.
  또한, cracker가 당신의 /etc/passwd file을 이미 가지고 있다면, 그들은 /etc/passwd file에 포함되어 있는 salt 값만 가지고 사전을 encode하면 된다. 이 방법은 200Megabyte의 공간과 486급 computer를 가지고 있는 보통 청소년이면 이용할 수 있다.  
  심지어 많은 공간없이, crack(1)과 같은 utility들은 최소한 충분히 많은 사용자를 확보하고 있는 system의 password를 2개정도는 깰 수 있다 (user가 자기 자신의 password를 고를 수 있는 system이라고 한다면).
  /etc/passwd file은 user ID와 group ID와 같은 대부분의 system program에서 쓰는 정보를 가지고 있다. 게다가 /etc/passwd file은 "모두 읽기 가능"으로 남아 있어야 한다. /etc/passwd file을 아무도 보지 못하게 하면, 제일 먼저 ls -l 명령이 이제 user 이름대신 user ID를 출력하는 것을 보게 될 것이다!
  Shadow Suite는 password를 다른 file(대개 /etc/shadow)에 위치시킴으로써 이 문제를 해결한다. /etc/shadow file은 어느 누구도 볼 수 없도록 되어 있다. root만이 /etc/shadow를 볼 수 있고, 쓸 수 있다. 어떤 program (xlock 같은)은 password를 바꿀수 있는 권리를 원하지 않는다. password를 확인할 수 있으면 된다. 이런 program들은 suid root로 실행되거나, /etc/shadow를 읽기만 할 수 있는 shadow로 group을 바꾸어 주면 된다. 그러면 program은 sgid shadow로 실행시킬 수 있다.
  password를 /etc/shadow file로 옮겨 줌으로써, dictionary attack를 하기 위해서 encode된 password들에 접근하는 공격자들은 효과적으로 방해할 수 있다.
추가적으로 Shadow Suite는 몇가지 괜찮은 기능을 더 가지고 있다: 

      login 기본사항(/etc/login.defs)들이 준비된 configuration file 
      user 계정 및 group을 추가, 수정, 삭제하는 utility들 
      password의 유효기간 설정과 경과후 취소 
      계정 무효와 동결 
      group password들의 shadow (선택사항) 
      2배 길이를 가지는 passwrd (16문자 password) (권하지 않음) 
      user가 password를 고를 때, 적절한 통제 
      전화접속용 password 
      보조 인증 program (권하지 않음) 

  Shadow Suite를 설치하는 것은 좀 더 보안이 강화된 system으로 만들어 준다. 그러나, Linux system의 보안을 강화시켜주는 다른 많은 것들이 있고, 따라서 궁극적으로 다른 보안 도구나 관련된 사안을 다루는 Linux Security HOWTO series가 생길 것이다.
  알려진 취약점을 포함한 Linux 보안 문제에 대한 정보를 얻으려면 Linux Security home page를 방문하기 바란다.

     4.3.2 /etc/passwd file의 형식
   shadow의 세례를 받지 않은 /etc/passwd file은 다음과 같이 구성되어 있다. 
      username:passwd:UID:GID:full_name:directory:shell
각 요소는
username   사용자 (login) 이름 passwd     encode된 password UID        숫자로 된 user ID GID        숫자로 된 기본 group ID full_name   user의 실제 이름 - 실지로 이 field는 GECOS (General Electric Comprehensive             Operating System: 일반 전자적 종합 운영 체계?) field라고 불리우며, 단지             실제 이름보다는 다른 정보를 가질 수 있다. Shadow 명령들과 manual page는 이              field를 comment로 다룬다.  directory     사용자의 home directory (Full pathname) shell          사용자의 login shell (Full pathname) 예를 들면    username:Npge08pfz4wuk:503:100:Full Name:/home/username:/bin/sh
Np는 salt이며, ge08pfz4wuk는 encode된 password이다. encode된 salt/password는 
kbeMVnZM0oL7I가 될 수도 있고, 둘은 같은 password를 가리킨다. 같은 password에 대해서 4096개의 다른 encoding이 존재할 수 있다. (예를 든 password는 'password'이며, 상당히 나쁜 password이다).
shadow suite가 설치되면, /etc/passwd file은 다음처럼 바뀐다: 
      username:x:503:100:Full Name:/home/username:/bin/sh

두번째 field의 x는 아무 것도 아니다. (공간만 차지하고 있을 뿐이다.) /etc/passwd file의 형식은 전혀 바뀌지 않았다. 단지 encode된 password를 포함하지 않을 뿐이다. 이는 /etc/passwd file을 읽기만 할 뿐 password를 검사하지 않은 program은 아무 이상없이 돌아간다는 것을 의미한다.
이제 password가 shadow file(대부분 /etc/shadow file)로 재배치된다.

     4.3.3 shadow file의 형식

/etc/shadow file은 다음과 같은 정보를 갖고 있다: 
      username:passwd:last:may:must:warn:expire:disable:reserved
각 요소는: 

username      사용자 이름
passwd        encode된 password
last           최근의 password를 바꾼 날 (1970, 1, 1일부터 계산한 날수)
may           password를 바꾼 다음, 또 바꾸기 위해 기다리는 날수 (다음 password로의 변경
              유예기간)
must          다음 password로 바꿀어야 할 때까지의 기간 (현 password 유효기간)
warn          password가 만료되기 전에 user에게 바꿀 것을 경고하는 기간
expire         password가 만료된 뒤, user 계정 사용이 불가능하기까지 기간
disable        계정이 사용 불가능하게 된 날(1970, 1, 1일부터 계산한 날수)
reserved      남겨둠

전의 예제 경우 다음과 같다:    username:Npge08pfz4wuk:9479:0:1000

    4.3.4 crypt(3)에 대해서.
  crypt(3) manual 페이지에 의하면:
  "crypt는 password를 encrypt하는 함수이다. 이는 Data Encryption Standard algorithm를 기반으로, (무엇보다) key를 찾는 기계적인 방법이 이용되기 힘들도록 약간의 변형이 가해져 있다.
key는 사용자가 입력한 password이다. encode되는 string을 전부 NULL이다.
  salt은 a-zA-Z0-9./로 이루어진 집합으로부터 고른 두문자로 이루어진 문자열이다. 이 문자열은 4096개 경우중의 하나로 algorithm이 혼란스럽게 보이려는 목적으로 쓰인다. key의 각 문자의 하위 7 bit을 취함으로써, 56-bit key가 주어진다. 이 56-bit key는 일정한 문자열을, 반복해서 encrypt하는 데 쓰인다. 결과는 13개 ASCII 문자열로, encrypt된 password를 가리킨다 (처음 두개 문자는 salt 그 자신이다). 결과값은 매번 호출될 때마다 다시 쓰이는 고정된 data를 가리킨다.
  경고: key space는 2**56, 즉 7.2e16 가능한 값으로 이루어져 있다. key space를 샅샅이 뒤지는 것은 거대한 병렬 computer를 사용하면 가능할 것이다. crack(1)와 같은, 대부분의 사람들이 password로 삼는 key space의 특정 부분을 찾는 software가 있다. 따라서, 최소한 password를 선택할 때, 자주 쓰이는 단어나 이름은 피하기 바란다. passwd program을 사용하여, 찾기 쉬운 password를 선택하는 지 검사하기를 바란다.
  DES algorithm, 그 자체는 가끔 crypt(3) interface를 사용하는 것이 다른 password 인증을 위한 어떤 것보다 더 나쁜 선택으로 만들어 버리는 경향이 있다. 보안 강화를 위해서 crypt(3)를 사용하려고 한다면, DES만 사용하지 마라: encryption에 대한 좋은 책과 널리 쓰이는 DES library들을 구하라."
  (역자주 : 원문은 The DES algorithm itself has a few quirks which make the use of the crypt(3) interface a very poor choice for anything other than password authentication. If you are planning on using the crypt(3) interface for a cryptography project, don't do it: get a good book on encryption and one of thewidely available DES libraries." 입니다. 그중에서 don't do it: get ...부분이 매우 애매합니다. it이 무얼 가리키는 건지 명확하지 않습니다. 일단, get ...을권유하는 것으로 추측하고 번역을 했는 데...)
  대부분 Shadow Suite들은 password의 길이를 16문자로 늘이는 code를 포함한다. des의 전문가들은 이를 권하지는 않는다. 왜냐하면 전반부를 encoding한 뒤, 긴 password의 후반부를 encoding하는 단순한 방법이기 때문이다. crypt의 방식대로라면, 긴 password를 사용하지 않는 것보다 더 취약한 password를 만들 수 있다. 더욱이, 사용자가 16문자나 되는 password를 기억하기 힘들다는 측면도 있다.  crypt 방법과 호환성을 지니면서, 긴 password를 지원하고 더 강화된 인증(특히, MD5 algorithm)을 할 수 있는 방법이 연구중이다. encryption에 대한 책으로 다음을 권한다: 
        "Applied Cryptography: Protocols, Algorithms, and Source Code in C"
        by Bruce Schneier <schneier@chinet.com>
        ISBN: 0-471-59756-2

    4.3.5 Shadow Suite 가 있는 인터넷 주소
      ftp://ftp.icm.edu.pl/pub/Linux/shadow/shadow-current.tar.gz 
      ftp://iguana.hut.fi/pub/linux/shadow/shadow-current.tar.gz 
      ftp://ftp.cin.net/usr/ggallag/shadow/shadow-current.tar.gz 
      ftp://ftp.netural.com/pub/linux/shadow/shadow-current.tar.gz 

    4.3.6 Shadow Suite Installation Guide
     4.3.6.1 압축풀기.
   package를 받을 뒤 처음 할 일은 풀어 제치는 것이다. package는 gzip으로 앞축된 tar (tape archive) 형식으로 되어 있으므로, /usr/src로 옮긴 뒤: 

      tar -xzvf shadow-current.tar.gz

그러면, /usr/src/shadown-YYMMDD라는 directory에 풀릴 것이다.

     4.3.6.2 config.h file을 가지고 설정합니다.

첫째, Makefile과 config.h를 복사한다: 
      cd /usr/src/shadow-YYMMDD
      cp Makefile.linux Makefile
      cp config.h.linux config.h

그리고 config.h를 보라. 이 file은 몇몇 설정 사항에 대한 정의를 담고 있다. 만일 권고한 package를 가지고 있다면, 일단 group shadow 지원을 사용하지 않도록 하기를 권한다. 기본으로, shadow된 group password들을 사용할 수 있다. 이를 바꾸기 위해서 config.h의 #define SHADOWGRP를 #undef SHADOWGRP로 바꾼다. 나는 그들을 사용하지 않고 시작할 것을 원한다. 나중에 절실히 group password와 group 관리자를 원한다면, 다시 사용가능하도록 한 뒤 재compile하면 된다. 만일 사용가능으로 남겨둔다면, 반드시 /etc/gshadow file을 만들어야 한다. 긴 password 사용을 하는 것은 앞에서 얘기한대로 권하지 않는다.

#undef AUTOSHADOW라고 한 것을 바꾸지 말라.

AUTOSHADOW 선택사항은 shadow를 무시하는 program들이 계속 작동하도록 하려는 목적으로 준비된 것이었다. 이 이야기는 이론상으로는 괜찮지만, 제대로 기능하지 않는다. 이 option을 허용하고 root로써 program을 실행시키면, 그 놈은 getpwnam()를 root권한으로 부르고, 후에 /etc/passwd file에 수정된 내용을 다시 쓰게 된다 (더이상 shadow되지 않은 채로). 그런 program에는 chfn과 chsh가 있다. (getpwnam()를 호출하기 전에, 실제 uid와 유효 uid를 바꾼다해도 이를 회피할 수 없다. 왜냐하면 root도 chfn과 chsh를 사용할 것이기때문이다. (역자주: 모호하네요. system programming에 관한 내용같는 데... 아시는 분의 설명 바랍니다.)) libc를 만들 때도 같은 경우가 있다. SHADOW_COMPAT option이 그 것이다. 그 것은 쓰면안 된다! /etc/passwd로부터 encode된 password를 얻기 시작한다는 것이 문제다. 지금 사용하고 있는 libc version이 4.6.27이전이라면, config.h와 Makefile을 고칠 것이 더 있다. config.h에서 바꿀 것은: 

      #define HAVE_BASENAME 을    #undef HAVE_BASENAME
      으로. 그리고 Makefile에서는: 

      SOBJS = smain.o env.o entry.o susetup.o shell.o \
              sub.o mail.o motd.o sulog.o age.o tz.o hushed.o
      SSRCS = smain.c env.c entry.c setup.c shell.c \
              pwent.c sub.c mail.c motd.c sulog.c shadow.c age.c pwpack.c rad64.c \
              tz.c hushed.c

을 

      SOBJS = smain.o env.o entry.o susetup.o shell.o \
              sub.o mail.o motd.o sulog.o age.o tz.o hushed.o basename.o
      SSRCS = smain.c env.c entry.c setup.c shell.c \
              pwent.c sub.c mail.c motd.c sulog.c shadow.c age.c pwpack.c rad64.c \
              tz.c hushed.c basename.c

으로. 이 고침은 libc 4.6.27이나 그 이후에 포함된 basename.c에 있는 code를 덧붙인다.

         4.3.6.3 원 program의 backup copy들을 만든다.

shadow suite가 대체시킬 program들을 추적해서 backup을 만드는 것도 좋은 생각이다. Slackware 3.0에는 다음과 같다: 

      /bin/su 
      /bin/login 
      /usr/bin/passwd 
      /usr/bin/newgrp 
      /usr/bin/chfn 
      /usr/bin/chsh 
      /usr/bin/id 

BETA package는 Makefile에 backup을 만들 목록이 있지만, 다른 배포판에서 다른 위치에 놓여 있을 수 있기에 설명으로 처리되어 있다. 또한 /etc/passwd file을 backup받기를 바란다. 그러나, 같은 directory에 만들 때, passwd 명령으로 덮어 쓰지 못하도록, 이름을 정할 때 조심해라.

      4.3.6.4 make를 실행
거의 대부분의 설치과정에서 당신이 root 권한을 지닐 필요가 있다. package를 compile하기 위해 make을 실행시킨다: 
      make all
다음과 같은 경고문가 나오는 경우가 있다: rcsid defined but not used (rcsid가 정의되어 있지만 사용되지 않습니다). 괜찮다, 이 건 저자가 version control package를 사용하기에 나오는 것이다.

      4.3.6.5 일이 잘못돼어 갈 경우를 대비해서 boot disk를 준비합시다.
   뭔가 잘못되어 간다면, boot disk를 준비해야 될 것이다. 설치시 boot/root disk를 사용했다면, 그 걸로 충분하다. 그렇지 않다면, Bootdisk-HOWTO에 booting가능한 disk를 만드는 법이 적혀있으니 참조하라.

      4.3.5.6 중복된 man page들을 제거하기
   또한, 대체될 manual page들을 옮기길 바란다. 심지어 backup없이 Shadow Suite를 설치할 정도로 무모할지더라도, 여전히 옛 manual page들은 제거하기를 원할 것이다. 대개 옛 manual page가 압축되어 보관되어 있으므로, 새 것들은 이전 것에 덮어쓰지 못할 수 있다. 제거 또는 옮길 필요가 있는 manual page를 찾기 위해 man -aW command나 locate command를 사용할 수 있다. make install을 실행시키기 전에 그런 식으로 옛 page들을 찾는 것이 일반적으로 더 쉽다.
Slackware 3.0 배포판을 사용한다면, 제거해야 할 man page들은: 
      /usr/man/man1/chfn.1.gz 
      /usr/man/man1/chsh.1.gz 
      /usr/man/man1/id.1.gz 
      /usr/man/man1/login.1.gz 
      /usr/man/man1/passwd.1.gz 
      /usr/man/man1/su.1.gz 
      /usr/man/man5/passwd.5.gz 
또, /var/man/cat[1-9]의 subdirectory에 삭제해야 할 것과 같은 이름을 지닌 놈들이 있다.

        4.3.6.7 make install을 실행

이제 준비가 끝났다: (root로서 이 일을 합시다) 
      make install
이 일은 새 것을 깔거나, 옛 것과 대체하며 file permission을 고친다. 또, man page도 설치한다.
그리고, /usr/include/shadow에 Shadow Suite에 있는 include file을 설치해준다. BETA package를 쓴다면, 직접 login.defs를 /etc에 복사하고, root만이 이를 바꿀 수 있도록 해주어야 한다. 

      cp login.defs /etc
      chmod 700 /etc/login.defs

이 file은 login program의 설정 file이다. 내용을 다시 보고, 당신의 system에 맞게 고치기 바란다. 이것은 root로 login할 수 있는 tty를 결정하고, 다른 보안 관련 setting을 결정한다(password 취소에 대한 기본값같은).

       4.3.6.8 pwconv 실행

다음 일은 pwconv를 실행시키는 것이다. 반드시 root로서 이 일을 해야 될 뿐만 아니라, /etc directory에서 하면 금상첨화다: 

      cd /etc
      /usr/sbin/pwconv

pwconv는 /etc/passwd와 그 안에서 몇몇 field을 가져와 다음 두 file을 만든다: 
/etc/npasswd 와 /etc/nshadow.

pwunconv program은 /etc/passwd와 /etc/shadow로부터 평범한 /etc/passwd file을 만들
경우에 대비해 주어진다.

       4.3.6.9 npasswd와 nshadow의 이름을 바꾼다.

이제 pwconv를 실행시켜서 /etc/npasswd와 /etc/nshadow를 얻었다. 이 것들을
/etc/passwd와 /etc/shadow로 덮어쓸 필요가 있다. 우리는 원 /etc/passwd를 backup을
받기를 원하고, root만 읽을 수 있게 한다. 그리고 backup을 root의 home directory로
옮긴다: 

      cd /etc
      cp passwd ~passwd
      chmod 600 ~passwd
      mv npasswd passwd
      mv nshadow shadow

file의 소유와 permission에 관한 것을 정확하게 해라. X-Windows를 쓸 생각이라면, xlock와 xdm program은 shadow file을 읽을 수 있게 한다 (쓰는 것은 말고). 이 일을 가능하게 하는 방법은 두가지다. xlock에 suid root를 설정해 줄 수 있다(xdm가 root의 권한으로 실행될 수 있다). 또는 shadow file을 shadow group의 root가 소유한 것으로 만드는 것이다. 그러나 두 번째 제안을 하기 전에 shadow group(/etc/group를 보라)이 있는 지 확실히 해라. 현재 system의 어떤 사용자도 shadow group에 속해있으면 안된다. 
      chown root.root passwd
      chown root.shadow shadow
      chmod 0644 passwd
      chmod 0640 shadow
 이제 system을 shadow된 password file을 가지게 되었다. 다른 가상 terminal을 띄우고, login할 수 있는 지 점검하는 것이 좋을 것이다. 지금 해라! 안 돼면, 뭔가 잘못된거다! shadow되지 않은 상태로 돌아가기 위해서 다음처럼 한다: 
      cd /etc
      cp ~passwd passwd
      chmod 644 passwd

그리고 나서, 이전에 있던 장소로 모든 file을 되돌려 놓아야 할 것이다.

     4.3.7 Shadow Passwd 사용법
   이 section은 system에 Shadow Suite을 깔고 나서 알고 싶은 몇몇 주제를 다룬다. 더 자세한 것은 각 명령의 manual page를 참조하기 바란다.

       4.3.7.1 사용자계정 추가, 수정, 삭제
  Shadow Suite는 사용자 계정을 관리하는, 다음과 같은 명령들을 추가했다. 이미 adduser program은 그전에 설치되어 있었을 것이다.

useradd

useradd 명령은 사용자를 추가한다. 또한, 기본 설정을 바꾸기 위해 이 명령을 실행할수 있다.
처음 해야 할 일은 기본 설정을 확인하고, system에 맞게 고치는 것이다: 

      useradd -D


GROUP=1
HOME=/home
INACTIVE=0
EXPIRE=0
SHELL=
SKEL=/etc/skel

기본 설정치는 아마 맘에 들지 않을 것이다. 따라서 지금 사용자를 추가하려면, 각각 사용자에게 공통되는 모든 정보를 정해야 한다. 어쨌든 우리는 기본 설정치를 바꾸고 덧붙일거다.
내 system에서는: 

      기본 group은 100이다. 
      password는 60일마다 한번씩 바꾼다. 
      password가 취소될 수 있으므로 계정이 고정되지 않기를 바란다. 
      기본 shell은 /bin/bash이다. 

이렇게 바꾸기 위해서: 

      useradd -D -g100 -e60 -f0 -s/bin/bash

이제 useradd -D를 치면: 

GROUP=100
HOME=/home
INACTIVE=0
EXPIRE=60
SHELL=/bin/bash
SKEL=/etc/skel

이러한 기본치들은 /etc/default/useradd에 저장된다. 이제 useradd를 써서 system에 사용자를 추가할 수 있다. 예를 들어, fred라는 사용자를 기본치만 적용해서 추가한다면: 

      useradd -m -c "Fred Flintstone" fred

/etc/passwd file에 다음과 같은 명부(?)가 생성된다: 

      fred:*:505:100:Fred Flintstone:/home/fred:/bin/bash

그리고, /etc/shadow file에는: 

      fred:!:0:0:60:0:0:0:0

fred의 home directory가 만들어지고, -m switch가 쓰였으므로 /etc/skel 전체가 그 곳으로 복사된다.또한, 특별히 UID를 지정하지 않았으로, 이미 사용된 UID 다음 것이 쓰였다. fred의 계정이 생겼으나, 우리가 계정을 풀어주기 전까지는 fred는 login할 수 없다. 계정을 풀어주기 위해서는 password를 바꾸어 주어야 한다. 

 passwd fred  Changing password for fred Enter the new password (minimum of 5 characters) Please use a combination of upper and lower case letters and numbers. New Password: ******* Re-enter new password: *******
이제 /etc/shadow는 다음과 같을 것이다: 

      fred:J0C.WDR1amIt6:9559:0:60:0:0:0:0

그리고, fred는 login해서 system을 사용할 수 있다. Shadow Suite에 있는 다른 program들과 같이 useradd가 좋은 점은 /etc/passwd와 /etc/shadow file의 내용을 바꿀 때 방해받지 않는다는 점이다. 따라서 동시에 당신은 사용자를 추가하고, 다른 이용자는 자신의 password를 바꾼다해도, 둘 다 제대로 이행된다. (역자주: mutex lock, race condition같은 걸 생각하면 될 것같습니다.)
 /etc/passwd, /etc/shadow를 직접 편집하는 것보다 이런 명령을 쓰는 것이 더 좋다. 만일 당신이 /etc/shadow file을 편집하고 있고, 그 와중에 한 사용자가 password를 바꾸고, 그리고나서 당신이 편집을 끝내고 저장하면, 그 사용자가 한 일을 잃어버리게 된다. 여기에 useradd와 passwd를 사용한 간단한 대화형 script가 있다: 

#!/bin/bash
#
# /sbin/newuser - Shadow Suite의 useradd와 passwd 명령을 이용해서 
#                 사용자를 추가하는 script
#
# Linux Shadow Password Howto의 예제로써 Mike Jackson <mhjack@tscnet.com>에
# 의해 작성됐음. 사용과 수정을 특별히 허가함.
#
# 이 것은 Slackware의 Adduser program처럼 기본치를 보여주고, 수정할 수 있도록
# 바꿀 수 있었다. 또한 멍청한 입력을 거부하도록 바뀔 수 있었다. 
# (즉, 더 나은 오류 검사등...)
#
##
#  useradd 명령의 기본 설정치들
##
GROUP=100        # 기본 Group
HOME=/home       # Home directory 위치 (/home/username)
SKEL=/etc/skel   # Skeleton(공통적인 내용을 지닌 file들?) Directory
INACTIVE=0       # password가 기한이 지난 뒤 사용자 계정이 무효가 
                 # 되기까지의 기간 (0=그렇게 하고 싶지 않음)
EXPIRE=60        # password 유효기간
SHELL=/bin/bash  # 기본 Shell (full path)
##
#  passwd 명령의 기본 설정치들
##
PASSMIN=0        # password를 바꾼다음 또 바꾸기 위한 유예기간
PASSWARN=14      # password의 기한이 지나기전에 경고하는 기간
##
#  script를 실행하는 사용자가 root인지 확인
##
WHOAMI=`/usr/bin/whoami`
if [ $WHOAMI != "root" ]; then
        echo "You must be root to add news users!"
        exit 1
fi
##
#  사용자 ID(username)와 실제 이름(Full name) 묻기
##
echo ""
echo -n "Username: "
read USERNAME
echo -n "Full name: "
read FULLNAME
#
echo "Adding user: $USERNAME."
#
# $FULLNAME 주변에 ""가 필요하다는 것에 주의할 것. 이유는 이 field는 
# 반드시 공란이상의 무엇인가를 포함하며, "를 없이 useradd command를
# 실행시킨다면, 다음에 이어지는 parameter들도 그 field에 일부분으로
# 인식된다.
#
/usr/sbin/useradd -c"$FULLNAME" -d$HOME/$USERNAME -e$EXPIRE \
        -f$INACTIVE -g$GROUP -m -k$SKEL -s$SHELL $USERNAME
##
#  password에 대한 기본 설정치를 정한다.
##
/bin/passwd -n $PASSMIN -w $PASSWARN $USERNAME >/dev/null 2>&1
##
#  passwd를 실행시켜 password를 입력받는다.
##
/bin/passwd $USERNAME
##
#  결과를 보여줌.
##
echo ""
echo "Entry from /etc/passwd:"
echo -n "   "
grep "$USERNAME:" /etc/passwd
echo "Entry from /etc/shadow:"
echo -n "   "
grep "$USERNAME:" /etc/shadow
echo "Summary output of the passwd command:"
echo -n "   "
passwd -S $USERNAME
echo ""

새로운 사용자를 추가하는 데 script를 쓰는 것은 /etc/passwd와 /etc/shadow를 직접 편집하는 거나 Slackware의 adduser를 쓰는 것보다 훨 낫다. 당신의 특별한 system에 알맞로록 자유롭게 고치기 바란다.

useradd에 대한 자세한 정보는 manual page를 보시길...
usermod
usermod는 사용자에 대한 정보를 고친다. option은 useradd와 비슷하다.

앞의 fred의 shell을 바꾸고 싶으면, 다음과 같이 입력한다: 
      usermod -s /bin/tcsh fred

이제 fred의 /etc/passwd file에 있는 내용은 다음처럼 바뀌어 있다: 
      fred:*:505:100:Fred Flintstone:/home/fred:/bin/tcsh

이번에는 fred의 계정이 97년 9월 15일까지만 쓰도록 하자: 
      usermod -e 09/15/97 fred

그러면 fred의 /etc/shadow file에 있는 내용은: 
      fred:J0C.WDR1amIt6:9559:0:60:0:0:10119:0

usermod에 대한 자세한 정보는 manual page를...
userdel

userdel는 정확히 당신이 원한 것 - 사용자 계정 죽이기 - 를 해치운다. 
      userdel -r username

라고 치면 된다. -r은 사용자의 home directory에 있는 모든 file들과 함께 directory 자체를 지운다. 다른 곳에 있는 file들은 일일이 찾아서 지워야 한다. 삭제보다 계정을 쓰지 못하게 할 거라면, passwd 명령을 쓰기 바란다. 
              
          4.3.7.2 passwd 명령과 passwd 수명 정하기.
   passwd는 말 그대로 password를 바꾸는 데 사용된다. 더우기, root는 다음과 같은 일을 할 수 있다: 

      계정 잠금(lock)과 풀림(unlock)(-l와 -u) 
      password 유효기간(-x) 
      password를 다시 바꾸기 위해 기다려야 하는 기간(-n) 
      password 유효기간 만료임을 알리는 경고는 몇일전에 할 것인가(-w) 
      password 유효기간이 지난 뒤 계정을 잠그기(lock)하기까지의 기간(-i) 
      계정에 대한 정보를 더 자세히 보는 것을 허용함(-S) 

다시 fred의 예로 돌아가면 

      passwd -S fred
      fred P 03/04/96 0 60 0 0

이것은 fred의 password가 유효하고, 96년 3월 4일에 마지막으로 바꾸었고, 언제든지 바꿀 수 있다. 그리고, 60일동안 password를 바꾸지 않으면 그후에는 못쓰고, 그 이전에 fred는 아무런 경고를 받지 않을 것이며, password를 못쓰더라도 계정은 유효하다. 즉, fred의 password가 무효가 된 뒤 들어오면, 새로운 password를 재촉받을 것이다. fred에게 password가 취소되기 14일전에 경고를 하고, 취소된 뒤 14일후 그의 계정을 동결시키려면: 

      passwd -w14 -i14 fred

그러면 다음처럼 fred에 대한 내용이 바뀐다: 

      fred P 03/04/96 0 60 14 14

passwd에 대한 자세한 정보는 manual page에...

             4.3.6.3 The login.defs file.

/etc/login file은 login program, 전체적으로 Shadow Suite에 대한 설정을 담고 있다. /etc/login은 prompt가 어떤 모습을 하고 있는 가부터 사용자가 password를 바꾸면 기본 유효기간은 어떻게 될 것인가에 대한 설정까지 담고 있다. /etc/login.defs file은 내부에 있는 수많은 comment들로 잘 문서화되어 있다. 있는 것을 간단히 설명하면: 
 
      발생하는 log의 양(?)을 결정하는 on/off방식의 flag들. 
      다른 설정 file을 가리키는 pointer들. 
      password 유효기간 설정같은 기본 설정치들. 

위에서 보듯 이 놈은 상당히 중요한 file이다. 따라서, 지금 있는지 확인하고, system과 당신 취향에 맞는 지 점검할 것.

       4.3.7.4 Group passwords.
     /etc/groups file은 사용자가 특정 group의 회원이 될 수 있도록 허용하는 password를 담고 있다. 이 기능은 /usr/src/shadow-YYMMDD/config.h의 SHADOWGRP 상수를 정의할 경우 작동된다. 만일 이 기능을 쓴다면, /etc/gshadow file을 만들어, group password와 group 관리자에 대한 정보를 담을 수 있도록 하라. /etc/shadow를 만들 때, 당신은 pwconv를 썼지만, /etc/gshadow를 만드는 데에는 그런 program이 없다. 하지만 걱정말라. 알아서 하니까. 처음 /etc/gshadow를 만들기 위해서 다음처럼 해라: 

      touch /etc/gshadow
      chown root.root /etc/gshadow
      chmod 700 /etc/gshadow

당신이 새로운 group을 만든다면, 자동적으로 /etc/group와 /etc/gshadow file에 그들이 덧붙여진다. group에 사용자를 추가하거나 삭제, 또는 group password를 바꾸면, /etc/gshadow file은 따라서 바뀔 것이다. groups, groupadd, groupmod, groupdel program이 group을 고치는 도구로써 Shadow Suite에 포함되어 공급된다. /etc/group file의 형식은 다음과 같다: 

      groupname:!:GID:member,member,...

각 요소는:  groupname     group 이름
            !              이 field는 password란이지만 /etc/gshadow file로 옮겨졌다.
            GID           group ID number
            member        group member의 list
이다.

/etc/gshadow file 의 형식은 다음과 같다: 
      groupname:password:admin,admin,...:member,member,...
각 요소는: 
             groupname     group 이름
             password       encode된 group password.
             admin          group 관리자 list
             member         group member list

이다. gpasswd 명령은 group의 사용자나 관리자를 추가, 또는 삭제할 때 쓴다. root또는 관리자만이 group member를 추가, 삭제할 수 있다. group password는 root나 group 관리자에 의해 passwd 명령으로 바꿀 수 있다. gpasswd에 대한 manual page가 현재 제공되어 있지 않지만, 아무런 parameter없이 gpasswd를 치면 option에 대한 list가 나오므로, file format과 개념만 잘 이해하면사용법을 쉽게 익힐 수 있다.

         4.3.7.5 일관성 점검 program들

     pwck

pwck program은 /etc/passwd와 /etc/shadow file간에 틀린 점이 없는 지 점검한다. 이 것은 각각 사용자에 대해 다음과 같은 사항을 점검한다: 
      field의 갯수는 맞는가 
      사용자 이름은 유일한가 
      사용자와 group id 
      기본 group 
      home directory 
      login shell 
또한, password가 없는 계정에 대해 경고를 준다.

Shadow Suite을 깐 뒤, pwck를 실행시키는 것은 좋은 생각이다. 주나 월단위등 주기적으로 실행시키기를 권한다. -r option을 쓴다면, cron으로 하여금 정기적으로 실행하고 결과를 보고하도록 할 수 있다.

        grpck

grpck program은 /etc/group와 /etc/gshadow file간에 틀린 점이 없는 지 점검한다. 이것은 다음과 같은 사항을 점검한다: 
      field의 갯수는 맞는가 
      사용자 이름은 유일한가 
      사용자와 관리자의 list가 맞는가 

자동 보고서를 위해 -r option이 있다.

     4.3.7.6 Dial-up passwords.

Dial-up password는 전화접속을 허용하는 system에게는 또 하나의 방어선이다. 당신은 직접이든 network를 통해서건 많은 사람들이 system에 접속하게 할 수 있지만, 전화접속을 할 수 있는 사람을 제한하고 싶다면, dial-up password는 좋은 해결책이다. dial-up password를 쓰고 싶다면, /etc/login.defs의 DIALUPS_CHECK_ENAB를 yes로 바꾸면 된다. 두 file이 전화접속에 대한 정보를 담고 있다. /etc/dialups는 ttys에 대한 내용이다 ("/dev/"는 제거된 채로 line당 하나씩). tty가 list에 올라와있다면 dial-up 검사가 수행된다(?). 두번째는 /etc/d_passwd이다. 이 file에는 password와 shell의 완전한 pathname이 들어 있다. tty를 통해서 log하는 사용자가 /etc/dialups에, 그의 shell이 /etc/d_passwd에 있다면, 그는 제대로 password만 입력하면 된다. dial-up password의 또 다른 이용법는 한 line에 어떤 접속 유형(대개 PPP나 UUCP 접속)을 허용할 것인가를 정하는 것이다. 사용자가 다른 유형의 접속(특히, 일련의 shell로써)을 시도하고자 한다면, line을 사용할 수 있는 password를 알고 있어야 한다. dial-up 기능을 사용하기 전에, file들을 만들어야 한다.
dpasswd 명령은 password와 /etc/d_passwd에 있는 shell을 연결해준다. 자세한 정보는 manual page에...

  4.4 리눅스에서의 방화벽

  리눅스 인터넷/인트라넷 서버 활용 분야에 있어 리눅스 커널과 간단한 관리 도구 하나만으로도 아주 훌륭한 방화벽 기능을 해낼 수 있다는 사실에 많은 사람들이 놀라워하고 있다.  아직은 실험적인 수준의  코드라고 하지만 리눅스에서 실험적이지 않은 것이 얼마나 있었던가? 그리고 리눅스에서 말하는 실험적  코드는 여러분이 이미 알고 있는 상용 소프트웨어의 베타 버전과는 성격이  다르다. 또한 실험적 코드라 할지라도  여러분의 실제 평가에 따라  쓸만한 것으로 판명되면 좋은 일이고 만약 그렇지 못하다면 채택하지 않으면 그만이다.

      4.4.1 준비 사항
1. 커널 컴파일을 해야 하므로 커널 소스가 필수적이다. 각 배포판에는 커널 소스가 기본적으로 포함되어 있다(커널 버전 2.0.0 이상).

2. ipfwadm 이라는 네트워크 관리 도구가 있어야 한다. 최신 배포판에는 모두 포함되어 있다.    만약 여러분의 배포판에서 찾을 수 없다면 <ftp:/ftp.xos.nl/pub/linux/ipfwadm>에 가서 ipfwadm
-2.3.0. tar.gz 파일을 받아와서 간단히 make 그리고 make install 과정만으로 쉽게 설치할 수 있을 것이다.

       4.4.2 리눅스 네트워킹 코드로 할 수 있는 일은?

우선 IP 방화벽을 구축할 수 있다. IP  방화벽이라 함은 여러분이 정하는 규칙(어떤 호스트 또는 네트워크로부터 오는 또는 가는 패킷을 차단할  것인가? 어떤 서비스에 관한 패킷을 차단할  것인가?)에 따라 패킷을 허가하거나  거부할 수 있는 기능이다. 이렇게 아예 패킷 수준에서부터 차단함으로써 기존의 각 서버 소프트웨어 자체의 보안 기능보다 훨씬 높은 수준의 보안 대책이 마련될 수 있게 되었다. 이미 커다란 업체들에서는 모두 방화벽 하드웨어나 소프트웨어를 사용하고 있다.리눅스는 이 방화벽 기능을 커널 네트워킹 수준에서 처리하고 있다. 이는 여러분이 고가의 라우터 장비나 방화벽  전문 소프트웨어를 구입하지 않고  단순히 리눅스를 설치하는 것 하나만으로도 게이트웨이, 라우터  역할의 해낼 수 있게 되었다는 것을 의미한다. 돈 많은 회사들은 일단 제치고라도 학교나 비영리 사회단체들은 충분히 리눅스의 이 기능으로부터 혜택을 받을 준비가 되어 있다고 할 수 있다. 상황은 일반적으로 다음과 같다. 하나의 이서네트  또는 기타 방식의 인트라넷이 구축되어 있는 상태이다. 그리고 그 인트라넷과 인터넷의 접촉 지점에 리눅스를 탑재한 게이트웨이 머신이  놓여 있다. 인트라넷이  인터넷과 연결하면서 제일 중요한 면이 바로 인터넷의 자원을 풍부히 활용하면서도 인트라넷의 정보가 외부로 유출되지 않고 인터넷의 잠재적인 공격에 대한 불안을 해소하는  것이다. 바로 리눅스가 인터넷과 인트라넷의 중간에 놓여  패킷 필터링(Filtering) 작업을 해냄으로써 문제를 해결하게 될 것이다. 그 다음 할 수 있는 일로는 IP 교통량에 대한 분석(IP Acco unting) 그리고 하나의 공식적인 인터넷 IP를 인트라넷의  여러 컴퓨터들이 공유하여 사용할 수 있도록 하는 IP 매스커레딩(IP Masquerading) 기능을 들 수 있다.  IP 분석 기능을 같이 활용하면 관리자의 입장에서 얘기치 않은 방화벽 보안 구멍을  발견하는 것이 가능하다.

IP 방화벽(IP Firewall) 우선 커널 컴파일을 해야 할 필요가 있을지 모른다.
Networking options  ---> [*] Network firewalls .... [*] IP: forwarding/gatewaying .... [*] IP: firewalling [ ] IP: firewall packet logging
위에서 나타낸 옵션이 커널 기능에 들어 있어야만 가능하다. 만약 앞으로 수행하는 명령이 제대로 실행되지 않을 때는 커널 컴파일 과정을 재차  확인해보기 바란다. 노파심이지만 정말로 많은  사람들이 커널을 컴파일해두고  제 위치에 커널을 복사하고 lilo를 다시 실행시키지 않는 경우가 허다하다. 레드햇 배포판의 경우 lilo.conf가 가리키고  있는 커널의 위치는 /  디렉터리가 아니라 /boot 디렉터리이다. 커널 컴파일 과정중  make zlilo는 커널을 /boot  위치가 아닌 / 위치에 복사하고 lilo를 실행시키므로 각별히 주의하라.

       4.4.3 방화벽(Firewall)이란 무엇인가?

방화벽이라 함은 자동차 분야의 용어였다고 한다.  방화벽은 자동차 엔진과 승객 사이의 차폐막 역할을 해주는  장치를 가리킨다. 자동차 엔진에  불이 붙는 상황이 벌어져도 화재로부터 승객을  보호하기 위해서 고안되었다.  이 용어가 그대로 네트워크 분야로 와서 컴퓨터 네트워크 관련의 의미를 가지게 되었는데 여기서의 방화벽이란 사적인 네트워크를 일반적으로 인터넷과 같은 공공의  네트워크로부터 보호하는 장치를 통틀어 말한다.앞으로 방화벽 역할을 해내는 컴퓨터를 그냥  간단히 방화벽이라고 부른다. 이 방화벽은 여러분이 보호하고자 하는 인트라넷과 같은 사적인 네트워크와  인터넷 둘 다 접근할 수 있는 특별한 위치에 놓인 컴퓨터이다. 간단히 말해 인트라넷은 인터넷을 접근할 수 없으며 또한 인터넷은 여러분의 인터넷을 접근할  수 없도록 하는 것이다. 이렇게 인트라넷과 인터넷의  연결 부분에서 방화벽이 차단하고 있으므로 만약 인트라넷에 있는 어떤 사람이 인터넷을 사용하고자 한다면 우선은 방화벽에 텔넷으로 로그인한 후 그 곳에서 인터넷을 사용해야 한다. 보통 가장 간단한 형태의 방화벽은 이중 네트워크로서 서로 다른 네트워크  두 
개에 대하여 각각 연결되어 있다. 이서네트 카드를 2개 달고 있거나 하나는 이서네트, 하나는 전화선이나 전용선을 통한 PPP 접속인 경우가 많다.

       4.4.4 방화벽의 주요 기능

   방화벽은, 일반적으루 네트위크 서비스 별로 해당 서비스를 요구한 호스트 IP 주소와 포트 번호, 사용자 인증에 기반을 두고 외부에서의 침입으로부터의 방어를 하게 된다. 허가된 네트워크 사용자에게는 원하는 서비스를 제공하면서 허용되지 않은 사용자 에게는 서비스를 차단하고, 해당 서비스의 허용 또는 실패에 대한 로그 파일을 남긴다.
      1. 외부 네트워크와 연결된 유일한 창구 (Gateway)
      2. 서비스 접속 허용 및 거부
      3. 사용자 인증 포함
      4. 내 왜부 상호 접속된 네트위크에 대한 트래픽 감시, 기록

       4.4.5 Kind of FireWall

   <Packet Filtering type>
   패킷 필터링 방식은 네트위크의 OSI 모델에서 네트위크층(IP Protocol)과 전송층 (TCP Protocol)에서 패킷을 필터링 하는 기능을 하면서, 패킥에 대한 경로 배정을 위한 자체 프로토콜을 함께 사용하는 형태의 방화벽 시스템이다. 패킷 필터링 방식의 방화벽은 스크리닝 라우터로 구성할수도 있으며, 베스천 호스트와 페킷 필터링 소프트웨어로도 구성할 수가 있다.
   <Application Proxy type>
   어플리케이션 프락시 방식의 방화벽은, OSI 7 Layer Network Model에서 제 7계층인 어플리케이션 계층에 방화벽 기능을 구현하게 된다. 이렇게 구현된 게이트 웨이는 각 서비스 별로 Proxy 데몬이 있기 때문에 프락시 게이트 웨이 또는 응용 게이트 웨이라고 부르기도 한다. 어플르케이션 프락시 방식의 게이트 웨이는 각 서비스별 프락시가 서비스 요구자의 IP address and port를 기반으로 네트워크 접근 제어를 수행하며, 아울러 사용자 인증 및 기타 부가적인 서비스를 지원할수 있다.  
   <Circuit Gateway type>
   위에서 알아본 어플리케이션 프락시 방식의 방화벽에서는, 각 서비스 마다 프락시가 존재 하지만, 서킷 게이트 웨이 방식의 방화벽에서는 OSI 7 Layer Network Model에서 4계층과 5계층 에 해당되는 부분에 TCP Proxy 와 UDP Porxy가 존재 하게 된다. 

       4.4.6 IP 패킷 필터링 방화벽
방화벽을 구축하는데는 크게 2 가지 방법이 있다고  한다. 하나는 지금부터 설명하고자 하는 패킷 필터링  방화벽(IP Packet Filtering  Firewall)이고 나머지 하나는 프록시(Proxy, 대리인) 서버 방법이 있다. 패킷 필터링이라는 말이 의미하듯 이런 형태의 방화벽은 패킷을 여러분이 정하는 특정 규칙에 따라  걸러내는 방식이다. 어떤 패킷은 그냥 거부해버릴 수 있고  어떤 패킷에 대해서는 허가할 수 있다. 여기서 중요한 것은 바로 그 어떤 패킷이라는 기준이 어떻게 성립되는가하는 것이다. 패킷 내부에는 패킷을 보낸 발신지의 주소, 패킷이  도착하고자 하는 목적지 주소, 패킷이 도착하고자 하는 목적지의 포트(Port) 그리고 TCP/UDP 등의 패킷 형태 등에  대한 정보가 기입되어 있다. IP  패킷 필터링 방화벽은 바로 패킷의 내부를 조사한다.

       4.4.7 IP 패킷 필터링 규칙

● 발신지/목적지 주소
 그 패킷이 어디로부터 오는지 그리고 어느 곳으로 가려 하는지 점검하여 결정한다. 몇몇 지역에 지사를 두고 있는 회사가 있다고 하자. 각 지역에는  인트라넷이 구축되어 있고 그 인트라넷은 인터넷을 통해 연결되어 있다. 각 인트라넷은 인터넷의 연결 지점에 리눅스  방화벽을 설치하고 각각의 인트라넷  주소만 허용하도록 설정하고 나머지 주소에서 오는 패킷은 거부해버린다.
● 프로토콜의 종류 : TCP, UDP, ICMP
● IP 옵션
IP 패킷에 몇 가지 사적인 네트워크에게는 위험한  옵션들이 있다. 그 중 하나는 소스 라우트(source route) 옵션인데  이 패킷이 여러분의 네트워크에 돌아다니면 외부에서 여러분의 네트워크가 어떻게 구축되어 있는지 파악할 수 있기 때문이다. 일반적으로 이런 패킷은 거부해야  한다. 외부에서 여러분의  네트워크 구성을 알 필요가 없지 않은가?
● 발신지/목적지 포트 번호
TCP/UDP 헤더 부분에는 포트 번호가 기입되어 있다. TCP/IP 네트워크에서는 바로 포트 번호를 가지고 서비스를 구분한다. 어떤 호스트에 도착한 같은 패킷이라 할 지라도 23번 포트를 향해 달려온 패킷은 텔넷 서비스에 관계된 패킷이며 25번 포트는 메일 서비스에 관련된 것이다. 여러분이 잘 알고 있는 웹 서비스는 일반적으로 80번 포트를 사용한다. 특정 포트 번호가 기입된 패킷을 필터링함으로써 여러분은 아주 쉽게 서비스 제한을 할 수 있다. 감이 잘 오지 않으면 /etc/services 파일을 곰곰이 살펴보기 바란다. 각 서비스에 관하여 그것이 TCP를 사용하는지 UDP를  사용하는지 그리고 사용하는 포트는 무엇인지 적혀 있다.
● TCP 플래그
연결지향(Connection-Oriented)  방식의  TCP  패킷에는  연결  확립을  위한 ACK/SYN 등의 비트가 있다. 이것을 필터링하면 외부에서는 여러분의 인트라넷에 접속할 수조차 없도록 할 수 있으며 오로지 내부에서 외부로의 접속만 허가할 수 있다. 왜냐하면 연결 확립을 요청하는 패킷을 모두 제거해버리기 때문이다.
● ICMP 메시지 유형
ICMP 패킷에는 ICMP 메시지의 유형에 대한 정보가 담겨있다. 이 메시지의 유형을 걸러낼 수 있다.  예를 들어 어떤 호스트가  살아있는지 확인해보는 ping 명령에서 발신되는 반향 요청(Echo Request) 패킷을 거부하게 되면 외부 침입자 입장에서는 도대체 호스트 컴퓨터가 켜져 있는지 꺼져 있는지 직접 보지 않고서는 확인할 길이 거의 없다.
● 패킷에 든 자료, 네트워크 장치, 패킷의 날짜/시간
이러한 정보에 의거하여 여러분은 판단을 내려야 한다. 리눅스 커널에서 지원하는 필터링 정책(Policy)은 다음 3 가지이다.
● 허가(Accept)
● 부인(Deny)
● 거절(Reject)
  여기서 설명이 필요한 부분은 바로 부인과 거절의 차이일 것이다. 부인은 규칙에 의거하여 필터를 통과할 수 없는 패킷을 아무 소리 없이 버리는데 반해 거절은 필터를 통과할 수 없는 패킷을 버리면서 패킷을 보낸 측에 목적지에 도달할 수 없음 메시지(ICMP Destination Unreachable)를 친절하게 보내준다. 이렇게 하면 발신지 측에서 아무런 이유도 모른 체 한 없이 기다리는 일은 없게 된다. 부인 방법과 거절 방법에 대해서는 여러분의 마음에 달렸다.

  4.5 ipfwadm 의 사용법
  네트워크 보안에 관한 거의 모든 설정을 이 명령  하나로 해결한다. 따라서 여러분이 능력 있는 리눅스 네트워크 관리자가  되려면 사용법에 능숙해야 한다. 여러분도 예상하겠지만 하나의 명령에서 많은 것을 해결하기 때문에 약간 많은 옵션들을 가지고 있다. 하지만 그렇게  처음부터 어려워 할 필요는 없다.  어떤 어려운 일이든 개념만 잘 잡고 들어가면 인간이 만든 이상 이해할 수 없는 것은 없다고 자신에게 장담해보자.

사용형식:
   ipfwadm -A command parameters [options]
   ipfwadm -I command parameters [options]
   ipfwadm -O command parameters [options]
   ipfwadm -F command parameters [options]
   ipfwadm -M [ -l | -s ] [options]

범주
총 4개의 범주로 나눌 수 있는데 
IP  회계분석(IP Accou nting), IP 입력 방화벽(IP Input Firewall) 
IP 출력 방화벽(IP  Ouput Firewall), IP 전달 방화벽(IP Forward Firewall)
영문자의 앞 자와  ipfwadm 명령의 -A, -I, -O, -F 와의 관계를 잘 보아두기 바란다.

명령(command)
ipfwadm 명령 사용형식에 있어 범주를 고른 후 그 다음 명령이 따른다.

● -p   <정책>선택한 방화벽 유형에 대한 기본 정책을 설정하거나 설정 값이 있을 때는 변화시킨다. <정책> 위치에  올 수  있는 값은 위에서도  설명한 바  있는 accept, deny, reject이다. 만약 아무런 규칙에도 해당되지  않는 패킷이 발견되면 바로 기본 정책을 사용한다. -I, -O, -F 플래그와 같이 사용할 수 있다(policy).
● -f    규칙을 모두 지워버린다(flush).
● -l    규칙을 화면에 표시한다(list).
● -a   <정책>규칙을 추가한다(append).
● -i   <정책>규칙을 맨 앞에 삽입한다(insert).
● -d   <정책>규칙을 삭제한다(delete).전달인수(parameters)
● -P  프로토콜 패킷 형태를 선택한다. tcp, udp, icmp 그리고 모든 패킷을 가리키는 all을 선택할 수 있다. 생략하면 all이라고 간주한다(Protocol).
● -S  주소[/마스크] [포트 ...] 주소에 올 수 있는 표현은  호스트명, 네트워크명 그리고 평범한 IP  주소이다. 넷 마스크를 적어주거나 또는 그냥 숫자를 적어주는 것도 가능한데 예를  들어 24는 255.255.255.0과 같다. 24의 의미는 여기서 IP 주소 32 비트에 대하여 왼쪽 24개 비트가 1이고 나머지는 0이라는 말이다. 포트에는 23, 25와 같은 포트  번호를 적거나 telnet, smtp 같은 서비스명칭 또는 ICMP  타입을 적는다. 포트의 범위를 표현할 때는 1023:65535와 같이 포트:포트라는 형식을 사용한다. 생략하면 0.0.0.0/0이라는 값을 사용하는데 이는 모든 주소를 뜻한다(Source).
● -D  주소[/마스크] [포트 ...]  -S와 사용법이 같다. 단 ICMP 포트는 명시할 수 없다(Destination).그 밖의 옵션들(Options)
● -m  전달하도록 허가된 패킷에 대하여  매스커레이딩을 실행한다. 이  옵션은 전달 
방화벽의 허가(accept) 규칙하고만 같이 사용할 수  있으며 커널 컴파일 시 매스커레이딩 지원이 들어있어야 한다(masquerade). 
   < ipfwadm 명령 사용예 >
예를 2 가지 들어보겠다. 이 두 가지 예는 거의 비슷하다. 하지만 두 가지 예로 부터 서로 다른 분위기를 느낄 수 있을 것이라고  생각하여 여기 소개한다. 첫 번째 상황은 인터넷과 연결된 인터페이스에 199.1.2.10이라는 주소를 갖고 인트라넷 측과는 192.168.2.1이라는 주소를 갖는 상황이다.

#
# IP 패킷 회계분석과 전달에 관한 설정
#
#   전달(Forwarding)
#
# 기본적으로 모든 서비스를 부인한다.
ipfwadm -F -p deny
# 전달, 입력, 출력에 대하여 규칙을 비운다.
ipfwadm -F -f
ipfwadm -I -f
ipfwadm -O -f
# 전자우편을 여러분의 서버로 전달
ipfwadm -F -a accept -b -P tcp -S 0.0.0.0/0 1024:65535 -
  D 192.1.2.10 25
# 외부 전자우편 서버로의 접속요청을 전달
ipfwadm -F -a accept -b -P tcp -S 196.1.2.10 25
   -D 0.0.0.0/0 1024:65535

# 웹 접속 요청을 여러분의 웹 서버로 전달
/sbin/ipfwadm -F -a accept -b -P tcp -S 0.0.0.0
 /0 1024:65535 -D 196.1.2.11 80

# 외부 웹 서버에 대한 요청을 전달
/sbin/ipfwadm -F -a accept -b -P tcp -S 196.1.2.
  * 80 -D 0.0.0.0/0 1024:65535

# DNS 패킷을 전달
/sbin/ipfwadm -F -a accept -b -P udp -S 0.0.0.0
  /0 53 -D 196.1.2.0/24

# 현재의 분석 규칙을 비운다
ipfwadm -A -f
# 회계 분석(Accounting)
/sbin/ipfwadm -A -f
/sbin/ipfwadm -A out -i -S 196.1.2.0/24 -D 0.0.0.0/0
/sbin/ipfwadm -A out -i -S 0.0.0.0/0 -D 196.1.2.0/24
/sbin/ipfwadm -A in -i -S 196.1.2.0/24 -D 0.0.0.0/0
/sbin/ipfwadm -A in -i -S 0.0.0.0/0 -D 196.1.2.0/24
  
인터넷과 PPP로 연결되어 있고 내부 네트워크와는 이서네트로  연결되어 있는 리눅스 방화벽의 방화벽 설정 예이다. 하나의  셸 스크립트에 저장해두고 부팅할 때마다 /etc/rc.d/rc.local과 같은 곳에서 한 번씩 실행해주면 좋다.

#!/bin/sh
# '전달(Forwarding)' 규칙 테이블을 비운다.
# 전달에 대한 기본정책을 '허가(accept)'로 변경한다.
#
/sbin/ipfwadm -F -f
/sbin/ipfwadm -F -p accept
#
# .. 이번에는 '들어오는' 패킷에 대하여
#
/sbin/ipfwadm -I -f
/sbin/ipfwadm -I -p accept

# 우선 PPP 인터페이스를 봉쇄한다.
# 개인적으로는 '-a reject -y' 대신 '-a deny'를 사용하고 싶지만 그
# 렇게하면 인터페이스 접속 자체가 불가능하게 된다.
# -o 는 거부된 데이터그램을 기록해두도록 한다.설정 실수에 대한 어떤 공
# 격이 있었는가를 알 수 있으나 디스크 공간을 필요로 한다.
#
/sbin/ipfwadm -I -a reject -y -o -P tcp -S 0/0 -D 
  172.16.174.30/sbin/ipfwadm -I -p accept

# 위조된 패킷은 그 즉시 버린다:
# 멀티캐스트/애니캐스트/브로드캐스트 주소로부터 어떠한 것도 와서는 안
# 된다.
#
/sbin/ipfwadm -F -a deny -o -S 224.0/3 -D 172.16.37.0/24
#
# 루프백 네트워크의 패킷은 회선 상을 돌아다니면 안된다.
#
/sbin/ipfwadm -F -a deny -o -S 127.0/8 -D 172.16.37.0/24

# 외부로부터 오는 SMTP, DNS 접속은 받아들이지만 오로지 메일/네임 서버
# 에게만 전달한다.
#
/sbin/ipfwadm -F -a accept -P tcp -S 0/0 -D 172.16.37.
    19 25 53
#
# DNS는 TCP 뿐 아니라 UDP도 사용한다.  따라서 네임 서버에 대해서는
# UDP도 허용해야 한다.
#
/sbin/ipfwadm -F -a accept -P udp -S 0/0 -D 172.16.37. 19 53
#
# 하지만 NFS 또는 Larry McVoy의 NSF 확장 기능 등 위험한 포트로부터 
# 나오는 답변은 전달하지 못하게 한다. squid를 실행하고 있다면 그 포트 
# 또한 추가하기 바란다.
/sbin/ipfwadm -F -a deny -o -P udp -S 0/0 53 -D 
172.16.37.0/24 2049 2050

# 그 외의 포트에 대해서는 괜찮다.
#
  /sbin/ipfwadm -F -a accept -P udp -S 0/0 53  -D 
     172.16.37.0/24 53 1024:65535

# identd에 대한 접속 요청은 거절(reject)
# 우리는 여기서 'reject'를 사용함으로써 접속하는 호스트에게 즉시 접속
# 해도 소용없다는 반응을 보내준다. 그렇지 않으면 ident가 타임아웃 걸리  
# 는 동안 지연이 생긴다.
#
/sbin/ipfwadm -F -a reject -o -P tcp -S 0/0 -D 
  172.16.37.0/24 113

# 192.168.64 그리고 192.168.65 네트워크는 우리가 믿는 친구들이므로 
# 몇 가지 일반적인 서비스를 허가한다.

#
/sbin/ipfwadm -F -a accept -P tcp -S 192.168.64.0/23 
   -D 172.16.37.0/24 20:23

# 내부에서 발생하는 일에 대해서는 허가하고 통과시킨다.
#
/sbin/ipfwadm -F -a accept -P tcp -S 172.16.37.0/24 -D 0/0

# 다른 대부분의 TCP 접속 요청은 거부하고 기록해둔다.
# (만약 ftp가 제대로 작동하지 않는다면 1:1023 을 추가하라)
#
/sbin/ipfwadm -F -a deny -o -y -P tcp -S 0/0 
    -D 172.16.37.0/24

# UDP도 마찬가지이다.
#
/sbin/ipfwadm -F -a deny -o -P udp -S 0/0 
   -D 172.16.37.0/24

상당히 복잡한 예이긴 하지만 ipfwadm  명령을 어떻게 사용하는지 감을  잡을 
수 있을 것이다. 

  4.6 계정을 가진 사용자들로부터의 보안
   다음으로 주목해야 할 것은 지역 사용자(local user)들의 공격에 대한 보안이다. 필자가 방금 _지역_ 사용자들이라고 말했다는데 주목하기 바란다. 지역 사용자의 접근권을 얻는 것이야말로 시스템에 침입하고자 하는 사람들이 가장 먼저 시도하는 것 가운데 하나다. 지역 사용자들에 보안이 느슨하면, 침입자들은 여러 가지 버그들과 시스템이 제공하는 서비스의 허점을 이용해서 그들이 갖고 있는 보통 사용자의 접근권을 관리자(root) 접근권으로 "업그레이드" 할 수 있다. 지역 사용자들에 대한 보안이 철저하면 침입자들은 뛰어넘어야 할 또 하나의 장애물을 갖게 되는 셈이다.
  설령 가짜가 아니라 해도 (어쩌면 바로 이런 경우에) 지역 사용자들은 당신의 시스템을 쑥밭으로 만들 수 있다. 당신이 모르거나 연락 방법을 모르는 사람들에게 계정을 주는 것은 매우 좋지 않은 생각이다. 어떤 시스템 파일이건 허가권을 바꾸기 전에 당신이 하고 있는 일을 정확히 이해하고 있는지 확인하도록 하라. 제대로 작동하도록 하는 쉬운 방법 같다는 이유로 파일의 허가권을 바꾸는 일은 결코 안된다. 파일의 허가권을 바꾸기 전에 왜 그런 허가권을 가져야 하는지 결정하도록 하라.

         4.6.1 새로운 계정의 생성
     사용자의 계정을 만들 때에는 작업을 위한 최소한의 권한만을 제공해야 한다. 당신의 열 살 난 아들에게 계정을 준다면, 워드 프로세서와 그리기 프로그램에 대한 접근 권한만을 주어야 하며, 어떤 것이건 지울 수 있도록 해서는 안 된다. 다른 사람에게 적절한 접근권한을 제공하려 할 때, 염두에 둘 아래와 같은 좋은 경험법칙들이 있다.

      사용자들에게는 그들이 필요로 하는 최소의 권한만을 주어야 한다. 
      사용자들이 언제/어디서 로그인 하는지 혹은 로그인 해야 하는지 알아야 한다. 
      사용자들이 더 이상 접속할 필요가 없어졌다면 그들의 계정을 삭제하고
      확인하라. 

침입에 사용되는 지역 사용자 계정은 대개 여러 달 이상 사용되지 않고 있는 것들이다. 아무도 사용하고 있지 않기 때문에 이런 계정들은 최고의 공격 도구가된다.

         4.6.2 루트 보안

흔히 시스템에 공격을 가하는 또 다른 지역 사용자는 당신의 리눅스 관리자, 즉 바로 당신이다! :) 루트 계정은 매우 짧고 특별한 작업을 위해서만 써야하며, 대부분의 경우에는 관리자 자신도 보통 사용자로서 사용해야 한다는 점을 명심해야 한다. 항상 루트로 작업을 하는 것은 매우 매우 매우 나쁜 생각이다. 루트가 해야만 하는 특별한 작업을 위해서는 su나 sudo를 쓰도록 하라. 루트로 작업하다가 자신의 컴퓨터를 뒤죽박죽으로 만드는 것을 피하기 위한 몇 가지 비결이 있다. 
      복잡한 명령을 써야할 때엔 먼저 파괴적이지 않은 방식으로 해 보도록 하라.       특히 와일드카드를 쓰는 명령의 경우에 주의하라. 예를 들어 "rm foo*.bak"을       하기 전에 먼저 "ls foo*.bak"을 해서 당신이 지우려고 생각하는 파일들만을       지우게 되는지 확인해야 한다. 파괴적인 명령 대신 에코를 쓰는 것도 때로는       좋은 방법이다.        어떤 사람들은 "touch /-i"를 쓰는 것이 도움이 된다고 한다. 이 명령은 "rm -rf       /" 같은 명령을 내렸을 때, 당신에게 정말 모든 파일들을 지우고 싶은지 묻도록       하는 것이다.        특정한 하나의 작업을 하기 위해서만 루트가 되도록 하라. 어떤 일을 하는       방법을 알아내고 싶다면, 루트로서 수행되어야만 하는 작업이 무엇인지 확신할       때까지 보통 사용자의 셸로 돌아가도록 하라.        루트로서 작업을 할 때에는 언제나 느긋하고 신중하게 행동하라. 당신이 하는       행동은 많은 것들에 영향을 줄 수 있다. 충분히 생각한 후에 자판을 두드려라! 
   (바라건대 지극히 믿을 만한) 누군가에게 당신의 컴퓨터에 수퍼유저로서 접근할 권한을 허용할 절대적이고 명확한 필요가 있다면, 도움이 될 만한 도구가 몇 가지 있다. Sudo는 사용자가 자신의 패스워드를 써서 몇 가지 제한된 명령을 루트로서 내릴 수 있도록 해준다. 예컨대 sudo를 이용해서 리눅스 시스템의 어떤 사용자가 다른 루트로서의 특권을 갖는 일없이 시디롬이나 디스켓을 제거하거나 마운트하는 것이 가능하도록 할 수 있다. sudo는 누가 무엇을 하기 위해 어떤 명령을 사용했는지 추적할 수 있도록, 모든 sudo 사용 시도와 성공에 대한 기록을 작성한다. 이런 까닭으로 많은 사람들이 루트 접근권을 갖는 곳에서는 변경 사항을 추적할 수 있도록 sudo를 쓰도록 하는 것이 좋다.
    
          4.6.3 트로이의 목마
   트로이의 목마는 호머의 위대한 문학작품에 나오는 전설적인 책략에서 비롯된 이름이다. 그럴듯해 보이는 어떤 프로그램이나 이진 파일을 업로드해 놓고, 다른 사람들이 그것을 다운 받아서 루트로서 돌리도록 한다는 아이디어다. 그렇게 되면 당신은 파일을 실행시킨 사람들이 주의를 기울이지 않는 동안 그들의 시스템을 손상시킬 수 있다. 관리자들이 방금 받아온 이진 파일이 한 가지 일을 (아마도 매우 잘) 한다고 생각하고 있는 동안, 그 파일은 그들의 보안을 손상시킨다. 당신은 컴퓨터에 설치한 프로그램이 어떤 것인지에 주의를 기울여야 한다. 레드햇은 md5 checksum과 pgp 표시가 된 rpm 파일들을 제공하므로 설치하고 있는 프로그램이 진짜인지 확인할 수 있다. 소스를 갖고 있거나 매우 유명한 것이 아닌 한, 어떤 이진 파일도 루트로서 실행시켜서는 안 된다! 소스를 공개하여 대중적인 검사를 받도록 하는 침입자는 거의 없다.
   복잡할 수도 있지만, 어떤 프로그램의 소스를 올바른 배포처에서 가져왔는지 확인하도록 하라. 프로그램을 루트로서 실행시킬 예정이라면, 당신이나 믿을 만한 누군가가 소스를 훑어보고 확인하도록 해야 한다.

           4.6.4 패스워드 보안 & 암호화
     암호는 오늘날 쓰이고 있는 가장 중요한 보안 기법 가운데 하나다. 안전하고 추측할 수 없는 패스워드를 갖는 것은 당신에게나 당신의 사용자들에게나 중요한 일이다. 요즘의 리눅스 배포본들은 대부분 쉽게 추측할 수 있는 패스워드는 설정할 수 없도록 하는 'passwd' 프로그램을 포함하고 있다. 당신의 passwd 프로그램이 이런 특성을 가지고 있는 최신판인지 확인하도록 하라.
    암호화에 대한 깊은 토론은 이 문서의 범위를 벗어 나는 것이지만, 소개는 필요하다. 암호화는 매우 유용하며, 요즘 같은 시대에는 필수적이기까지 하다. 세상에는 자료를 암호화하는 수많은 방법이 있으며, 각각 나름의 결함과 약점이 있다. 당신이 알고 있어야 할 만한 흔히 쓰이는 방법에는 아래와 같은 것들이 있다. 유닉스 암호 암호화(unix password encryption): 대부분의 유닉스 체제들은 (리눅스도 예외가 아니다) 당신의 패스워드를 암호화하기 위해 DES(자료 암호화 표준, Data Encryption Standard)를 사용한다. 이렇게 암호화된 패스워드는 (흔히) /etc/passwd (혹은 덜 흔하게는) /etc/shadow 에 저장된다. 당신이 로그인 하려고 시도하면, 당신이 입력한 것은 다시 암호화되어 passwd 파일 내의 기재사항과 비교된다. 둘이 일치하면 같은 패스워드임이 분명하므로 당신의 접근은 허가된다. DES는 일방통행 식의 암호화 방법이다. DES는 빠른 컴퓨터가 많은 요즘 같은 시대에는 상당히 취약하다고 알려져 있다. 당신의 패스워드가 충분히 불규칙적인 것이 아니라면, crack이나 John the ripper (아래를 보시오) 같은 난폭한 공격에 의해 패스워드를 간파 당하는 경우가 있을 수 있다. PAM 모듈은 패스워드를 지키기 위해 (MD5나 그 비슷한) 다른 암호화 방법을 사용할 수 있도록 해준다. (아래를 보시오) PAM - Pluggable Authentication Modules 레드햇 리눅스 배포본의 새로운 버전은 "PAM"이라는 새로운 것을 포함하고 있다. PAM은 시스템 실행 중에 인증 방법과 요구를 바꿀 수 있도록 해준다. 어떤 바이너리 파일도 다시 컴파일할 필요가 없다. PAM의 설정 방법은 이 문서의 범위를 넘어서므로 더 자세한 정보가 필요하다면 PAM의 웹사이트를 살펴보기 바란다. http://www.kernel.org/pub/linux/libs/pam/index.html 
PAM으로 할 수 있는 일 가운데 몇 가지 만 들어보면 아래와 같다.

      DES 아닌 암호화 방법을 패스워드에 쓴다. (패스워드를 난폭한 암호 해독 시도에
      더 견고하게 만든다) 
      모든 사용자들에게 사용 가능한 자원의 제한을 설정함으로써, 그들이 서비스
      거부 공격을 가할 수 없도록 한다.(프로세스의 숫자, 메모리의 양 등) 
      실행 중에 쉐도우 패스워드를 가능하게 한다.(아래를 보시오) 
      특정한 사용자가 특정한 시간에 특정한 장소에서만 로그인할 수 있도록 한다. 
      
            4.6.5 Crack과 John the Ripper

어떤 이유로 쉽게 추측할 수 없는 패스워드를 쓰도록 하는 새 버전의 passwd를 쓰지 않는다면, 패스워드 크래킹 프로그램을 실행시켜서 당신의 사용자들이 안전한 패스워드를 쓰고 있는지 확인하고자 할 수 있다. 패스워드 크래킹 프로그램은 간단한 아이디어에 의해 작동한다. 이런 프로그램들은 사전에 있는 모든 단어와 그 변형들을 시험한다. 모든 단어를 암호화하여 시스템의 암호화된 패스워드와 비교하는 것이다. 만약에 딱 들어맞는 단어를 찾게되면, 암호를 알아낸 것이다.
 세상에는 많은 패스워드 크랙 프로그램들이 있다. 그 중에 가장 악명 높은 두 가지가 바로 "Crack"과 "John the Ripper"다. http://www.false.com/security/john/index.html 이 프로그램들은 cpu를 엄청나게 사용하겠지만, 당신이 먼저 패스워드 크랙 프로그램들을 써보고 취약한 패스워드를 가진 사용자들을 알아냄으로써, 공격자가 이런 프로그램들을 써서 시스템에 침입할 수 있는지 확인해야 한다. 공격자는 당신의 passwd (유닉스에서는 /etc/passwd) 파일을 얻기 위해서 먼저 다른 허점을 이용하여야 하겠지만, 이런 허점들은 당신이 생각하는 것보다 훨씬 흔하다는 점에 주의해야 한다.

             4.6.6 Tripwire를 이용한 완전성 검사

   Tripwire 같은 완전성 검사 프로그램을 실행시키는 것도 지역 사용자에 의한 (그리고 네트웍을 통한) 시스템 공격을 탐지해내는 매우 좋은 방법이다. Tripwire는 시스템의 중요한 이진 파일들과 설정 파일들 전부에 대한 대조작업을 수행하고 이전의 결과 값들로 이루어진 데이터베이스와 비교한다. 따라서 파일의 모든 변화에 대해서 신호를 받게 된다. Tripwire를 플로피에 설치하고 쓰기 방지 탭을 붙여두는 것이 좋다. 이렇게 하면 침입자는 tripwire 자체를 변조하거나 데이터베이스를 바꿀 수 없게 된다. 일단 tripwire를 설치하고 나면, 하루에 한 번 실행시키거나 해서 뭔가 바뀐 것이 있는지 확인해 보는 것이 좋다. Tripwire는 가장 빠르게 침입자를 감지해낼 수 있다는 점에서 신이 주신 선물일 수 있다. 하지만 대개 시스템의 많은 파일들이 바뀌므로 무엇이 크래커의 짓이고 무엇이 당신 자신이 한 일인지 주의해서 살펴야 한다.

              4.6.7 CFS - Cryptographic File System 과 
                   TCFS -transparent cryptographic File System. 

    CSF는 파일 시스템 전체를 암호화하고 사용자들이 암호화된 파일을 이 암호화된 파일 시스템에 저장할 수 있도록 해주는 방법이다. 이것은 지역의 컴퓨터에서 실행 중인 NFS 서버를 사용한다. rpm 파일을 http://www.replay.com/redhat/에서 구할 수 있고, 그 작동방식에 대한 정보는 ftp://ftp.research.att.com/dist/mab/ 에 더 있다. TCSF는 암호화된 파일 시스템이 모든 사용자에게 쓰기 쉬운 것이 되도록 더 완성도를 높여서 CSF를 개량한 것이다. 
http://edu-gw.dia.unisa.it/tcfs/ 에서 더 많은 정보를 구할 수 있다.

             4.6.7 X11, SVGA와 디스플레이 보안.

         <X11>
 그래픽 디스플레이의 보안은 중요하다. 공격자가 당신 모르게 당신이 입력하는 패스워드를 가로채거나, 당신이 당신의 스크린 상에서 읽고 있는 문서나 정보를 읽거나, 수퍼유저의 권한을 얻기 위해 허점을 이용하기까지 하는 일들을 막기 위해서다. 네트웍을 통해서 떨어져있는 컴퓨터 상의 X 응용프로그램을 수행하는 것도 역시 스니퍼(sniffer)들이 당신과 원격 시스템 사이의 상호작용을 모두 볼 수 있기 때문에 위험으로 가득하다. X는 많은 통제 방식을 가지고 있다. 가장 간단한 것은 호스트에 기반한 것이다. 당신의 디스플레이에 접근할 수 있는 호스트를 지정하기 위해서 xhost를 사용할 수 있다. 하지만 xhost를 쓰는 것은 안전한 방법은 아니다. 누군가가 당신의 컴퓨터에 접근했다면 그들은 "xhost +그들의 컴퓨터"를 입력해서 쉽게 들어올 수 있다. 아울러 믿을 수 없는 컴퓨터로부터의 접근을 허용했다면, 그쪽 컴퓨터의 누구 이건 당신의 디스플레이를 더럽힐 수 있다. 로그인을 위해 xdm(x display manager)을 쓴다면, 더 나은 접근 방법인 MIT-MAGIC-COOKIE-1을 구할 수 있다. 128 비트의 cookie 하나가 만들어져서 당신의 .Xauthority 파일에 저장된다. 원격 컴퓨터에서 당신의 디스플레이에 접근하는 것을 허용할 필요가 있다면, 그 컴퓨터로부터의 접근 만을 제공하기 위해 xauth 명령과 당신의 .Xauthority 파일에 들어있는 정보를 쓸 수 있다. 안전한 X 연결을 위해서 ssh(위에 있는 ssh 설명을 보라)를 쓸 수도 있다. ssh는 암호화되지 않은 자료는 네트웍을 통해 흘러 다닐 수 없도록 하며, 최종 사용자에게는 아무 다른 느낌을 주지 않는다는 장점도 갖고 있다. X 보안에 대해 더 많은 정보가 필요하면 Xsecurity의 man 페이지를 보기 바란다. 안전한 방법은 콘솔에 로그인하기 위해서는 xdm을 쓰고, X 프로그램을 원격 수행시키고 싶은 원격 사이트들로 가기 위해서는 ssh를 쓰는 것이다.

           <SVGA>

SVGAlib 프로그램들은 당신의 리눅스 컴퓨터에 있는 모든 비디오 하드웨어에 접근할 수 있도록 하기 위해 루트로 사용자 설정(suid)이 되어 있다. 만일 이 프로그램들이 깨지면, 대개 콘솔을 사용하기 위해서 다시 부팅시켜야 한다. 당신이 수행시키고 잇는 모든 SVGA 프로그램들이 출처가 분명한 것인지, 최소한 믿을 만한 것인지 확인하라. 더 나은 방법은 SVGA 프로그램들을 아예 수행시키지 않는 것이다.

           <GGI (Generic Graphics Interface project) >

  리눅스 GGI 계획은 리눅스에서의 비디오 인터페이스에 대한 여러 가지 문제들을 해결하고자 하는 시도이다. GGI는 비디오 코드의 작은 부분을 리눅스 커널 안으로 옮겨 놓을 것이며, 비디오 시스템에 대한 접근을 통제할 것이다. 이것은 GGI가 어느 때건 콘솔을 어떤 이미 알려진 좋은 상태로 회복시킬 수 있다는 것을 뜻한다. GGI는 보안 처리도 가능해서 당신의 콘솔에서 수행되고 있는 로그인 프로그램에 트로이 목마가 없는지 확인할 수 있다. http://synergy.caltech.edu/~ggi/ 

            4.6.8 identd

   identd는 주로 inetd 외부에서 수행되는 작은 프로그램으로, 어떤 사용자가 어떤 tcp 서비스를 수행시키는지 추적하고, 누구건 요구하면 추적 결과를 보고한다. 많은 사람들이 identd의 유용성을 오해하고, 이것이 수행되지 않도록 하거나 외부로부터의 모든 요청을 거부하도록 막아둔다. identd는 원격 사이트에 도움을 주기 위해서 있는 것이 아니다. 당신이 원격 identd로 얻은 자료가 옳은지 알 방법은 없다. identd 요청에는 아무런 인증 절차가 없다. 그렇다면 왜 당신은 identd를 수행시켜야 할까? identd가 _당신을_ 도와주기 때문이고, 흔적을 찾아내기 위한 또 다른 자료이기 때문이다. 당신의 identd가 변조되지 않았다면 당신은 tcp 서비스를 쓰고 있는 사람들의 사용자 이름이나 uid를 identd가 원격 사이트에 말해주고 있는 것을 알게 된다. 만에 하나 원격 사이트의 관리자가 당신에게 찾아와서 당신 컴퓨터의 사용자가 자기의 사이트로 침입하려고 했다고 한다면, 당신은 쉽게 그 사용자에 대해서 행동을 취할 수 있다. 당신이 identd를 실행시키고 있지 않았다면, 수많은 기록들을 살펴보고 누가 그 때 있었는지 찾아내야 한다. 이런 경우 일반적으로 훨씬 긴 시간이 걸리게 된다. 대부분의 배포판에 들어있는 identd는 많은 사람들이 생각하는 것보다 더 다양한 설정이 가능하다. 특정한 사용자들에 대해서는 identd가 작동하지 않도록 할 수 있고(이런 사용자들은 .noident 파일을 만들 수 있다), 모든 identd 요청을 기록하도록 할 수 있으며(필자는 이렇게 하기를 권한다) 사용자 이름 대신 uid나 NO-USER를 반환하도록 할 수도 있다.

  4.7 네트윅 상에서의 보안
  사람들이 더 많은 시간을 네트웍에 연결된 상태로 지냄에 따라 네트웍 보안은 점점 중요해지고 있다. 네트웍 보안을 뚫는 것은 물리적 보안이나 지역 보안을 뚫는 것보다 대개 훨씬 쉽고 또 훨씬 자주 일어난다.  네트웍 보안을 돕는 좋은 도구들이 많이 있으며, 리눅스 배포본에 점점 더 많이포함되고 있다.

     4.7.1 패킷 스니퍼(Packet Sniffers)
    일단 한 호스트에 침투한 침입자가 네트웍에 연결된 더 많은 시스템들에 접근할 권한을 얻기 위해 가장 흔하게 사용하는 방법 가운데 하나가 이미 침입한 호스트에서 패킷 스니퍼를 사용하는 것이다. 이 "스니퍼"는 이더넷 포트를 통해 패킷 흐름 가운데 "Password", "Login", "su" 같은 것에만 귀를 기울이고는, 그 다음에 오는 내용을 기록해둔다. 이렇게 해서 공격자는 침투하려고 시도조차 않았던 시스템으로 들어가는 패스워드를 얻게 된다. 명료한 텍스트 패스워드는 이런 공격에 매우 취약하다.  예: 호스트 A가 이미 침입 당했다. 공격자는 스니퍼를 설치한다. 스니퍼는 호스트 C에서 호스트 B로 들어가는 관리자의 접속을 집어내서, 관리자가 B로 로그인할 때 관리자의 개인 패스워드를 얻는다. 그 다음 관리자가 어떤 문제를 해결하기 위해 'su'를 사용하면, 스니퍼는 호스트 B의 루트 패스워드를 얻게 된다. 나중에 관리자가 자기 계정으로부터 다른 사이트에 있는 호스트 Z로 텔넷 접속하면, 공격자는 호스트 Z로 로그인할 패스워드까지 갖게 된다. 오늘날에는 공격자가 패킷 스니퍼를 쓰기 위해 어떤 시스템에 침입할 필요조차 없다. 공격자들은 랩탑이나 PC를 건물 안으로 갖고 들어와서 네트웍에 연결하면 되는 것이다.
  ssh나 다른 암호화된 패스워드 방법을 사용하면 이런 공격을 방해할 수 있다. pop 계정을 위한 ATOP 같은 것도 스니퍼 공격을 방어할 수 있다. (유선을 통해 명료한 텍스트 패스워드를 전송하는 것이 다 그렇듯이, 보통의 pop 로그인은 스니퍼에 대단히 취약하다.)

      4.7.2 시스템 서비스와 tcp_wrapper
  어떤 네트웍에건 당신의 리눅스 시스템을 연결했을 때, 가장 먼저 고려할 것은 어떤 서비스를 제공하여야 하는가 이다. 제공할 필요가 없는 서비스는 막아서 걱정거리를 하나 덜고, 공격자가 구멍을 찾을 만한 곳을 하나 줄여야 한다. 리눅스 시스템에서 서비스를 불가능하게 하는 방법은 많이 있다. 당신은 /etc/inetd.conf 파일을 보고 당신의 inetd가 어떤 서비스를 제공하고 있는지 알아볼수 있다. 필요 없는 서비스는 모두 주석문 처리를 해서 막아버리고 (# 줄의 가장 앞에), inetd에게 SIGHUP 신호를 보내도록 하라. 아울러 해당하는 서비스를 /etc/services 파일에서도 주석문 처리를 하거나 삭제할 수도 있다. 앞으로 어떤 패키지를 쓸 일이 없으리라는 것을 안다면, 그 패키지를 완전히 삭제할수도 있다. 레드햇 배포본에서는 rpm -e 명령으로 한 패키지 전체를 지울 수 있다. 데비안에서는 dpkg로 같은 작업을 할 수 있을 것이다.
  당신은 /etc/rc.d/rcN.d를 확인해야 한다. 여기서 N은 당신 시스템의 런 레벨이다. 그 디렉터리 안에서 부팅 때마다 실행되는 서버들 가운데 혹시 필요 없는 것이 있는지 보라. 필요 없는 스크립트는 그냥 지워버리면, 다음에 부팅할 때에는 그 서버는 실행되지 않는다. BSD 형식의 rc 파일들을 갖고 있다면 필요 없는 프로그램들은 /etc/rc*에서 확인해야 한다. 
  대부분의 리눅스 배포본에는 당신의 모든 tcp 서비스들을 "감싸주는(wrapping)" tcp_wrapper가 들어있다. inetd가 요구를 보내면 진짜 서버 대신 tcp_wrapper (tcpd) 하나가 뜬다. tcpd는 서비스를 요청한 호스트를 확인하고, 요청받은 서비스에 해당하는 서버를 실행시키거나 그 호스트로부터의 접근을 거부한다. 당신은 tcpd를 이용해서 당신의 tcp 서비스로의 접근을 제한할 수 있다. /etc/hosts.allow 파일을 만들고, 당신 컴퓨터의 서비스에 접근할 필요가 있는 호스트들만을 추가하도록 한다. 당신이 집에서 모뎀을 쓰는 사용자라면, 필자는 모든 서비스에 대한 접근을 거부하도록 권한다. tcpd는 서비스에 접근하려다가 실패한 시도들을 기록하므로, 공격을 받고 있다는 것을 알려줄 수도 있다. tcp에 기반한 새로운 서비스를 추가로 제공하게 되면, 반드시 tcp wrapper의 설정에 그 서비스를 추가하여야 한다.

      4.7.3 SATAN과 ISS, 그 밖의 네트웍 검사 프로그램들
   세상에는 포트와 서비스를 바탕으로 컴퓨터들과 네트웍에 대한 검사를 수행하는 많은 소프트웨어 패키지들이 있다. SATAN과 ISS는 그 가운데 비교적 잘 알려진 프로그램이다. 이 소프트웨어들은 표적 컴퓨터의 (혹은 한 네트웍 상의 모든 표적 컴퓨터들의) 가능한 모든 포트에 연결하려고 시도하며, 어떤 서비스가 수행되고 있는지 찾아내고자 한다. 이 정보를 바탕으로 표적 컴퓨터가 어떤 공격에 취약한지 찾을 수 있다.
  SATAN(Security Administrators Tool for Analyzing Networks)는 웹 인터페이스를 가진 포트 검사 프로그램이다. 컴퓨터 한 대나 하나의 네트웍에 대한 검사 강도는 강,중, 약으로 설정할 수 있다. SATAN을 구해서 당신의 컴퓨터나 네트웍을 조사해보고 발견된 문제를 고치는 것이 좋다. SATAN을 선사이트나 유명한 FTP, 웹 사이트에서 구하도록 주의해야 한다. 인터넷에 SATAN을 가장한 트로이 목마가 있었기 때문이다. http://www.trouble.org/~zen/satan/satan.html 
  ISS (Internet Security Scanner)는 포트를 바탕으로 검사하는 또 다른 프로그램이다. SATAN 보다 빠르며, 따라서 대규모의 네트웍을 검사하기에 더 적합할 수 있다. 하지만 SATAN이 더 많은 정보를 제공하는 경향이 있다.

      4.7.4 포트 검색을 감지하기.

    SATAN이나 ISS 등의 소프트웨어가 당신의 컴퓨터를 탐지하고 있다는 것을 경보해주도록 만들어진 도구들이 몇 가지 있다. 하지만 tcp_wrapper를 잘 활용하고 기록 파일들을 정기적으로 살펴보기만 해도, 그런 탐색을 알아차릴 수 있다. tcp_wrapper를 가장 낮은 수준으로 설정해 두더라도 SATAN은 보통의 레드햇 시스템 기록파일에 자국을 남긴다.

      4.7.5 pgp와 public key 암호작성/해독법

  리눅스는 pgp (pretty good privacy)를 잘 지원한다. 2.62와 5.0 버전은 잘 작동한다고 알려져 있다. pgp에 대한 훌륭한 입문서와 사용법이 필요하다면 pgp FAQ를 보기 바란다. 
http://www.pgp.com/service/export/faq/55faq.cgi

      4.7.6 ssh와 stelnet

   ssh (secure shell)와 stelnet은 원격 시스템으로의 로그인과 연결을 암호화해 주는 프로그램들이다. ssh는 호스트 spoofing 공격을 막아내며 (ssh는 전에 연결되었던 호스트로부터 특정한 키가 돌아오기를 기대한다), 원격 컴퓨터와의 모든 통신을 암호화할 뿐 아니라 압축과 X11 forwarding까지 수행한다. ssh는 packet sniffer 공격을 퇴치하기에 매우 좋다. (packet sniffer는 암호화된 패킷만 한 다발 가질 것이다) ssh는 개인 사용자에게는 무료이므로 개인 사이트라면 설치해서 사용하도록 권한다. http://www.cs.hut.fi/ssh/ stelnet은 텔넷 연결을 암호화해주는 텔넷의 보안 대체물이다.

      4.7.7 sendmail, qmail과 MTA들. 

    당신이 제공할 수 있는 가장 중요한 서비스들 가운데 하나가 메일 서버이다. 불행하게도 메일 서버는 공격에 가장 취약한 서비스 중의 하나인데, 그 까닭은 단지 그것이 수행해야 하는 작업의 숫자와 필요로 하는 권한이 많기 때문이다.  sendmail을 쓰고 있다면, 최신 버전을 사용하는 것이 매우 중요하다. sendmail은 매우 매우 오래 전부터 보안상의 허점을 공격당해 왔다. 항상 가장 최근의 버전을 사용하도록 유의하라. http://www.sendmail.org  매주 sendmail 버전을 업그레이드하기에 지쳤다면, qmail로 바꿔보는 것도 고려해볼만 하다. qmail은 처음부터 보안을 염두에 두고 설계되었다. 이 프로그램은 빠르고안정적이고 안전하다. http://www.qmail.org

     4.7.8 서비스 거부를 이용한 공격.

   서비스 거부를 이용한 공격은 시스템 자원의 일부를 매우 바쁘게 만들어서, 정당한 요청에 답하지 못하게 만들거나, 정당한 사용자의 시스템 접근을 거부하게 만드는 것이다. 이런 공격은 근년에 들어 크게 증가해왔다. 비교적 최근의 공격방법 가운데 잘 알려진 것들을 아래에 소개했다. 새로운 공격방법들이 항상 나타나고 있으므로 여기 소개된 것들은 그저 몇 가지 사례에 불과하다는 것을 명심해야 한다. 더 새로운 정보를 얻으려면 리눅스 보안 리스트를 읽도록 하라.
    SYN 범람(flooding). SYN 범람이란 네트웍을 통한 서비스 거부 공격이다. 이 방법은 TCP 연결이 만들어지는 방법에 있는 "허점"을 이용한다. (2.0.30 이후의) 새로운 리눅스 커널들은 SYN 범람 공격에 의해 사람들이 당신의 컴퓨터나 서비스에 접근하지 못하는 것을 막기 위해 CONFIG_SYN_COOKIES와 CONFIG_RST_COOKIES 같은 설정 가능한 옵션들을 가지고 있다. SYN 범람 공격의 위험을 줄이기 위해서는 이 옵션들을 선택해서 커널을 다시 컴파일 하도록 하라.
    펜티엄 "FOOF" 버그. 인텔의 정품 펜티엄 프로세서에 일련의 어셈블리 코드를 보낼 경우 컴퓨터가 동작을 멈춘다는 것이 최근에 발견되었다. 이것은 어떤 운영체제인가에 관계없이 (모조품과 펜티엄 프로, 펜티엄2를 제외한) 펜티엄 프로세서를 사용하는 모든 컴퓨터에 영향을 미친다. 2.0.32 이상의 리눅스 커널에는 이 버그로 인해 컴퓨터가 다운되는 것을 막기 위한 작업 성과들이 포함되어 있다. 펜티엄을 사용하고 있다면, 지금 업그레이드를 해야 한다.
    Ping 범람. Ping 범람은 간단하고 난폭한 서비스 거부 공격의 일종이다. 공격자는 ICMP 패킷 하나를 "먹이"로 당신의 컴퓨터에 보낸다. 공격자가 이 짓을 당신의 컴퓨터 보다 좋은 주파수 대역을 갖는 컴퓨터에서 한다면, 당신의 컴퓨터는 네트웍으로 아무 것도 전송할 수 없게 될 것이다. 이 공격법의 변종 중 하나인 "파도타기"는 당신 컴퓨터의 IP로 반응이 돌아가도록 해서 ICMP 패킷을 다른 호스트에 보낸다. 이렇게 하면 찾아내기가 더 어려워진다. Ping 범람 공격을 받고 있다면, 어디에서 패킷이 오는지 (혹은 오는 것처럼 보이는지) 알아내기 위해서 tcpdump 같은 도구를 쓰도록 하라. 그리고 당신의 네트웍 제공자에게 이 사실을 연락하도록 하라. Ping 범람은 라우터 수준에서 차단하는 것이 가장 쉽다.

         4.7.9 NFS (Network File System) 보안. 

     NFS는 매우 널리 쓰이는 파일 공유 프로토콜이다. NFS를 이용하면 nfsd를 실행시키는 서버의 전체 파일 시스템을 mountd를 실행하는 다른 컴퓨터들과 공유할 수 있다. 많은 사이트에서 사용자들에게 홈디렉터리를 제공하기 위해 NFS를 사용하고 있으며, 이렇게 함으로써 사용자들이 로그인한 것이 어느 컴퓨터이건 사용자들은 그들의 모든 홈파일들을 갖게 된다. 파일시스템을 공유할 때 사용할 수 있는 "보안" 설정이 몇 가지 있다. 당신은 원격 컴퓨터의 루트 사용자(uid=0)를 nobody 사용자로 대응시켜서, 공유된 파일시스템에 완전한 접근권한을 갖는 것을 거부하도록 nsfd를 설정해야 한다. 그러나 개인 사용자는 각자의 (혹은 최소한 같은 uid의) 파일에 대한 접근권이 있기 때문에, 원격지의 수퍼유저는 자기 계정으로의 로그인이나 su 사용이 가능하며, 자기 파일들에 대해서 완전한 접근권을 가질 수 있다. 이렇게 하는 것은 원격 파일시스템을 마운트할 권한을 가진 공격자에게는 사소한 장애물밖에 되지 못한다.
     NFS를 꼭 써야한다면, 꼭 공유해야만 하는 컴퓨터들로만 공유시키도록 유의하라. 루트 디렉터리 전부를 공유해서는 절대로 안되며, 필요한 디렉터리들만 공유해야 한다. NFS에 대한 더 자세한 정보가 필요하면 NFS 하우투를 보도록 하라. NFS HOWTO

        4.7.10 NIS (Network Information service) (예전의YP). 

    네트웍 정보 서비스(Network Information service, 예전의 YP)는 한 무리의 컴퓨터들에 정보를 나누어주는 한 가지 방식이다. NIS 서버는 정보의 표를 가지고 있으면서 그것들을 NIS 대응 파일들로 변환한다. 이 대응 파일들이 네트웍을 통해 제공됨으로써 NIS 클라이언트 컴퓨터들은 로그인과 패스워드, 홈 디렉터리와 셸에 대한 정보(즉 보통의 /etc/passwd 파일에 들어있는 모든 정보)를 얻을 수 있게 된다. NIS를 이용하면 사용자들은 패스워드를 한 번 바꿈으로써 그 NIS 영역에 들어있는 모든 컴퓨터들에 영향을 줄 수 있다. NIS는 결코 안전하지 못하다. 안전하도록 하고자 했던 적조차 없다. NIS는 간편하고 쓸모 있도록 고안되었다. (네트웍 상의 어디에 있건) 당신의 NIS 영역의 이름을 짐작할 수 있는 사람은 당신의 passwd 파일 복사본을 얻을 수 있고, 당신의 사용자 패스워드를 깨기 위해 crack과 john the ripper를 쓸 수 있게 된다. NIS를 속여서 온갖 추잡한 속임수를 쓸 수도 있다. 꼭 NIS를 써야 갰다면, 이런 위험들을 잘 알고 있어야 한다.

       4.7.11 방화벽

   방화벽(firewall)은 당신의 지역 네트웍 안팎으로 오갈 수 있는 정보를 통제하는 한 가지 방법이다. 전형적인 방식은 방화벽 호스트를 인터넷과 지역 lan에 연결시키고, lan과 인터넷 사이의 접근은 방화벽을 통해서만 가능하도록 하는 것이다. 이렇게 하면 방화벽에서 인터넷과 당신의 lan 사이를 오가는 정보를 제어할 수 있다. 방화벽을 설정하는 수많은 유형과 방법들이 있다. 리눅스 컴퓨터는 상당히 저렴하면서도 훌륭한 방화벽이 될 수 있다. 방화벽 코드는 컴파일을 통해 2.0 이상의 커널에 바로 삽입될 수 있다. 사용자 공간 도구인 ipfwadm을 쓰면, 사용 중에도 허용되는 네트웍 소통의 유형을 바꿀 수 있다. 방화벽은 네트웍을 안전하게 하는 매우 중요하고도 유용한 기술이다. 하지만 방화벽이 있으니까 그 뒤의 네트웍에 있는 컴퓨터들의 보안은 필요 없다고 생각해서는 절대로 안 된다. 이렇게 생각하는 것은 치명적인 실수다. 방화벽과 리눅스에 대한 정보를 더얻고 싶으면 가까운 선 사이트에 가서 매우 훌륭한 방화벽 하우투를 읽어보도록 하라.
http://sunsite.unc.edu/mdw/HOWTO/Firewall-HOWTO.html

      4.7.12 IP Spoofing 기술
   미 국방성의 TCP/IP 프로토콜 표준은 1979년 인터넷을 구현하기 위해서 디자인되었다. 가장 많이 쓰이는 TCP/IP는 4.2BSD 시스템에서 구현된 것으로 Bell Lab과 미국방성 네트웍에서 사용되었다. 4.2BSD 유닉스 TCP/IP 프로그램은 매우 유동적이며 사용하기 편리하지만 보안측면에서는 많은 약점을 가지고 있다. 이 약점의 하나를 공격하는 IP Spoofing Attack은 1985년 Morris에 의하여 아이디어가 처음 지적되었고, 실제로 1995년도 San Diego Supercomputer Center를 해킹하는데 Kevin Mitnick이 사용하기도 하였다.

      4.7.12.1 문제의 시작점
   TCP/IP 프로토콜은 구현시의 정확성에도 불구하고 그 설계의 결점으로 인해서 보안상에 큰 취약점을 가지고 있다. 그 요인은 다음과 같다. 

      호스트의 인증 문제 

      호스트에 대한 인증을 IP의 소스 주소만으로 수행한다. 앞서 언급한 TCP의 연결 구분 체계에서도 볼 수 있듯이 공격할 대상의 IP 주소와 포트 번호는 알려져 있고, 소스 호스트의 포트는 ephemeral 포트 번호를 사용하므로 소스 호스트의 IP 주소만을 속일 수 있다면 다른 호스트에 연결을 맺을 수 있다. Berkeley의 `r-utility'들이 단적인 예이다. 순서 번호(sequence number)의 생성 문제  TCP 스펙에서는 순서 번호가 초당 250,000번, 즉 4 microsecond 마다 한번씩 증가시키도록 하고 있다[1]. 그러나, Berkeley에서 구현된 TCP의 순서 번호는 4.2BSD에서는 초당 128만큼 증가하고 4.3BSD의 경우에는 초당 128,000만큼씩 증가한다. 즉, 초당 한번씩밖에 변화하지 않는다. 
 
      4.7.12.2 IP spoofing은 어떻게 막을까?
   IP spoofing 공격은 SYN 공격법과 같은 `Denial of Service' 공격법이 같이 사용되므로 Denial of Service 공격을 막는 것이 곧 IP spoofing 공격을 막는 법이 된다. 중복되는 감이 있지만, 다음과 같은 방법을 소개한다. 

      패킷 필터링이 가능한 라우터를 사용하여 외부에서 내부로 들어오는 패킷중 내부의 IP 주소를 가진 것을 무시한다. 이러한 기능이 가지고 있는 라우터는  다음과 같다.
            Bay Networks/Wellfleet routers, version 5 and later 
            Cabletron - LAN Secure 
            Cisco - RIS software all releases of version 9.21 and later 
            Livingston - all versions 
      그러나, 패킷 필터링 기능을 가진 라우터를 설치하고, 필터를 설정하였다 하더라도 라우터 안쪽에 있는 시스템에서의 IP spoofing 공격은 막지 못한다.  
       순서 번호 생성을 무작위로 한다. 
       순서 번호를 암호화한다. 
   위의 순서 번호에 관한 공격 방지법은 모두 앞서 위에서 지적 했듯이  순서 번호의 생성이 너무 단순하여 예측이 쉬운 결점을 보안하는 것이 목적이다. 사실상, TCP 스펙에서에서 제시한 대로 초당 250,000번씩 순서번호를 증가시키는 것은 운영체제에도 상당한 부하를 야기할 것이므로, 순서 번호의 생성은 지금과 같이 하더라도 쉽게 내용을 분석하지는 못하도록 하자는 것이다. 그러나, 암호화 하는 방법은 현재 방대하게 설치가 되어 사용되고 있는 BSD 계열의 TCP 프로그램을 모두 교체하여 암호를 풀 수 있도록 해야 하므로 실현되기 어렵다고 본다.  로깅(logging)과 경고 기능(alerting)을 강화한다. 예를들면, 비정상적인 패킷을 발생시키는지 감시한다. 
 이 방법은 IP spoofing 공격이 공격하고자 하는 호스트가 신뢰하고 있는 시스템을 무력화 하는 데서 출발하는 점에 착안 한 것이다. 앞서 설명한 공격 예제에서와 같이 상대방의 포트 하나를 무력화 하기 위해서는 SYN 패킷을 여러번 보내야 한다. 하지만, 일반적인 상황에서 SYN 패킷은 한번만 보내면 되기 때문에, 이러한 패킷들이 있는지 미리 감시 하자는 것이다. 그러나, 이런 패킷을 감시하고자 할땐 특별한 목적으로 패킷을 추적하고 감시하는 응용 프로그램의 제작이 선행되어야 한다는 문제점이 있다. 

  4.8 웹서버의 보안
 
      4.8.1 개요
   웹에 대해서는 굳이 언급을 하지 않아도 될 것이라는 생각이 든다. 사실, 웹이 인터넷 확산의 일등 공신이라고 말하더라도 어느 누구 이에 대해서 반박할 사람이 없을 것이라는 것은 명백한 사실이다. 요즘은 웹을 사용하여 전자 쇼핑, 전자 상거래까지 이루어지고 있는 점을 생각해 보면 웹이 앞으로 우리의 생활에 어떠한 영향을 끼칠지는 가히 상상을 불허할 정도이고 실제로 지금도 웹을 모르면 넷맹이라고 치급 받을 정도로 일상 생활에 큰 영향을 끼치고 있다. 그리고 더 나아가서 인터넷에서 한 번이라도 여행해 본 사람들은 제일 먼저 자신의 홈 페이지를 가지고 싶어하며,근래에는 홈 페이지 제작에 관한 열풍마저 불고 있다. 홈 페이지를 제작하는 방법에 관한 책이 수십 종류나 되며, 홈 페이지를 제작해 주는 회사나 단체가 생겨 성황을 누릴 정도로 웹의 관심은 날로 증가하고 있는 점과 함께 요즘 들어 웹 보안에 대한 관심도 증가하고 있음이 느껴진다. 
   일반적으로 웹 보안이라고 하면 대분이 자료 전송 시의 암호화에 대한 이슈가 보안 관련 세미나 등에서 주를 이루고 있고, 가끔씩 웹 서버, CGI, 웹 브라우저와 관련된 프로그램상의 구멍(hole)이나 사실 웹과는 관계없이 독자적으로 개발되었지만 웹에 큰 영향을 미치고 있는 Java가 웹과 같이 이용될 때 야기될 수 있는 보안 문제가 소개가 되고 있는 실정이다. 이번 글은 위의 내용을 기대한 독자들에게는 조금 아쉽지만 다른 관점에서의 웹 보안을 다루고 있다.  이 글에서는 웹이 동작하는 근본적이 구조(working architecture)에 존재하고 있는 보안적 위험성을 해결하여 보다 안전하게 웹 서버가 동작할 수 있게 하기 위해서 대부분의 유닉스에서 제공하고 있는 chroot라는 시스템 함수를 이용하여 웹 서버를 설치하는 방법을 소개하고자 한다. 

      4.8.1.1 웹 서버의 동작 구조와 문제점
   웹 서비스를 제공하기 위해서 서버 머신에는 항상 웹 서버 데몬이 실행되고 있다. 웹 서버가 동작하는 기본적인 구조를 살펴보면 다음과 같다. 
      서버 프로세스는 클라이언트의 웹 서비스 요청을 기다리고 있다가 요청이       들어오면 이 서비스를 처리할 수 있는 새로운 자식(child) 프로세스를       생성하여서 이를 처리하게 하여 주고 이 자식 프로세스는 클라이언트의       요청을 처리하고 나면 자동으로 소멸되게 된다. 
    웹 서버에 따라 약간씩 동작 방법이 달라질 수도 있고 또 서버를 어떻게 설정하냐에 따라서도 조금씩 달라질 수가 있겠지만 특별한 상용 제품을 제외하고는 현제의 구현된 거의 대부분의 웹 서버의 동작 구조가 앞에서 이야기한 시나리오에서 크게 변하지는 않는다.  웹 서버를 설치한 후 웹 서버를 서버 머신에서 실행시킬 경우 대부분의 웹 서버들이 시스템이 부팅 시에 웹 서버 프로세스를 실행시키기 때문에 이 웹 서버는 자동으로 루트 권한으로 동작하게 되어 있다. 그러므로 위의 시나리오에 의하면 클라이언트의 요청을 처리하기 위해서 생성된 자식 프로세스 역시 루트의 권한으로 동작하게 되는 것이다. 보안적인 관점에서 보면 이러한 동작 방법은 매우 위험하다고 볼 수 있다. 왜냐하면, 이는 클라이언트들이 요청을 해 올 때 마다 새로운 루트 권한의 프로세스가 생성되기 때문에 시스템이 불필요한 루트 프로세스가 많이 떠 있는 효과를 가져오게 되기 때문이다. 그러므로, 대부분의 웹 서버들은 클라이언트의 요청을 처리하기 위해서 자식 프로세스를 생성시킬 때 이 프로세스의 권한을 루트가 아닌 다른 사용자로 할 수 있는 방법을 제공하고 있다. 아파치 서버의 경우를 보면 아래와 같은 부분이 있는데 여기서 User에 nobody라고 해주고 /etc/passwd 파일에 nobody라는 사용자를 등록시켜 두면 생성되는 자식 프로세스들은 nobody이라는 사용자의 권한으로 동작하게 된다. 
 /conf/httpd.conf file:       # User/Group: The name (or #number) of the user/group to run httpd as.       #  On SCO (ODT 3) use User nouser and Group nogroup       User nobody        /etc/passwd file:        # grep nobody passwd       nobody:x:1001:1001:nobody user::
nobody 사용자를 만들 때 주의할 점은 패스워드 부분은 *와 같은, 암호화된 결과(encrypted result)가 될 수 없는 문자로 막아 두어야 한다. 만일 shadow passwd를 사용한다면 shadow passwd 파일에서 암호화된 부분을 막아 두어야 한다.  이러한 동작 방식의 시나리오에서는 클라이언트는 항상 nobody 사용자 권한의 웹 서버와 통신을 하기 때문에 이 서버 프로세스를 공격하여 클라이언트가 원하는 작업을 하게 하더라도 이 때의 작업은 nobody 사용자 권한이므로 루트 소유의 파일들 (예 /etc/passwd 등)을 수정하는 등의 작업은 할 수가 없게 된다. 하지만 이것만으로는 /etc/passwd 등의 중요한 시스템 파일에 접근하는 것을 원천적으로 봉쇄하지는 못한다. 즉, 읽기 권한이 부여된 시스템 파일들은 여전히 접근이 가능하기 때문이다. 

      4.8.1.2 웹 서버에 대한 보안의 문제점
     여기서 말하고자 하는 웹 서버의 보안에 관한 문제점은 단순히 각각의 웹 서버에 존재할 수 있는 버그에 의한 보안의 허점을 이야기하는 것이 아니라 웹의 동작 구조에 존재하고 있는 근본적인 보안의 문제점에 대해서 이야기하려고 함을 강조하고 싶다. 

      앞에서 언급한 시나리오, 즉 자식 프로세스의 권한을 루트가 아닌 권한으로
      동작하게 하는 방법을 조금 생각해 보면 여기에 역시 심각한 보안 문제의 소지가
      존재하고 있음을 알 수 있다. 제일 먼저 클라이언트의 요청을 받아 들이는 서버
      데몬은 루트로 실행되기 때문에 이 서버 데몬이 앞 예와 같이 nobody의 사용자
      권한을 가진 새로운 자식 프로세스를 생성시키기까지의 과정은 역시 루트의
      권한으로 실행되고 있으므로 이 과정에서 침입이 일어나게 되는 경우에는 루트의
      권한으로 원하는 일을 처리할 수 있게 되는 위험의 소지를 가지고 있다고 볼 수
      있는 것이다. 비록 이러한 버그가 아직까지 발견되지는 않았다고 하더라도
      이러한 사실을 절대로 간과해서는 안된다. 이제까지의 시스템 침입과 관련된
      버그들의 역사를 보면 이는 쉽게 이해 할 수 있을 것이다. 
      비록 자식 웹 서버 프로세스의 권한이 루트가 아니더라도 이 프로세스는 전체
      파일 시스템을 모두 접근(access)할 수 있기 때문에 문제의 소지를 가지고 있다.
      이것은 웹을 사용함에 있어서 사실상 거의 필요하지 않은 다른 디렉토리나
      파일들(/etc의 여러 시스템 설정 파일들)에 접근 권한을 주게 되는 불필요한
      결과를 초래하고 있다. 이는 보안 관점에서 보면 시스템의 정보를 유출시킬 수
      있는 매우 불필요한 것이며 침입의 발판이 될 수도 있는 요소가 된다. 

      실제로 예전에 이러한 경우로 인해서 문제가 되었던 예를 한번 들어보자.
      일반적으로 패스워드나 그룹 파일은 모두에게 읽기 권한을 주게끔 설정되어
      있어야 한다. 이런 이유로 CGI 프로그램을 이용하여 웹 서버가 있는 머신에
      로긴하지 않고도 패스워드 파일을 가져올 수 있다. 이는 웹 서버 프로그램을
      인스톨했을 때, 디폴트로 cgi-bin에 포함된 CGI 프로그램 중 phf라는
      프로그램으로 인해서 가능하다. phf의 버그는 지금은 널리 알려져 있어서 패치가
      거의 되었으리라고 생각되지만 CGI 프로그램에 대해 이후에도 얼마든지 침입받을
      수 있다는 가능성을 시사해 주는 것이다. 지금 웹 서버의 cgi-bin 디렉토리의
      phf 프로그램을 검사해 보고 이 CGI가 존재한다면 즉시 이를 지워버리거나
      패치를 하기 바란다. 
      
      4.8.2 chroot의 의미와 개요
   chroot는 새로운 루트 디렉토리를 설정하여 실제로 chroot된 프로세스는 이 디렉토리의 상위 디렉토리로는 접근할 수 없고 오직 이 하위의 디렉토리로만 접근할 수 있게 해주는 보안에는 매우 효과적인 시스템 함수이다. 즉 하나의 프로세스를 실행시킬 때 이 프로세스가 접근할 수 있는 영역을 프로세스 생성 시기에 미리 제한시킬 수 있게 해주는 것이다. 잘 살펴 보면 이 함수를 이용하여 만들어진 동명의 chroot라는 명령어도 존재하는데 이는 프롬프트상에서 프로세스를 실행시킬 때도 이러한 작업을 가능하게 해주기 위해서이다. 아직 chroot가 잘 이해가 안된다면 글의 뒷부분의 wrapper 코드를 보면 쉽게 이해 할 수 있으리라고 생각된다. 

      4.8.2.1 장점
   이전에 소개 했던 웹 서버의 문제점을 해결해 주고 있다. 

      chroot된 디렉토리가 웹 서버 프로세스의 루트 디렉토리로 인식되기 때문에
      불필요한 파일이나 디렉토리로의 접근을 제한할 수 있다. 
      앞에서 소개했듯이 루트 권한의 프로세스가 nobody 권한의 자식 프로세스를
      생성시켜서 컨트롤을 넘기기 전에 공격 당하여 루트의 권한으로 작업을 한다고
      하더라도 이러한 작업이 chroot된 디렉토리를 벗어 날 수 없기 때문에 시스템에
      큰 영향을 미치지 못한다. 물론 이는 chroot된 디렉토리 이하에는 시스템을
      침입하는데 사용할만한 파일이나 디렉토리가 없고 단순히 html파일, 그림 파일,
      CGI파일 등이 있을 뿐이기 때문이다. 
      기존의 웹 서버의 경우 사용자들의 홈 페이지들이나 웹 서비스를 하기 위한
      프로그램(웹 BBS, DB와 연동된 웹 서비스의 DB)들이 디스크에 흩어져 있었다.
      이는 물론 기존의 웹 서버나 생성된 자식 프로세스가 디스크의 어디든지 접근할
      수 있었기 때문이다. 그러나 chroot를 이용하여 웹 서비스를 하게 될 경우에는
      하나의 큰 디스크 파티션을 지시하는 디렉토리를 chroot하여 만들기 때문에 모든
      웹 서비스 관련 파일들을 이 디스크 파티션에 모아 두게 된다. 그러면 실제로 웹
      서버는 이 디스크 파티션, 정확하게는 이 디스크 파티션을 지시하는 chroot된
      디렉토리 밖을 못 벗어 나면서 동작했기 때문에 이 디스크만 정기적으로 백업을
      받아 둔다면 시스템이 죽거나 디스크가 망가지더라도 다른 호스트의 빈 디스크에
      백업을 풀어서 즉시 웹 서버를 복구시킬 수 있게 된다. 이때의 복구 시간은
      단순히 백업 데이터를 새로운 디스크에 복사하는 시간만이 소요되게 될 것이다.
      물론 새로이 옮긴 호스트의 DNS entry에 문제가 생긴 호스트의 이름을 alias시켜
      놓으면 기존에 웹 서비스를 이용하던 사람들은 전혀 문제를(호스트가 옮겨지고
      데이터를 저장하고 있던 디스크가 바뀌었다는 사실) 느끼지 못할 것이다. 즉
      투명성(transparency)을 보장할 수 있다는 것이다. 

      만일 이와 같이 하지 않고 웹 자료들이 여러 디스크에 분산되어 있다고 가정하면
      이중 어느 하나의 디스크가 망가지게 되면 이 디스크에 있는 웹 자료만
      복구시키는 문제도 지저분할 뿐만 아니라 시스템이 파괴될 경우에는 더욱 더
      전체 웹 서비스의 복구 시간은 길어질 것이며 관리자들에게 큰 부담을 주게 될
      것이다. 

      4.8.2.2 단점
   chroot를 사용하는 방법은 보안을 위해서는 매우 훌륭한 방법이지만 이 또한 약간의 문제를 내포하고 있는 것이 사실이다. 이를 여기서 간단히 언급하고 넘어가도록 하자.

      설치하기가 까다롭다고 말할 수 있다(물론 노련한 관리자라면 큰 문제는 되지
      않을 것이다). 뒷 부분에서 언급하겠지만 이진 파일들을 bin디렉토리에 가져다
      놓을 때 그냥 시스템에 있는 것을 복사하게 되면 이들은 모두 공유 라이브러리를
      사용하고 있기 때문에 이들이 필요로 하고 있는 모든 라이브러리를 usr/lib에
      복사 할 필요가 있다. 특히 웹에서는 CGI를 이용하고 있기 때문에 이러한 일은
      매우 피곤하다. 그래서 대부분의 경험자들은 이진 파일들은 정적으로 컴파일
      하는 것을 추천하고 있다. 이 경우에는 공유 라이브러리를 사용할 필요가 전혀
      없기 때문에 관리하기가 깔끔하고 편리하다. 물론 웹에서 이용될 모든 이진
      파일들을 정적으로 다시 컴파일해주어야 하므로 초기 설치 시에 좀 시간이
      소요되는 단점이 있다. 뒤에서 보일 예제는 정적으로 컴파일하지 않는 방법을
      소개하고 있다. 
      기존에 이미 웹 서버가 설치 되어 있는 상태에서 chroot를 이용한 서버를 설치할
      경우에는 chroot를 이용하는 장점을 살리기 힘들 수 있다. 하지만 관리자의
      재량에 따라 불가능한 것은 아니다. 이 말은 이미 기존의 웹 서버가 있다면
      개인들이 각각의 홈 디렉토리에 자신의 홈 페이지를 만들어 놓았을 것인데 이 홈
      페이지들이 chroot에서 이용하는 파일 시스템이나 chroot의 tree 바깥에 있을 수
      있다는 것이다. 이에 대한 해결책을 소개하면 다음과 같다. 만일 사용자들의 홈
      페이지가 chroot를 이용하는 tree 바깥에 있지만 같은 파일 시스템 상에 있다면
      하드 링크를 이용해서 해결 할 수 있다(chroot tree이하에서 바깥으로의 소프트
      링크는 동작하지 않는다). 하지만 완전히 다른 파일 시스템에 사용자들의 홈
      페이가 있을 경우에는 loop back 마운트(로컬 파일 시스템에서 다른 로컬 파일
      시스템으로의 마운트)를 이용하여 해결 할 수 있다. loop back 마운트에 대한
      자세한 설명은 생략하도록 하겠다. 

      4.8.2.3 chroot를 이용한 웹 서버 설치 과정

   이제 chroot을 이용하여 새로운 웹 서버 프로그램을 설치하는 방법에 대해 소개해 보도록 하겠다. 아래의 예제는 솔라리스 2.5 머신에서 모든 프로그램은 공유 라이브러리를 이용하게 컴파일하였다는 가정하에서 직접 설치한 과정을 정리하여 본 것이다. 이 과정은 솔라리스 2.5의 경우이므로 모든 운영체제에 적용되는 것은 아니지만 기본적인 과정을 잘 이해한다면 다른 운영체제라도 큰 문제가 되지는 않을 것이라 믿고, 또 발생할 수 있는 사소한 문제들은 관리자의 재량으로 해결할 수 있을 것이라고 생각된다. 

  chroot는 임의의 디렉토리를 새로운 루트 디렉토리로 만드는 것이기 때문에 디스크에 대한 용량이 충분한 디스크를 하나 선정한다. 

            # df -k
            파일시스템           K바이트    사용    가용   용량    설치지점
            /dev/dsk/c0t0d0s0      86879   21416   56783    28%    /
            /dev/dsk/c0t0d0s6     480919  417695   15134    97%    /usr
            /proc                      0       0       0     0%    /proc
            fd                         0       0       0     0%    /dev/fd
            /dev/dsk/c0t1d0s7    1952573  135576 1621747     6%    /WWW
            /dev/dsk/c0t0d0s5     288855  212963   47012    82%    /opt
            /dev/dsk/c0t0d0s7     724031  227921  423710    35%    /usr1
            swap                  409672     224  409448     1%    /tmp

  여기서는 /WWW라는 디렉토리에 chroot를 하기로 하겠다. 먼저 아래와 같은 디렉토리를 만들도록 하자. 

            # pwd
            /WWW
            # ls 
            총 28               2 cgi-bin/       2 etc/           2 logs/
               2 HOME_PAGE/     2 conf/          2 home/          6 src/
               2 bin/           2 dev/           4 icons/         2 usr/

      위의 디렉토리들을 간단히 설명하면 다음과 같다. 

  HOME_PAGE       이 웹 서버에 접근했을 때 기본적으로 찾는 디렉토리로 설정 
  bin                 이진 파일들을 가져다 놓을 디렉토리 
  cgi-bin              CGI 프로그램을 가져다 놓을 디렉토리 
  conf                 httpd의 설정 파일을 가져다 놓을 디렉토리 
  dev                 디바이스 파일을 가져다 놓을 디렉토리 
  etc                  passwd나 group파일을 가져다 놓을 디렉토리 
  home               개인 홈페이지나 웹 서비스 관련 DB등의 자료들을 가져다 놓을 디렉토리 
  icons               아이콘을 놓을 디렉토리 
  logs                 httpd가 만들 로그 파일을 저장할 디렉토리 
  usr                  usr/lib나 usr/tmp를 위한 디렉토리 
  src                  httpd를 컴파일 할 디렉토리 

   자신이 원하는 웹 서버 프로그램을 가져와 /WWW/src 밑에서 컴파일하자. 본인이 사용한 아파치 웹 서버 소스 프로그램은 다음에서 구할 수 있다. 

            http://www.apache.org

   기본적인 설치 과정은 웹 서버를 설치할 때와 동일하지만, 다음의 설치 과정에만 주의하면 된다. 앞에서 만들어진 conf라는 디렉토리에 아래의 파일들을 가져다 놓는다. 

            # ls conf
            총 36                12 httpd.conf      14 srm.conf
               4 access.conf      6 mime.types

  conf밑에 있는 httpd.conf에서는 다음과 같이 해주어야 한다. 

            #ServerRoot /usr/local/etc/httpd
            # for chroot()
            ServerRoot /

  이것 이외의 설정은 기존의 설정과 동일하다. 좀더 자세한 아파치 서버의 기본적인 설정 방법은 월간 Internet 1996년 10월 호를 참고하기 바란다. src에서 컴파일한 httpd를 bin밑으로 옮겨두고 이 httpd가 이용하는 공유 라이브러리들을 실제 /usr/lib에서 /WWW/usr/lib밑에 복사해 둔다. httpd가 사용하는 이진 파일은 ldd라는 명령어로 조사한다. 

            # ldd httpd
                    libsocket.so.1 =>/usr/lib/libsocket.so.1
                    libnsl.so.1 =>   /usr/lib/libnsl.so.1
                    libc.so.1 =>     /usr/lib/libc.so.1
                    libdl.so.1 =>    /usr/lib/libdl.so.1
                    libintl.so.1 =>  /usr/lib/libintl.so.1
                    libw.so.1 =>     /usr/lib/libw.so.1

  이것을 하는 이유는 기존의 라이브러리 파일이 있던 /usr/lib라는 디렉토리는 httpd 데몬에게는 더 이상 보이지 않기 때문이다. 따라서, httpd 데몬에게 루트 디렉토리인 /WWW밑에 새로운 usr/lib을 만들어 필요한 라이브러리들을 복사해 두어야 하는 것이다. etc 밑에는 /etc/passwd, /etc/group, /etc/netconfig를 복사한다. 이 때, 주의해야 할 점은 패스워드 파일의 패스워드 부분을 x로 막아 놓는다.  솔라리스는 shadow passwd를 사용하기 때문에 사실 이렇게 할 필요는 없지만
  이를 이용하지 않은 경우는 패스워드의 암호화된 부분은 반드시 삭제 시켜야 한다. 그리고 불필요한 사용자는 삭제하는 것이 좋다. dev 밑에는 필요한 디바이스 파일을 만들어 놓는다. 솔라리스의 경우에는 다음과 같이 만들 수 있는데 이는 운영체제에 따라서 달라질 수 있는 요소가 가장 크기 때문에 다른 운영체제를 이용하는 경우에는 조심할 필요가 있다. 

            # mknod /www/httpd/dev/ip c 11 3
            # mknod /www/httpd/dev/tcp c 11 42
            # mknod /www/httpd/dev/ticotsord c 105 1
            # mknod /www/httpd/dev/udp c 11 41
            # mknod /www/httpd/dev/zero c 13 12
            # mknod /www/httpd/dev/null 13 2
            # ls
            총 0                0 null           0 ticotsord      0 zero
               0 ip             0 tcp            0 udp

   이렇게 하면 디바이스 파일을 생성할 수 있다. 만약에 major, minor 숫자를 모르는 경우에는 실제 /dev 밑에 있는 파일을 아래와 같이 살펴보면 된다. 

            # ls -lL /dev/zero
               0 crw-rw-rw-   1 root     sys       13, 12  5월  8일  04:48 /dev/zero

   참고로 zero는 동적 로더(dynamic loader)에 의해서 사용되는 것이며 나머지는 네트웍(network)에 사용되는 것이다. CGI 프로그램을 웹 서버가 제공할 지에 대해 결정한 후 CGI 프로그램을 사용자들이 이용할 수 있게 하려면, CGI 프로그램이 사용하는 이진 파일을 조사한 후, CGI 프로그램이 사용하는 이진 파일과 그에 따른 라이브러리를 /WWW/bin, /WWW/usr/lib에 각각 넣어 주여야 한다. 그렇지 않으면 CGI 프로그램에 필요한 이진 파일들(sh, perl등)을 chroot된 새로운 루트 디렉토리에서 찾지 못하게 되므로 CGI 프로그램을 이용할 수 없게 된다. 우선 기본적인 sh과 perl을 컴파일한 후 bin 밑에 넣어 준다. 여기서는 정적으로 컴파일하지 않는 경우이므로 sh와 perl이 이용하는 라이브러리들을 확인하여 usr/lib에 복사하여 둔다.  다음은 기본적으로 넣어 두면 CGI 사용에 유용한 프로그램들이다. 

            cat     comm      cp     csplit       cut  
            du      expand    find   fmt          fold
            grep    head      join   locate       ls
            mkdir   mv        nl     od           paste
            pr      rm        rmdir  sort         split 
            sum     tail      touch  tr           unexpand
            uniq    wc        xargs

   본인의 경우는 bin에 csh, sh, perl, httpd만을 넣어 두었는데 이들이 필요로  하는 라이브러리들은 다음과 같았다. 

            # pwd
            /WWW
            # ls usr
            총 4          2 lib/     2 tmp/
            # ls usr/lib
            총 3322                     2 libmapmalloc.so@      78 libw.so.1*
              48 ld.so*                14 libmapmalloc.so.1*    32 nss_compat.so.1*
             288 ld.so.1*               2 libmp.so@             22 nss_dns.so.1*
               2 libc.so@              32 libmp.so.1*           42 nss_files.so.1*
            1312 libc.so.1*             2 libnsl.so@            48 nss_nis.so.1*
               2 libdl.so@           1136 libnsl.so.1*          58 nss_nisplus.so.1*
               6 libdl.so.1*            2 libsocket.so@          2 straddr.so@
               2 libintl.so@          136 libsocket.so.1*       20 straddr.so.2*
              32 libintl.so.1*          2 libw.so@

  마지막으로 httpd 데몬을 실행시키기 위한 wrapper를 만든다. 다음은 wrapper의 소스 코드이다. 

            #include <stdio.h>

            main(int argc, char *argv[])
            {

            if (chdir(argv[1])) {
                    fprintf(stderr,"change directory to %s failed !",argv[1]);
                    exit(1);
            }

            if (chroot(argv[1])) {
                    fprintf(stderr,"chroot %s failed !",argv[1]);
                    exit(1);
            }

            execl("/bin/httpd","httpd","-f","/conf/httpd.conf",(char *)0);
            exit(0);
            }

   이 프로그램의 의미는 다음에 오는 실행 방법을 보면 확실히 이해 할 수 있을 것이다. 다음의 과정은 /WWW이하 디렉토리와 파일의 소유를 가상의 사용자인 www으로 한다. 물론 www이라는 사용자는 /etc/passwd에 등록되어 있어야 한다. 이것은 nobody를 등록시킨 과정과 동일하게 하면 된다. 

            # grep www /etc/passwd
            www:x:1000:1000:WWW server:/www/httpd:

            # grep webgroup /etc/group
            webgroup::1000:web

            # chown -R www /WWW
            # chgrp -R webgroup /WWW
            # chmod -R 755 /WWW

  이제 wrapper 프로그램 파일을 만들어서 부팅 스크립트에 추가해 주기만 하면  된다. 
 # pwd             /etc/rc3.d             # ls             총 1258                 4 S15nfs.server*  2 S97wrapper*                4 README             2 S98smbd*             # cat S97wrapper              #!/bin/sh             # for httpd wrapper daemon              if [ -f /WWW/bin/httpd_wrapper ]              then                     echo  "start httpd wrapper"                     /WWW/bin/httpd_wrapper                     echo  "/WWW/bin/httpd_wrapper"             fi 
           
      4.8.3 CGI의 취약점과 보안에 대한 개요
   세계는 인터넷 열풍으로 바쁘게 움직이고 있다. 인터넷을 모르면 낙오자가 되는 양, 너도나도 인터넷 대열에 모여들고 있다. 하지만, 발전과 변화의 빠른 속도 만큼이나 취약한 부분도 꾸준히 생겨 나고 있다. 그래서, 웹에 대한 보안를 더욱 신경써야 할 시기가 아닌가 한다. 이 문서에서는 웹 보안에 관련되어 CertAdvisory와 8lgm을 참고로 하여 취약점과 보안을 설명하고 있다. 사용자가 CGI를 사용할 때 사용자가 웹 서버 시스템에 침입하는 효과를 낼 수 있는 취약한 부분과 그에 대한 보안책을 설명하고, 그 중에서 이미 문제가 되었던 예를 제시하고자 한다. 이 내용은 
   1.Interpreters in CGI bin Directories 
   2.Vulnerability in NCSA/Apache CGI example code 

      4.8.3.1 CGI 해석기
    웹을 통해 홈 페이지를 들어가보면 방문 횟수가 나오는 홈 페이지가 있다. 이것은 사용자와 웹 서버가 상호 작용하는 CGI를 통해 가능한 것이다. 이 CGI 스크립트를 수행하기 위해서는 해석기가 웹 서버 시스템에 존재해야 한다. 사용자가 웹을 통해 CGI 스크립트를 실행시키기 위해서 웹 서버는 해석기에 대한 접근 권한이 있어야 한다. 그래서, 초기에는 사용자가 CGI 스크립트를 이용할 수 있다는 것을 확신시켜주기 위해서 CGI bin 디렉토리상에 해석기를 위치시켰다. 그러나, CGI bin디렉토리상에 있는 모든 프로그램들(interpreters)은 임의의 변수(argument)로 실행될 수 있기 때문에 CGI 프로그램이 의도된 목적으로만 실행될 수 있도록 디자인하는 것이 중요하다.

      4.8.3.2 문제점
   따라서 해석기들(/bin/sh 또는 PERL 등등)이 CGI bin 디렉토리에 위치해 있다면 침입자는 해석기를 직접적으로 접근할 수 있고 웹 서버 시스템에서 임의의 명령를 수행할 수 있다. 이 후에 소개되는 내용은 이로 인해서 생겼던 문제이고, 이 문제를 해결하기 위한 몇 가지 방법을 제시하고자 한다. 

      4.8.4 NCSA/Apache CGI 예제 코드의 취약성의 개요
 웹 서버 프로그램을 인스톨 한 다음에 src라는 디레토리를 보면은 util.c라는 파일을 발견할 수 있을 것이다. 그 파일의 함수 중에서 escape_shell_cmd()라는 함수가 취약성을 보유하고 있다. 이 함수는 system(), popen()과 같은 shell-based 라이브러리를 필터링하여 호출하는 역활을 한다. 즉, escape_shell_cmd()에 의존하여 shell-based 라이브러리를 호출하는 프로그램은 공격당하는 취약점을 가질 수 있  

      4.8.4.1 프로그램의 예
   phf라는 CGI 프로그램이 그러한 예이다. 주의해야 할 점은 취약점은 httpd 그 자체에 있는 것이 아니라, escape_shell_cmd()에 의존하는 CGI 프로그램에 있다라는 것이다. 따라서, 취약한 escape_shell_cmd()를 사용하는 프로그램은 모두 구멍이 있을 수 있다는 생각을 가져야 한다. 따라서, escape_shell_cmd()를 적절히 고쳐주면 된다. 

      4.8.4.2 문제점
   phf 프로그램이 있는 웹 서버에서는 일반 사용자가 /etc/passwd를 볼 수 있는 능력이 있고 시스템상에서 다른 상호적인 쉘(shell) 명령어를 실행할 수 있는 가능성이 있다는 점이다. 많은 CGI 프로그램에서 util.c을 파일 시스템과 연결하는 방법으로 사용한다. 특히 escape_shell_cmd()은 CGI 프로그램에 의해 발생된 쉘(shell)이 추가의 명령을 가지고 명령어를 실행할 수 있게 하는 제어 문자(control characters)을 필터링한다. 

      /* In util.c */

      void escape_shell_cmd(char *cmd) {
             register int x,y,l;
             l=strlen(cmd);
             for(x=0;cmd[x];x++) {
                    if(ind("&;`'\"|*?~<>^()[]{}$\\",cmd[x]) != -1){
                    /*the line above is the filter for control chars*/
                           for(y=l+1;y>x;y--)
                           cmd[y] = cmd[y-1];
                           l++; /* length has been increased */
                           cmd[x] = '\\';
                           x++; /* skip the character */
                    }
             }
      }

위의 소스 코드를 살펴 보면 , 대부분의 제어 문자(control characters)을 필터링시키는 데에 비해 `n'만이 필터링되지 않는다. 이런 이유로 구멍이 생기게되었다. 다음의 첫 번째는 웹 상에서 사용되고 있는 일반적인 phf 질문의 형태이다. 이것을 통해서 아이디와 실명을 등록하는 것이다. 하지만, 두 번째는 첫 번째와는 다른 형태이다. 자세히 살펴보면 이것은 /etc/passwd을 보여주는(cat) 질문 형태임을 알 수 있다. 의미하며 일반적인 phf 질문의 형태 속에 패스워드 파일을 보여주는 명령이삽입되어 있음을 쉽게 발견된다. 
http://aaa.bb/cgi-bin/phf?Pserver=xxx.xx.xx.xx&Qalias=morphy &name=ChrisTerry
http://aaa.bb/cgi-bin/phf?Jserver=xxx.xx.xx.xx%0Acat%20/etc/passwd%0A&Qalias=&Qname=foo

      4.8.4.3 침입 과정

   1.누군가 당신의 호스트를 목표로 정한다. 
   2.phf의 버전이 불안전한지를 본다. 즉,`n'이 필터링이 안 되는지를 확인한다. 
   3.위의 질문 방법으로 /etc/passwd을 가져오거나, 셀을 실행시킨다. 
   4.이 과정은 물론 httpd 로그에 남는다. 

      4.8.4.4  해결책
  C 라이브러리 함수(system()과 popen() 등등)을 사용하지 않는다. CGI 프로그램을 제거한다. 즉, escape_shell_cmd() 함수를 사용하는 CGI 프로그램을 이용할 수 없게 한다. 이것은 프로그램에서 실행 권한을 제거하거나, 프로그램 그 자체를 제거한다. 특별히, phf가 설치되어 있는 사이트나 필요하지 않은 사이트는 그것을 이용할 수 없게 한다. CGI 프로그램을 다시 쓴다. escape_shell_cmd()의 의도는 shell meta-characters를 부르기 쉬운 함수에 대해서 shell meta-characters를  필터링하여 호출하는 역활을 한다. 따라서, 좀 더 안전한 방법은 이러한 라이브러리 함수의 사용을 피하는 것이다. 이미 shell-based 라이브러리 함수(system() , popen())을 사용하는 CGI 프로그램을 사용하고 있는 사이트는 이러한 프로그램을 다시 써야 한다. 패치된 util.c을 가지고 CGI 프로그램(cgi-bin 에 있는 모든 프로그램)을 다시 컴파일한다. 

      단순한 패치 방법 
      1)  if(ind("&;`'\"|*?~<>^()[]{}$\\",cmd[x]) != -1){
      2)  if(ind("&;`'\"|*?~<>^()[]{}$\\\n",cmd[x]) != -1){

  util.c의 escape_shell_cmd()의 내용을 1)에서 2)로 바꾸면 된다. 그리고, 소스 프로그램을 다시 make를 실행시키면 된다. 

  4.9 칩입자의 발견시에 관리자의 임무

     4.9.1 침입을 받고 있을 때나 받은 후에 해야할 것들.
    이제 침입을 감지했을 때에 대비한 몇 가지 조언을 하고자 한다. 첫 번째 할 일은 냉정을 유지하는 것이다. 성급한 행동은 공격자가 저지를 수 있는 것보다 더 큰 해를 끼칠 수 있다.

     4.9.1.1 진행 중인 보안 공격.
    진행 중인 보안 공격을 알아차리는 것은 긴장되는 일일 수 있다. 당신이 어떻게 대응하는가에 따라 중요한 결과를 가져올 수 있다. 공격이 물리적인 것이라면, 당신이 알아차린 이상은 누군가 당신의 집이나 사무실, 연구실에 침입했다는 사실일 것이다. 당신은 지역 책임자에게 알려야 한다.
연구실에서라면 누군가 케이스를 열려 했거나 컴퓨터를 재부팅하려고 했다는 것을 알아차렸을 것이다. 당신의 권한과 절차에 따라, 당신은 그들에게 중지하도록 요구하거나 지역 보안 책임자에게 연락할 수 있다. 지역 사용자가 보안을 훼손하고자 하는 것을 감지했을 경우, 가장 먼저 해야 할 일은 그 사용자가 실제 본인인지 확인하는 것이다. 그 사용자가 어디에서 로그인하려고 하고 있는지 확인해 보도록 하라. 그 곳이 평상시에 로그인해 들어오는 곳인가? 그렇지 않은가? 다음에는 컴퓨터를 통하지 않은 직접적인 연락을 취해보도록 하라. 예를 들어 전화를 걸거나 그 사용자의 집 혹은 사무실로 직접 가서 이야기를 나눌 수있다. 만일 그 사용자가 자기의 행위를 시인한다면, 당신은 그의 행위에 대해서 설명하도록 요구할 수 있고 그런 행위를 중지하라고 말할 수도 있다. 그가 부인하고, 당신이 말하는 사건에 대해서 모른다면 좀 더 조사를 해야 한다. 비슷한 사건들을
알아보고 어떤 고발이나 비난 이전에 많은 정보를 확보하도록 하라.
    네트웍을 통한 침투를 감지했다면, 처음 할 일은 (당신이 할 수 있다면) 네트웍 연결을 끊는 것이다. 침입자가 모뎀으로 접속했다면 모뎀 선을 뽑아버리도록 하고, 이더넷을 통해 접속했다면 이더넷 선을 뽑아라. 이렇게 하면 침입자가 더 큰 피해를 입히는 것을 막을 수 있고, 침입자는 아마 자신이 들통났다고 생각하기보다는 네트웍에 문제가 생긴 모양이라고 여길 것이다.
    당신이 네트웍 연결을 끊을 수 없다면 (접속이 빈번한 사이트이거나, 컴퓨터에 대한 물리적 관리권한이 없다면), 차선책은 침입자의 사이트로부터 접속해 들어오는 것을 막기 위해 tcp_wrapper나 ipfwadm 같은 프로그램을 사용하는 것이다.
    침입자의 사이트에서 들어오는 모든 사람들의 접근을 거부할 수 없다면, 사용자들의 계정을 폐쇄하여야 한다. 하나의 계정을 폐쇄하는 것은 쉬운 일이 아니라는 점에 주의하라. 당신은 .rhosts 파일과 FTP를 통한 접근, 호스트 상의 뒷문(backdoor)을 염두에 두어야 한다.
    위의 조치들 (네트웍 절단, 공격자의 사이트로부터 오는 접근 시도 거부, 그리고/혹은 그들의 계정 폐쇄) 가운데 한 가지를 하고 나면, 공격자의 모든 사용자 프로세스를 죽이고 그들을 로그 오프 시켜야 한다.
    공격자는 다시 들어오려고 시도할 것이므로, 다음 몇 분 동안은 당신의 사이트를 자세히 감시해야 한다. 공격자는 아마도 다른 계정을 쓸 것이고, 다른 네트웍 주소를 쓸 수도 있다.

       4.9.2 이미 일어난 보안 훼손.
    당신은 이미 일어난 사고를 뒤늦게 알아차렸을 수도 있고 제때 감지하고 (바라기로는)공격자를 당신의 시스템에서 몰아냈을 수도 있다. 이제는 무엇을 해야 할까?

       4.9.2.1  구멍 막기
   공격자가 당신의 시스템에 들어오기 위해 사용한 방법이 무엇인지 알 수 있다면, 그 구멍을 막도록 해야 한다. 예를 들어 공격자가 로그인 한 다음에 FTP 사용사항들이 여러 개 생긴 것을 발견할 수 있다. 이 때에는 FTP 서비스를 중지하고 개정 버전이나 알려진 교정 사항 목록이 있는지 찾아봐야 한다. 기록(log) 파일들을 확인하고, 자주 찾는 보안 사이트에 가서 당신이 고칠 수 있는
새롭고 흔한 사례가 있는지 목록을 살펴보도록 하라.
   공격자를 완전히 차단하지 않았다면, 그는 대개 다시 돌아온다. 당신의 컴퓨터로 바로 돌아오지는 않을지라도, 당신의 lan 안의 어딘 가로 말이다. 공격자가 패킷 스니퍼를 작동시키고 있었다면, 그는 지역 내의 다른 컴퓨터로 접근할 수 있다.

      4.9.2.2 피해 평가
   첫 번째 할 일은 피해를 평가하는 것이다. 무엇이 훼손되었는가? Tripwire 같은 완전성 검사 프로그램을 사용하고 있다면, tripwire를 실행시켜서 알아볼 수 있다. 이런 프로그램이 없다면, 모든 중요한 자료들을 일일이 살펴보아야 한다. 리눅스 시스템이 갈수록 설치하기 쉬워지고 있으므로, 설정 파일들을 저장해 두고 디스크를 지워버린 다음 리눅스를 다시 설치한 뒤 백업으로부터 사용자 파일과 설정 파일들을 복구하는 것을 고려해 볼 수도 있다. 이렇게 하면 깨끗한 시스템을 새로 갖게 된다.

      4.9.2.3 백업, 백업, 백업!

    정기적으로 백업을 해두는 습관은 보안 문제에 있어서는 신의 선물이다. 당신의 시스템이 망가졌을 때, 백업된 것으로부터 당신이 원하는 자료를 복구할 수 있다. 물론 공격자에게도 가치 있는 자료는 훔쳐가서 자기의 사본을 만들어 둔 다음에 파괴하겠지만, 최소한 당신은 자료를 도난 당할지언정 잃지는 않는다. 변조된 파일을 백업된 것으로 복구하기 전에, 이전의 여러 백업본들을 확인해 보아야 한다. 침입자가 파일을 오래 전에 망쳐놓았다면, 엉터리 파일들만 잔뜩 백업해 놓았을 수도 있기 때문이다. 물론 백업본들에 대해서도 보안 문제가 있다. 백업본들을 안전한 장소에 두었는지 확인하여야 하고, 누가 거기 접근할 수 있는지 알고 있어야 한다. (공격자가 백업본을 얻을 수 있다면, 당신이 모르는 사이에 당신의 모든 자료에 접근할 수 있게 되는 것이다.)

      4.9.2.4 침입자 추적
   침입자를 몰아내고, 시스템을 복구했다고 해서 모든 일이 끝난 것은 아니다. 대개 침입자들은 잡히지 않지만, 그래도 공격 사건을 보고해야 한다. 당신은 공격자가 당신 시스템을 공격했던 사이트의 관리자에게 그 사건을 알려주어야 한다. 연락처는 "whois"나 internic 데이터베이스를 이용해서 찾아볼 수 있다. 모든 적절한 기록 사항과 날짜 및 시간을 첨부해서 저쪽 관리자에게 email을 보내는 것이 좋다. 침입자에 대해서 어떤 특이한 점을 발견했다면 그것도 함께 알려주도록 하라. email을 보낸 뒤에 (하고 싶다면) 전화를 하도록 하라. 저쪽 관리자가 다시 그 공격자를 찾아냈다면, 그 관리자가 다시 공격자가 들어온 사이트의 관리자에게 말하고 뭐 그렇다.
    뛰어난 해커는 대개 많은 중간 시스템들을 사용한다. 이 시스템들 중의 어떤 (혹은 많은) 곳에서는 침입 당했다는 사실조차 모를 수도 있다. 크래커의 원래 시스템까지 쫓아가는 것은 어려운 일이다. 당신이 이야기하게 되는 관리자들에게 공손하게 대하는 것은 그들로부터 도움을 얻어내는데 좋다.
    당신이 가입한 (cert나 이와 비슷한) 모든 보안 조직들에도 알려주어야 한다.

  4.10 보안 관련 자료 및 기타 인터넷 주소록
   유닉스 보안 일반에 대한 혹은 특별히 리눅스 보안에 대한 훌륭한 사이트들이 정말 많이 있다. 하나 이상의 보안 관련 메일링 리스트에 가입해서 최신의 보안 수정사항들을 따라가는 것은 매우 중요하다. 이런 리스트들은 대개 매우 분량이 적으면서도 유익하다.

     4.9.1 FTP 사이트들
  ♠CERT는 컴퓨터 응급 대응 팀(Computer Emergency Response Team)의 약자다. 이들은 종종 최근의 공격 사건과 수정사항들에 대한 경보를 보내곤 한다. cert.org Replay는 많은 보안 프로그램들을 저장하고 있다. Replay는 미국 안에 있지 않기 때문에 미국의 어리석은 암호 제한에 따를 필요가 없다. replay.com
  ♠Matt Blaze는 CFS의 저자이며 탁월한 보안 전문가이다. Matt Blaze's stuff
  ♠Sorosis는 리눅스 PAM 사이트의 고향이다. 여기에는 PAM에 대한 많은 정보와 모듈들이
있다. Linux PAM ftp site 
  ♠tue.nl은 네덜란드에 있는 훌륭한 보안 관련 ftp 사이트이다. ftp.win.tue.nl

    4.9.2 The Hacker FAQ 

  ♠COAST 자료실에는 매우 많은 유닉스 보안 프로그램들과 정보들이 있다. COAST
  ♠Rootshell.com은 크래커들이 요즘 쓰는 침투방법에 대해 알아보기에 좋은 사이트이다.
    rootshell.com exploits 
  ♠BUGTRAQ은 보안 관련 문제에 대한 상황보고를 발표한다. BUGTRAQ archives 
  ♠컴퓨터 응급 대응 팀, CERT는 유닉스 시스템에 대해 흔히 가해지는 공격을 보고한다.
    CERT home (http://www.cert.org)
  ♠Dan Farmer는 SATAN과 많은 다른 보안 도구들의 저자이며, 그의 홈사이트에는 보안 도구들 뿐 아니라 보안에 대한 흥미로운 개괄 글들도 있다. Dan Farmers trouble.org 
  ♠리눅스 보안 WWW는 리눅스 시스템의 보안에 대한 좋은 자료원이다. Linux Security
WWW
  ♠Reptile의 개인 사이트에는 리눅스 보안에 관한 좋은 정보들이 많이 있다. Reptiles Linux Security Page 
  ♠Infilsec에는 어떤 취약점이 특정한 플랫폼에 영향을 주는지 알려주는 취약점 엔진(vulnerability engine)이 있다. Infilsec vunerability engine 
  ♠CIAC는 흔한 침입 사건들에 대해 정기적인 보안 보고서들을 보내준다. CIAC bulitins 

    4.9.3 메일링 리스트들
  ♠Bugtraq: bugtraq를 구독하려면, 본문에 subscribe bugtraq라고 써서
    listserv@netspace.org로 email을 보내면 된다.
  ♠CIAC: 본문에 (제목에 말고) subscribe ciac-bulletin라고 써서
    majordomo@tholia.llnl.gov에 e-mail을 보내라.

    4.9.4 책들 - 인쇄된 읽을거리.
  좋은 보안 관련 서적들이 많이 있다. 이 절에서는 이런 책들 가운데 조금만 나열하고자 한다. 보안을 전문적으로 다룬 책들 뿐 아니라, 시스템 관리에 대한 많은 책들이 보안에 대해서 다루고 있다.

Building Internet Firewalls By D. Brent Chapman & Elizabeth D. Zwicky
1st Edition September 1995
ISBN: 1-56592-124-0

Practical UNIX & Internet Security, 2nd Edition By Simson Garfinkel & Gene
Spafford
2nd Edition April 1996
ISBN: 1-56592-148-8

Computer Security Basics By Deborah Russell & G.T. Gangemi, Sr.
1st Edition July 1991
ISBN: 0-937175-71-4

Linux Network Administrator's Guide By Olaf Kirch
1st Edition January 1995
ISBN: 1-56592-087-2

PGP: Pretty Good Privacy By Simson Garfinkel
1st Edition December 1994
ISBN: 1-56592-098-8

Computer Crime A Crimefighter's Handbook By David Icove, Karl Seger & William
VonStorch (Consulting Editor Eugene H. Spafford) 
1st Edition August 1995
ISBN: 1-56592-086-4

■ 리눅스에서의 한글 구현
	- 개요 : 기존의 libc5 라이브러리 하에서의 XFree86 한글 설정은 국제화된 버전으로써, 한글 입·출력에 큰 문제가 없었으나, libc6(glibc2)하에서의 한글 입·출력은 XFree86의 국제화된(i18) 버전을 포함하지 못하는 상황이다. 아직은 알파버전으로써 안정되지 못한 libc6(glibc2) 라이브러리의 문제로써 아직 XFree86(X)에서의 i18 은 아직 이루어지기 힘든 상황이다. 현재 (1998년 이후) 한글 패치 된 리눅스의 설정은 기존의 XFree86 에 i18된 패치버전을 가지고 패치를 가한 것이며, 불안정한 상태이다. 2바이트 권에 속하는 우리는 한글 사용이 필수이다. 이 글은 영문 리눅스 상태에서의 한글 구현에 대해서 설명한 것이다. 그럼, 리눅스에서의 기본적으로 필요한 한글 구현에 대하여 알아보자.

	< 리눅스에서의 기본적인 한글 설정 >
	영문 리눅스에서의 한글 출력은 한글 폰트를 설치하면 출력에는 문제가 없다. 하지만, 한글을 입력하기 위해서는 한글로케일이 설정되어야만 한다. 우리는 가장 기본적인 한글 입·출력에 대하여 알아보기로 하자. 리눅스를 설치하고 나서 제일 먼저 우리는 root 권한으로써 리눅스를 제일 먼저 만나게 될 것이다.
	한글 환경에 있어서 제일 중요한 문제는 바로 LANG 문제인데, 이 LANG(locale) 설정을 먼저 알아보자.

==================< LANG (locale) 설정 >=========================  
if [ -z "$LANG" ] && [ ! `tty |grep -c 'tty[0-9]'` -eq 1 ]; then
	export LANG=ko
fi

if [ -z "$LESSCHARSET" ]; then
	export LESSCHARSET=latin1
fi
================================================================

	다음 상황을 홈 디렉토리의 .bash_profile 에 적어준다.
(설명) X에서는 한텀을 이용해서 한글을 볼수도 있고, 만약 유저가 한글 패치된 XFree86 을 설치하였다면 한글구현이 가능해진다. 그러나, 콘솔에서는 han이라는 프로그램을 실행하지 않는 한 한글은 보이지 않는다. 이런 경우를 생각해서 X 에서는 기본값을 LANG=ko 로 설정을 하고, 콘솔에서는 기본값을 LANG=C 로 설정하는데, 만약 유저가 han 을 실행하게 된다면 LANG=ko 로 바뀌도록 하는 스크립트이다. 리눅스나 유닉스에서는 터미널 장치를 tty1~12 까지 이런식으로 사용을 하게 되는데, 한텀이나 han, telnet, ftp 등을 사용하게 된다면 ttyp1 이런식으로 명칭을 부여받고 일을 시작하게 된다. 즉, tty 명령을 실행해서 표준출력으로 나오게 되는 프로그램들 중에서 tty0-9 까지의 일련번호가 있는지 확인해보고 없으면 LANG=ko 로 설정하고 있으면 LANG=C 로 설정하게 되는 방법이다.
	bash 의 모든 설정을 읽어들이게 하기 위해서는 다음과 같은 명령을 내려준다.

# source .bash_profile

이러면 root 사용자의 한글 입·출력의 기본설정은 끝나게된다.

	< 기본적인 한글사용을 위한 한텀 설치 >
	각 해당 통신망의 자료실이나 FTP 사이트로부터 한텀의 바이너리 파일 또는  소스 파일들을 구해야한다. 대개 소스 형태로 압축이 되어 배포가 되지만 만일 자신의 시스템에 맞도록 미리 컴파일 되어 압축이 되어있는 바이너리 파일인 경우에 슬랙웨어인 경우에는 pkgtool을 이용하여 설치를 할 수 있고, 레드햇인 경우에는 rpm을 구해서 설치를 할 수 있고, 데비안의 경우에는 deb을 구해서 설치를 할 수 있다. 만약, 한텀 소스를 구하였다면 직접 자신의 시스템에서 컴파일 하여 사용하여야 한다.

=================< 한글 터미널(한텀) 사이트 >=====================
1. source: http://pseudo.snu.ac.kr/~hwang/
2. rpm: ftp://ftp.kreonet.re.kr/pub/hangul/linux/AlzzaLinux
3. deb: ftp://ftp.kreonet.re.kr/pub/hangul/linux/Debian-KR
================================================================

설치는 다음과 같은 절차로 진행된다.
# tar xvfz hanterm-xf-p15.tar.gz 하면 압축이 풀리면서 한텀 소스코드가
                                   들어있는 디렉토리가 생성된다.
# cd <한텀 소스 디렉토리> 하여 디렉토리를 이동한 후,
# xmkmf 하여 imagefile을 makefile로 변환한다.
# make 하여 컴파일을 한다.

이렇게 컴파일이 성공적으로 수행되면 hanterm이란 실행파일이 생성된다.
   
# cp hanterm /usr/X11R6/bin 복사를 한다.
# cp Hanterm.ad /usr/X11R6/lib/X11/app-defaults/Hanterm : Hanterm.ad 
                            라는 파일을 Hanterm이라는 파일로 복사를 한다.
   
=================<한텀에 필요한 폰트 구하는곳 >===================
* ftp.kornet.nm.kr: ftp://ftp.kornet.nm.kr/pub/Hangul/fonts/    
================================================================
	☞ 기본적인 한텀에 필요한 폰트는..? : hanyang-font-pcf.tar.gz, iyagi.pcf.Z, iyagi16.pcf.Z, johabg16 - johabsm16.pcf.Z

# dir *.bdf를 하면 총 11개의 폰트파일이 나오는데 이 파일들을 .pcf 포맷으로 바꾸어주는 작업을 하면 된다. 예를 들어, iyagi16.bdf 파일을 변환하는 방법은,
# bdftopcf iyagi16.bdf > iyagi16.pcf
	총 11개의 폰트파일에 대하여 똑같은 방식으로 작업을 하면 된다.
	작업 종료 후 *.pcf 파일이 정확히 생성되었는지 확인을 마친 후,
# cp *.pcf /usr/X11R6/lib/X11/fonts/misc
# mkfontdir /usr/X11R6/lib/X11/fonts/misc
# xset fp rehash /usr/X11R6/lib/X11/fonts/misc
	즉, 한텀의 x-window 폰트 파일 을 x-window의 해당디렉토리로
	복사하고, 해당디렉토리의 폰트 파일들에 대한 인덱스를 생성하는
	것으로 작업은 끝난다.

	< 넷스케이프에서의 한글 입·출력 구현 >
	리눅스에서의 웹 서핑을 하기 위해서 사용자들은 넷스케이프를 주로 많이 이용하게 된다. 물론, lynx 라는 텍스트 브라우저를 이용하여 빠른 웹 서핑을 하지만, 요즘 대부분의 홈페이지를 가더라도 이미지 없는 홈페이지는 거의 없다. lynx 를 이용한 웹 서핑은 어느 정도 한계가 있다. 그래서, 넷스케이프를 많이 이용하는데 리눅스용 한글 넷스케이프는 실제적으로 없는 상태이다. 한글 패치를 한 넷스케이프가 있더라도 순수 한글 넷스케이프는 없기 때문에, 한글 쓰는 리눅스 유저들은 넷스케이프에서의 한글 입·출력에 많은 관심이 가게 된다. 여기서는 한글 패치가 된 넷스케이프가 아닌 순수 영문 상태의 넷스케이프를 가지고 한글 입·출력이 가능하도록 보여주기 위함이다.
	먼저, 넷스케이프가 설치가 되어있다고 가정 하에 설명이 들어갑니다.

=================<Netscape를 구할수 있는곳 >====================
     ftp.netscape.com: ftp://ftp.netscape.com/
===============================================================

먼저, 넷스케이프를 소스를 받고 나서 다음과 같은 파일을 만든다.

=========================<locale.c >============================
#include <locale.h>
#include <X11/Intrinsic.h>

char *_Xsetlocale (int, const char *);

#undef setlocale
char *setlocale (int c, const char *l) {
	if ((c == LC_ALL || c == LC_CTYPE) && l != NULL
	&& !(*l == 'C' && l[1] == '\0')) {
		XtSetLanguageProc(NULL, NULL, NULL);
		l = NULL;
	}
	return _Xsetlocale(((c == LC_ALL || c == LC_CTYPE) ? 2 : 3), l);
}
===============================================================

이 파일을 다음과 같은 형식으로 컴파일을 한다.

# gcc -fPIC -shared -Wl,-rpath=/usr/X11R6/lib,-soname,liblocale.so \
       -o liblocale.so locale.c -L/usr/X11R6/lib -lX11 -lXt
      
그러면, liblocale.so 라는 라이브러리가 만들어진다.
그리고 나서, /usr/X11R6/lib/X11/locale에 ko라는 디렉토리를 만든후에

다음과 같은 사항을 적어준다.

====================<XLC_LOCALE >===========================
XLC_FONTSET
# fs0 class (7 bit ASCII)
fs0 {
	charset {
		name    ISO8859-1:GL
	}
	font {
		primary         ISO8859-1:GL
		vertical_rotate all
	}
}

# fs1 class
fs1 {
	charset {
		name    KSC5601.1987-0:GL
	}
	font {
		primary KSC5601.1987-0:GL
		substitute KSC5601.1987-1:GR
	}
}
END XLC_FONTSET
   
XLC_XLOCALE
encoding_name           ko.euc
mb_cur_max              2
state_depend_encoding   False
wc_encoding_mask        \x30000000
wc_shift_bits           7

# cs0 class
cs0 {
	side            GL:Default
	length          1
	wc_encoding     \x00000000
	ct_encoding     ISO8859-1:GL

}

# cs1 class
cs1 {
	side            GR:Default
	length          2
	wc_encoding     \x30000000
	ct_encoding     KSC5601.1987-0:GL; KSC5601.1987-0:GR
}
END XLC_XLOCALE 
==============================================================

다음과 같은 넷스케이프 실행 파일을 만든후에 liblocale.so 라이브러리를 똑
같은 경로로 복사를 해주면 넷스케이프에서의 한글 입.출력이 된다.

=======================< netscape2 >===========================
#!/bin/sh
NS_EXE=/usr/lib/netscape/netscape
NS_LIB=/usr/lib/netscape
LD_PRELOAD="/usr/lib/netscape/liblocale.so:/lib/libc.so.5.3.12"
export LD_PRELOAD

## exec $NS_EXE $* >/tmp/netscape.log1 2>/tmp/netscape.log2 &
exec $NS_EXE $*
===============================================================

이 화일을 path 가 걸린 /usr/X11R6/bin 에 복사하고 나서 사용을 하면 된다.

	< 넷스케이프에서의 한글 입력기 설치 >
	* hanIM의 설치
	hanIM 의 설치에 필요한 파일들 : xfntmizi-1.1-1.noarch.rpm
					   hanIM-0.9-1.i386.rpm
먼저, 폰트를 설치한다.

# rpm -ivh xfntmizi-1.1-1.noarch.rpm
# rpm -ivh hanIM-0.9-1.i386.rpm

그리고 나서, /usr/X11R6/lib/X11/fonts/misc로 이동해서 폰트 정보를 만든다.

# cd /usr/X11R6/lib/X11/fonts/misc
# mkfontdir
# xset fp rehash

라고 명령어를 실행시키면, 폰트 정보가 만들어진다. 먼저, 만들었던 넷스케이프에서의 한글 라이브러리와 hanIM, kims는 동일한 locale.so로 입력 로케일을 지원하므로 먼저 넷스케이프를 실행시키기 전에 hanIM을 실행시키면, 한글 입력이 지원된다.

	* kims의 설치
	kims에 필요한 파일 : kims.1.0a-971009.tar.gz

먼저, kims 을 받아와서 압축을 풀자. root 디렉토리에 압축을 푼다고 가정하에 설치를 해보겠다.

# tar xvfz kims.1.0a-971009.tar.gz
# cd usr/X11R6/lib/X11/fonts/misc

하면, 필요한 3개의 폰트가 있다. 
3개의 폰트를 /usr/X11R6/lib/X11/fonts/misc 에 복사를 하자.

# cp *.gz /usr/X11R6/lib/X11/fonts/misc
# mkfontdir /usr/X11R6/lib/X11/fonts/misc
# xset fp rehash /usr/X11R6/lib/X11/fonts/misc

이렇게 하면 kims 에 필요한 폰트를 설치를 하였다.

# cd /root/usr/X11R6/lib/X11/app-defaults 하면 CHterm이라는 kims에서 사용하는 한글 칼라 터미널의 설정 파일이 있다.
이것을 /usr/X11R6/lib/X11/app-defaults 에 복사를 한다.

# cp CHterm /usr/X11R6/lib/X11/app-defaults 

그리고 나서, /root/usr/X11R6/bin 으로 가면 kims 와 chterm 이라는 실행파일 두개가 있다. 이것을 /usr/X11R6/bin 에 복사를 해보자.

# cd /root/usr/X11R6/bin
# cp kims chterm /usr/X11R6/bin

그리고 나서, /root/usr/local/lib 디렉토리로 가면 kims에 필요한 한자사전이 있다.(디렉토리를 통째로 복사한다)

# cd /root/usr/local/lib
# cp -r dic /usr/local/lib

그러면 일단 kims의 설치는 마무리 된다. 다음은 설정으로 들어가보도록 하자.
다음 사항을 홈 디렉토리에 있는 .bash_profile에 기입한다.

=========================<.bash_profile >========================
export LANG=ko
export XMODIFIERS="@im=kims"
===============================================================

저장하고 나서, source .bash_profile이라는 명령으로 설정을 읽어 들이게끔 해준다.
그리고, kims의 압축을 푼 디렉토리에 보면은 .Xdefults_kims라는 파일이 있는데 그 내용을 홈 디렉토리에 있는 .Xdefaults에 적어준다.

다음은 저자의 kims에 대한 .Xdefaults의 내용이다.

========================< .Xdefaults >==========================
kims.hangulEnglishToggle: Shift_space
kims.hanja: Meta_g
kims.hanjaBack: Meta_e
kims.hanjaWindowPopup: Meta_c
kims.special: Control_p
kims.fontSet:\
-schumacher-clean-bold-r-normal--16-160-75-75-c-80-iso8859-1,\
-kaist-myeongjo-bold-r-normal--16-160-75-75-c-160-ksc5601.1987-1
kims.foreground: black
kims.background: white
!!
!!chterm
!!
CHterm*Title: 한글 입력 터미날 
CHterm*scrollBar: on
CHterm*foreground: black
CHterm*background: white
CHterm*jumpScroll: on
CHterm*saveLines: 1000
CHterm*fontSet:\
-schumacher-clean-bold-r-normal--16-160-75-75-c-80-iso8859-1,\
-kaist-myeongjo-bold-r-normal--16-160-75-75-c-160-ksc5601.1987-1

Netscape*international: true
Netscape*inputMethod: kims
Netscape*preeditType: Root
==============================================================

이러한 내용을 자신의 홈디렉토리에 있는 .Xdefaults 에 적어주고 나서

# xrdb -load .Xdefaults라는 명령으로 설정을 읽어들이게 하면 다음 실행부터 적용이 된다.

* 주의사항 : 넷스케이프에서 한글 입력기를 통해 한글을 입력 하려면 먼저, kims 나 hanIM 같은 한글 입력기를 먼저 실행시킨 후 넷스케이프를 실행시키면 된다.

* 참고사항 : kims 나 hanIM 에 대한 자세한 정보는 다음의 홈페이지를 참고한다.
@ kims :  http://members.iworld.net/bumchul/kims.html
@ hanIM : http://www.mizi.co.kr/hanIM/hanIM-right.htm

	< 한글 글씨가 깨지는 경우 >
	Linux의 터미널 모드에서 한글모드로 전환 후 한글이 깨지는 것을 해결하는 방법은 다음과 같이 몇가지가 있다. 이러한 경우는 간혹 LINUX에서 터미널모드를 쓸 경우, 한글모드로 전환 후에 한글을 쳐보면 이상하게 깨질 경우가 있는데 이럴 때는 STTY명령을 통하여 8비트의 EUC코드가 입출력되도록 설정해 주는 방법이 있다.

# stty cs8 -parenb -istrip 또는
# stty pass8

을 설정해주면 된다. 또 하나는 바로 한글환경설정을 해 주는 방법이다.

bash 사용자 : # vi /etc/profile 하면
--------------------------------------------------------------
export LESSCHARSET=latin1
export LANG=ko
--------------------------------------------------------------
를 삽입한다.
물론 자신의 홈디렉토리에 있는 .bashrc에 앞의 내용을 삽입하여도 상관없다.

csh 사용자 : 자신의 홈디렉토리에 있는 .cshrc 를 편집한다.
# vi .cshrc 하면
 -------------------------------------------------------------
setenv LANG ko
setenv LC_TYPe iso_8859_1
setenv LESSCHARSET latin1
stty cs8 -istrip -parenb
--------------------------------------------------------------
를 삽입한다.

	< Han 설치 및 사용상 주의사항 >
	han2는 리눅스 콘솔이나 유닉스 상의 콘솔에서 한글을 출력하기 위한 도구이다. SVGA 모드를 사용하며 비디오 카드에 따른 특성을 타는 경향이 있다.
S3 virge, S3 Trio64V+, TGUI 9680, Milenium I, Cyber 9683(ThinkPad)
이상의 비디오 카드에서 문제 없이 돌아간다. 설치과정은 다음과 같다.

# tar xvfz han2-0.3.7.tar.gz
# cd han2-0.3.7H
# make config
# make 
# make install : han 이라는 실행 파일이 생성된다.

폰트는 /usr/share/fonts에 위치하며, 8x16pc.bdf.gz(영문폰트), h16m.bdf.gz(한글폰트)를 사용하고 있다.

minix-zcat:Startup
gzip -d < /usr/local/share/fonts/han/h16m.bdf.Z | /usr/local/bin/hanfld
gzip -d < /usr/local/share/fonts/han/8x16pc.bdf.Z | /usr/local/bin/hanfl
* Startup 이 붙어있는것이 현재 읽어들이는 폰트 부분이다.

han 의 설정 파일은 /etc/han.cfg 에 있다.
한글 자판 :	2벌식   사용자라면                 HangulKeyboard: 2
		3벌식   사용자라면                 HangulKeyboard: 3
한/영 전환 : han에서 한/영 전환을 shift+space로 하려면 /etc/han.cfg와 keymap의 설정을 수정하면 된다.

# cp /usr/lib/kbd/keytables/us.map /usr/lib/kbd/keytables/han.map 

이것은 us.map을 han.map이란 이름으로 복사하는 것이다.
han.map에서 "keycode 57 = space  space"란 글을 찾은 후 뒤에 있는 space를 "Contorl_underscore"로 바꾼다. 즉, "keycode 57 = space  Control_underscore"처럼 바꾸면 된다. 그리고 난 후, /etc/han.cfg에서

---------------------------------------------------------------
# Show "NO warranty" message
StartupMessage: on
HanguelToggleChar: 31
HanguelKeyboard: 2
---------------------------------------------------------------

이와 같이 설정해 주면 된다. 여기서 "loadkeys han"이라고 실행하면 han.map에서 정의한 keymap으로 바뀌면서 한/영 전환을 shift+space로 할 수 있고, 끝마치려면 "loadkeys us"로 원상복귀하면 된다.

	< MC(Midnight Commander) 에서의 한글 출력 >
	리눅스를 사용하는 사람은 MC 를 적어도 한번 이상은 사용할 것이다. 편리한 기능을 가진 MC 에서의 한글 출력은 간단하다. MC 를 실행시키면, 맨위에 Options 라는 항목이 보일 것이다. Options 라는 항목을 선택하면, Display bits 라는 항목이 나타나는데 선택하고 들어가서, * Full 8 bits output 이라는 항목과 Full 8 bits input 이라는 항목을 선택한 뒤에, Save setup 를 선택하면 2바이트권을 지원해준다. 그 다음에 이 항목을 /etc/profile.d 에 mc.sh 이라는 파일로 만들어서 저장을 한다.

=====================< mc.sh >=============================
mc() {
	MC=/tmp/mc$$-"$RANDOM"
	/usr/bin/mc -P "$@" > "$MC"
	cd "`cat $MC`"
	rm -f "$MC"
	unset MC;
}
===========================================================

저장을 한뒤, 다음과 같은 실행 명령과 설정을 내려주면 한글 구현이 된다.

# chmod 755 mc.sh
# source mc.sh 

설정을 읽어들이게 되어서 다음 실행부터 한글이 구현이 된다.

	< lynx(텍스트 브라우저) 에서의 한글 구현 >
	lynx 는 텍스트형 브라우저로써 빠른 속도가 장점인 브라우저이다. 그럼, lynx 에서의 한글 출력에 대해서 알아보기로 하자. lynx를 실행한 후 "O" 키를 선택하면 Option 이 나오는데, display (C)haraster set를 Korean으로 바꾼 다음에, Raw 8-bit or CJK m(O)de를 ON으로 하시면 됩니다. 그러면, 다음 실행 부터는 한글을 보실수 있습니다.

	< GNU Emacs에서 한글 구현 >
	GNU Emacs 20.x 버젼부터는 Mule의 기능이 통합되어 다국어(한글, 중국어, 일어, 베트남어, 타일랜드어, ...)를 편리하게 사용을 할 수 있다. 그러나 한글/한자 전환 글쇠의 배열이 널리 쓰이는 글쇠가 아니라 불편할 수 있는데, 아래와 같이 홈 디렉토리의 .emacs 파일을 설정하면 SHIFT-SPACE 글쇠로 한글/영어 전환을 SHIFT-CTRL-SPACE 글쇠로 한자/영어 전환을 쉽게 할 수 있다. (CTRL-SPACE는 Emacs에서 일정 부분을 설정하는데 사용되는 글쇠이므로, 이 글쇠를 한자/영어변환에 사용하는 것은 혼란을 가져올 소지가 있으므로 여기에서는 SHIFT-CTRL-SPACE 글쇠로 대신했다.) 

=========================< .emacs >================================
 $HOME/.emacs 파일 

● 한글 환경 설정
(set-language-environment 'Korean)
(set-keyboard-coding-system 'korean-iso-8bit)
(set-terminal-coding-system 'korean-iso-8bit)

● 한글/영어 전환 함수
(defun toggle-hangul-key ()
	"Toggle Hangul Key"
	(interactive)
	(cond ((equal current-input-method "korean-hangul")
		(toggle-input-method))
		(t (select-input-method 'korean-hangul))))

● 한자/영어 전환 함수
(defun toggle-hanja-key ()
	"Toggle Hanja Key"
	(interactive)
	(cond ((equal current-input-method "korean-hanja")
		(toggle-input-method))
		(t (select-input-method 'korean-hanja))))

● 글쇠 설정
만일 한자/영어 전환 글쇠를 F9로 바꾸고 싶으면,
[(shift control ?\ )]을 [(f9)]으로 변경하면 된다.
(define-key global-map [(shift ?\ )] 'toggle-hangul-key)
(define-key global-map [(shift control ?\ )] 'toggle-hanja-key)
===================================================================
■ X-Window 설정하기
	개요 : 리눅스 사용자에게 리눅스를 시작하기도 전에 맨 먼저 봉착하는 문제가 바로 X-Window 가 아닌가 싶다. MS-Windows 나 Mac 같은 환경에 익숙한 오늘날 유저에게 리눅스에서의 X-Window 의 화면은 리눅스의 사용을 위해서 필수적인 문제로 받아들이는 듯 싶다. LinuX에서의 X-Window 환경 구현은 XFree86 프로젝트팀에서 구현을 하고 있지만, 많은 문제에 당면하고 있다. 각 VGA 제조회사에서의 드라이브 공개가 쉽지 않고, Linux 문제에 대해서 그리 큰 문제로 받아들이지 않기 때문이다. 그들에게 MS-Windows라는 큰 시장이 있기에 Linux라는 시장은 크게 보지 않고 있기 때문이다. 그래서, 2-3년 전 에는 Linux에서의 X-Window의 데스크탑을 보는 경우는 흔한 일이 아니었다. 그러나, 요즘 추세는 많은 VGA 제조업체에서 드라이브 정보를 많은 Linux 사용자에게 공개하고 있으며, XFree86 3.3.2에서는 AGP 비디오 카드에 대한 지원도 하기 시작하였다. 이 문서는 Linux 사용자에게 처음 당면하게 되는 X-Window 설정을 다양한 시각에서 보여주고자 함이다.

	< 설치에 필요한 XFree86 패키지별 목록 >
preinst.sh :		Pre-installation script.
Postinst.sh :		Post-installation script.
extract :		XFree86 extraction utility.
X332bin.tgz :		clients, run-time libs, and app-defaults files.
X332doc.tgz :		Documentation.
X332fnts.tgz :		75dpi, misc and PEX fonts.
X332libs.tgz :		Data files required at run-time.
X332man.tgz :		Manual pages.
X332set.tgz :		XF86Setup utility.
X332VG16.tgz :		16 colors VGA server (XF86Setup needs this server).
X332upd.tgz :		XFree86 3.3.2 patch 2 update.
X332cfg.tgz :		Sample config files for xinit, xdm.
X3328514.tgz :		8514/A server.
X332AGX.tgz :		AGX server.
X332I128.tgz :		I128 server.
X332Mach32.tgz :	Mach 32 server.
X332Mach64.tgz :	Mach 64 server.
X332Ma8.tgz :		Mach 8 server.
X332Mono.tgz :		Mono server.
X332P9k.tgz :		P9000 server.
X332S3.tgz :		S3 server.
X332S3V.tgz :		old S3 VIRGE server (please use SVGA server).
X332SVGA.tgz :	SVGA server.
X332VG16.tgz :		16 colour VGA server (XF86Setup needs this server).
X332W32.tgz :		ET4000/W32, ET6000 server.
X332f100.tgz :		100dpi fonts.
X332fcyr.tgz :		Cyrillic fonts.
X332fnon.tgz :		Other fonts (chinese, Japanese, Korean, Hebrew).
X332fscl.tgz :		Scalable fonts (Speedo and Type1).
X332fsrv.tgz :		Font server and config files.
X332prog.tgz :		X header files, config files and compile-time libs.
X332nest.tgz :		Hested X server.
X332vfb.tgz :		Virtual framebuffer X server.
X332prt.tgz :		X Print server.
X332ps.tgz :		Postscript version of the documentation.
X332html.tgz :		HTML version of the documentation.
X332lkit.tgz :		X server LinkKit.
X332lk98.tgz :		X server LinkKit for PC98 servers. 

	< XFree86 설치 >
	이전에 XFree86 버전이 있다면 /usr/X11R6/ 디렉토리를 인스톨하기 이전에 백업을 하기 바란다.

# mkdir /home/X11R6
# ln -s /home/X11R6 /usr
# cd /usr/X11R6

	그 다음 인스톨할 XFree86 패키지를 전부다 /var/tmp 디렉토리로 복사를 한다. 패키지를 인스톨하기 전에 먼저 post installation script를 실행시킨 다음에 

# sh /var/tmp/preinst.sh
# chmod 755 extract

이제 XFree86 을 인스톨 준비가 되었다. 인스톨할 패키지를 동일한 디렉토리에 카피를 하는 것을 잊지 말기를...

# cd /usr/X11R6
# /var/tmp/extract /var/tmp/X332[8-z]*.tgz
그러면, 패키지들은 설치가 되기 시작한다.

	< XFree86 패치 >
	현재 XFree86 3.3.2 의 가장 최신 패치 파일은 X332upd.tgz 파일이다. 이 파일을 받아서 패치를 해보자.

extract :                XFree86 extraction utility.
X3322upd.tgz :          XFree86 3.3.2 patch 2 update.

먼저, XFree86 3.3.2 버전이 설치 되어있다고 가정을 한다.

# chmod 755 extract

그리고, X3322upd.tgz 를 /var/tmp 디렉토리로 복사를 한다.

# cp X3322upd.tgz /var/tmp/
# /var/tmp/extract /var/tmp/X332upd.tgz
(주의)X3322upd.tgz를 인스톨하기 전에 X3321upd.tgz가 설치가 되어야한다. 

	< Xconfigurator로 설정하기 >
	최신 리눅스 시스템에서는 X를 설정하는데 있어서 두 가지 방식을 지원한다. 첫번째는,  X를 설정하기 편하고 시각적으로 쉽게 접근 할 수 있도록 Xconfigurator라는 툴을 이용하여 X를 설정하는 방식과, 두번째는, 예전의 텍스트 모드로써 보여주는 xf86config가 있다. 여기서는 사용자들이 쉽게 접근 할 수 있는 Xconfigurator에 대해서 알아보기로 하자. Xconfigurator는 X interface 와 콘솔 모드에서 모두 사용 가능하다. 다음과 같은 명령을 실행해 보자.

# Xconfigurator

=========================< Xconfigurator >===================================
  Xconfigurator 3.57 - (C) 1998 Red Hat Software and others
-----------------------------------------------------------------------------
       This program will create a basic XF86Config file, based on Menu
       selections you make.

       The XF86Config file usually resides in /usr/X11R6/lib/X11 or
       /etc/X11. A sample XF86Config file is supplied with XFree86; it
       is confgiured for a standard VGA card and monitor with 640x480
       resolution.

       You can either take the sample XF86Config as a base and edit it
       for your configuration, or let this program produce a base
       XF86Config file for your configuration adn fine-tune it. Refer
       to /usr/X11R6/lib/X11/doc/README.Config for a detailed overview


                  ----                         ----------
                 | OK |                       |  Cancel  |
                  ----                         ----------

-------------------------------------------------------------------------
  <Tab>/<Alt-Tab> between elements  | <Space> selects | <F12> next screen  
=========================================================================

이런 화면이 나올 것이다. 여기서, OK 버튼을 누르고 들어가면 자신의 비디오 카드의 칩셋을 찾으면서 다음의 화면이 나올것이다.
  
=========================================================================
  Xconfigurator 3.57 - (C) 1998 Red Hat Software and others
                ------------------------------------------
                                  PCI Probe
          
                  PCI probing found a:

                    PCI Entry: Mystique
                    X server : SVGA

                                  ---------
                                  |  OK   |
                                  --------

                ------------------------------------------- 
    <Tab>/<Alt-Tab> between elements | <Space> selects | <F12> next screen
========================================================================
여기서 잡힌 비디오 카드는 미스티크이고, 여기에 맞는 X server 는 SVGA 라는 메시지 가 나온다. 비디오 카드가 설정이 되었으니, 다음으로 넘어가 보자.
   
========================================================================
   Xconfigurator 3.57 - (C) 1998 Red Hat Software and others
        --------------------------------------------------------------  
                               Monitor Setup

        What type of monitor do you have? If you would rather specify the             sync frequencies of your monitor, choose "Custom" from the list. 

                     Custom                                
                     Acer Acerview 11D                     
                     Acer Acerview 33D/33DL             
                     Acer Acerview 34T/34TL             
                     AOC-15                               
                     Apollo 1280x1024-68Hz                
                     Apollo 1280x1024-70Hz       

                --------                       -----------------
                |  OK  |                       |    Cancel     |
                -------                        -----------------
        --------------------------------------------------------------
    <Tab>/<Alt-Tab> between elements  | <Space> selects | <F12> next screen
=========================================================================
  
여기서 자신이 가지고 있는 모니터를 찾아보기 바란다. 국산의 삼성과 현대 모니터를 가지고 있는 사용자라면 설정을 맞추기 쉬울 것이다. LG 모니터는 아직 들어있지 않다. 자신이 가지고 있는 모니터가 목록에 없다면, 맨 위의 Custom 을 선택한 후 모니터의 매뉴얼을 찾아서 모니터의 수직 주파수와 수평 주파수를 알아두기 바란다. 모니터를 선택하였다면 다음으로 넘어 가보자.

  =============================================================              
  Xconfigurator 3.57 - (C) 1998 Red Hat Software and others 

  -----------------------------------------------------------------
                                 Monitor Setup

       Now we want to set the specifications of the monitor. The             
       two critical parameters are the vertical refresh rate, which          
       is the rate at which the the whole screen is refreshed, and           
       most importantly the horizontal sync rate, which is the rate          
       at which scanlines are displayed.                                     
             
       The valid range for horizontal sync and vertical sync should          
       be documented in the manual of your monitor. If in doubt,             
       check the monitor database /usr/X11R6/lib/X11/doc/Monitors            
       to see if your monitor is there.                       
   

 
                ---------                   -----------------     
                |       |                   |               |
                |  OK   |                   |     Cancel    |
                |       |                   |               | 
                --------                    ----------------
       -----------------------------------------------------------------
    <Tab>/<Alt-Tab> between elements | <Space> selects | <F12> next screen   
=========================================================================

모니터를 설정하기 위한 메시지이다. 모니터를 설정하려면 OK 하고 넘어간다.
  
=========================================================================
  Xconfigurator 3.57 - (C) 1998 Red Hat Software and others
      ----------------------------------------------------------------
                        Monitor Setup (Continued)

      You must indicate the horizontal sync range of your monitor. You can          either select one of the predefined ranges below that correspond to           industry-standard monitor types, or give a specific range.                    It is VERY IMPORTANT that you do not specify a monitor type with a            horizontal sync range that is beyond the capabilities of your monitor.        If in doubt, choose a conservative setting.

      Standard VGA, 640x480 @ 60 Hz                               
      Super VGA, 800x600 @ 56 Hz                                  
      8514 Compatible, 1024x768 @ 87 Hz interlaced (no 800x600)   
      Super VGA, 1024x768 @ 87 Hz interlaced, 800x600 @ 56 Hz  
      Extended Super VGA, 800x600 @ 60 Hz, 640x480 @ 72 Hz       
      Non-Interlaced SVGA, 1024x768 @ 60 Hz, 800x600 @ 72 Hz      
      High Frequency SVGA, 1024x768 @ 70 Hz                     
      Monitor that can do 1280x1024 @ 60 Hz           
      Monitor that can do 1280x1024 @ 74 Hz                    
      Monitor that can do 1280x1024 @ 76 Hz      

            ---------                     ---------------------
            |       |                     |                   | 
            |  OK   |                     |      Cancel       |
            |       |                     |                   |
            ---------                     ---------------------
      --------------------------------------------------------------------
  <Tab>/<Alt-Tab> between elements | <Space> selects | <F12> next screen
  =======================================================================
  
이 부분은 모니터에서 해상도에 따른 수평 동기 주파수를 맞추는 항목이다. 자신의 모니터에서 수평 동기 주파수를 매뉴얼에서 찾아 맞추어 보기 바란다. 수평 주파수를 맞추었으면 다음은 수직 주파수를 맞추는 부분이다

========================================================================= 
  Xconfigurator 3.57 - (C) 1998 Red Hat Software and others 
       -------------------------------------------------------------
                      Monitor Setup (Continued)

       You must indicate the vertical sync range of your monitor.           
       You can either select one of the predefined ranges below             
       that correspond to industry-standard monitor types, or give          
       a specific range. For interlaced modes, the number that              
       counts is the high one (e.g. 87 Hz rather than 43 Hz).               
          
                                 50-70                                     
                                 50-90                                     
                                 50-100                                    
                                 40-150 


         ---------                    --------------------- 
         |       |                    |                   |
         |  OK   |                    |       Cancel      |
         |       |                    |                   |
         ---------                    ---------------------

       --------------------------------------------------------------
  <Tab>/<Alt-Tab> between elements | <Space> selects | <F12> next screen   
  ======================================================================

여기서는 모니터의 수직 동기 주파수를 맞추는 부분이다.

======================================================================
  Xconfigurator 3.57 - (C) 1998 Red Hat Software and others
               ---------------------------------------------
                           Probing to begin

                 Xconfigurator will now run the X                        
                 server you selected to probe                            
                 various information about your                          
                 video card. It is normal for the                        
                 screen to blink several times.  

                                ----------
                                |        |
                                |   OK   |
                                |        |
                                ----------

                --------------------------------------------

  <Tab>/<Alt-Tab> between elements | <Space> selects | <F12> next screen 
  ========================================================================
이 부분은 모니터의 유저가 선택한 모니터의 수직 주파수 와 수평 주파수 및 비디오 카드의 칩셋의 클럭이 맞는지 확인하는 절차이다. 이 테스트에서 맞지 않는다면 다시 설정을 할 수 있다. 맞지 않는다면 이런 메세지가 나올 것이다.

 =========================================================================
  Xconfigurator 3.57 - (C) 1998 Red Hat Software and others
                 -------------------------------------------
                                  X Error

                      There was an error executing the                        
                      X server in a probing mode. You                         
                      should try configuring the video                        
                      card manually. 

                                  ----------
                                  |        | 
                                  |   OK   |
                                  |        |
                                  ----------

                 -------------------------------------------
  <Tab>/<Alt-Tab> between elements | <Space> selects | <F12> next screen
  =======================================================================  

다음은 비디오 메모리를 설정하는 부분이다.

  =======================================================================
  Xconfigurator 3.57 - (C) 1998 Red Hat Software and others
                     ------------------------------------
                                   Video Memory

                      How much video memory do you have?                      
                                      256 k                                 
                                      512 k                                  
                                      1 meg                                  
                                      2 meg                                  
                                      4 meg                                  
                                      8 meg
                       -------           ----------------
                       |     |           |              |
                       |  OK |           |    Cancel    |
                       |     |           |              |
                       -------           ---------------- 

                     ------------------------------------
  <Tab>/<Alt-Tab> between elements | <Space> selects | <F12> next screen
  ========================================================================

요즘 대부분의 비디오 카드의 메모리는 1-2MB이다. 자신의 비디오 메모리가 얼마나 되는지 확인해보자. 설정을 하였으면 다음은 비디오 카드의 클럭 칩셋을 설정하는 부분이다.

  ========================================================================
  Xconfigurator 3.57 - (C) 1998 Red Hat Software and others 
       -------------------------------------------------------------
                            Clockchip Configuration

       Which Clockchip do you have ?

       No Clockchip Setting (recommended)                                 
       Chrontel 8391                                                      
       ICD2061A and compatibles (ICS9161A, DCS2824)                       
       ICS2595                                                            
       ICS5342 (similar to SDAC, but not completely compatible)           
       ICS5341                                                            
       S3 GenDAC (86C708) and ICS5300 (autodetected)                      
       S3 SDAC (86C716)                                     
       STG 1703 (autodetected)                                            
       Sierra SC11412                                                     
       TI 3025 (autodetected)                                             
       TI 3026 (autodetected)                                             
       IBM RGB 51x/52x (autodetected       

            ---------                       -------------------
            |       |                       |                 |
            |  OK   |                       |      Canecel    |
            |       |                       |                 |
            ---------                       -------------------
------------------------------------------------------------------------
  <Tab>/<Alt-Tab> between elements | <Space> selects | <F12> next screen  
=========================================================================

자신의 비디오 카드의 메뉴얼을 보아서 비디오 카드의 클럭 칩셋의 정확한 이름을 알아야 할 것이다. S3 계열을 제외한 대부분의 비디오 카드는 No Clockchip Setting (recommend) 선택하면 된다. 여기서는 자신이 원하고자 하는 컬러수와 해상도를 체크하기 바란다.
  =======================================================================

      ----------------------------------------------------------------
                                You're Done!

      File has been written. Take a look at it before running               
      'startx'. Note that the XF86Config file must be in one of the         
      directories searched by the server (e.g. /usr/X11R6/lib/X11)          
      in order to be used. Within the server press ctrl, alt and            
      '+' simultaneously to cycle video resolutions. Pressing ctrl,         
      alt and backspace simultaneously immediately exits the server         
      (use if the monitor doesn't sync for a particular mode).              
              
      For further configuration, refer to                                   
      /usr/X11R6/lib/X11/doc/README.Config.  
                         
                                  --------
                                  |      |
                                  |  OK  |
                                  |      |
                                  --------
      ----------------------------------------------------------------
=========================================================================


이것으로서, 간단히 나마 Xconfigurator 를 이용하여 X 를 설정해 보았다. 다음은 텍스트 모드로 X 를 설정하는 방법에 대해서 알아보기로 하자.

	< xf86config 로 설정하기 >
	이 방식은 위에서도 언급했듯이 텍스트 모드로써 X 를 설정하는 방법이다. 콘솔에서나 X interfaces에서 설정 할 수 있는 방식이다. 그럼, 아무데서나 xf86config를 실행하기 바란다.
   
# xf86config

 ======================================================================
 This program will create a basic XF86Config file, based on menu selections you
 make.

 The XF86Config file usually resides in /usr/X11R6/lib/X11 or /etc/X11. A sample
 XF86Config file is supplied with XFree86; it is configured for a standard
 VGA card and monitor with 640x480 resolution. This program will ask for a
 pathname when it is ready to write the file.

 You can either take the sample XF86Config as a base and edit it for your
 configuration, or let this program produce a base XF86Config file for your
 configuration and fine-tune it. Refer to /usr/X11R6/lib/X11/doc/README.Config
 for a detailed overview of the configuration process.

 For accelerated servers (including accelerated drivers in the SVGA server),
 there are many chipset and card-specific options and settings. This program
 does not know about these. On some configurations some of these settings must
 be specified. Refer to the server man pages and chipset-specific READMEs.

 Before continuing with this program, make sure you know the chipset and
 amount of video memory on your video card. SuperProbe can help with this.
 It is also helpful if you know what server you want to run.

 Press enter to continue, or ctrl-c to abort.
 =======================================================================

xf86config 의 도입 부분이다. 계속 하려면 엔터를, 중단한다면 ctrl-c를 누르면 된다. 엔터를 쳐서 계속 진행을 해보자.
 =======================================================================
 The directory '/usr/X386/bin' exists. You probably have an old version of
 XFree86 installed (XFree86 3.1 installs in '/usr/X11R6' instead of
 '/usr/X386').

 It is important that the directory '/usr/X11R6' is present in your
 search path, *before* any occurrence of '/usr/X386/bin'. If you have installed
 X program binaries that are not in the base XFree86 distribution in
 '/usr/X386/bin', you can keep the directory in your path as long as it is
 after '/usr/X11R6'.

 Your PATH is currently set as follows:
 
/sbin:/usr/sbin:/bin:/usr/bin:/usr/X11R6/bin:/opt/kde/bin:/root/bin:/usr/X11R6/bin:/opt/kde/b
in:/root/bin

 Note that the X binary directory in your path may be a symbolic link.
 In that case you could modify the symbolic link to point to the new binaries.
 Example: 'rm -f /usr/bin/X11; ln -s /usr/X11R6/bin /usr/bin/X11', if the
 link is '/usr/bin/X11'.

 Make sure the path is OK before continuing.
 Press enter to continue, or ctrl-c to abort.
 =======================================================================

현재 XFree86 버전이 설치된 패스를 확인하는 절차이다. 역시 계속 하려면 엔터를 치고 넘어가면 된다.
 =======================================================================
 First specify a mouse protocol type. Choose one from the following list:

 1.  Microsoft compatible (2-button protocol)
 2.  Mouse Systems (3-button protocol)
 3.  Bus Mouse
 4.  PS/2 Mouse
 5.  Logitech Mouse (serial, old type, Logitech protocol)
 6.  Logitech MouseMan (Microsoft compatible)
 7.  MM Series
 8.  MM HitTablet
 9.  Microsoft IntelliMouse

 If you have a two-button mouse, it is most likely of type 1, and if you have
 a three-button mouse, it can probably support both protocol 1 and 2. There are
 two main varieties of the latter type: mice with a switch to select the
 protocol, and mice that default to 1 and require a button to be held at
 boot-time to select protocol 2. Some mice can be convinced to do 2 by sending
 a special sequence to the serial port (see the ClearDTR/ClearRTS options).

 Enter a protocol number: 
 ======================================================================

자신의 시스템에 부착된 마우스의 종류를 선택하는 부분이다. PS/2 마우스는 4번,  일반적인 시리얼 마우스를 가지고 있는 사용자는 1번을 선택하고 넘어가면 된다.
 =======================================================================
 If your mouse has only two buttons, it is recommended that you enable
 Emulate3Buttons.

 Please answer the following question with either 'y' or 'n'.
 Do you want to enable Emulate3Buttons? 
 ========================================================================
 
일반적인 2버튼 사용자라도 양쪽 버튼을 가지고 마치 3버튼 마우스처럼 가상 에뮬레이트 해주는 기능을 선택할 것인지 묻는 항목이다. 2버튼 마우스를 3버튼 마우스 처럼 사용하려면 YES로 설정하고 넘어가기 바란다.

 ========================================================================
 Now give the full device name that the mouse is connected to, for example
 /dev/tty00. Just pressing enter will use the default, /dev/mouse.

 Mouse device:
 ========================================================================

마우스의 시스템 디바이스를 결정하는 부분이다. 디폴트로는 /dev/mouse 로 되어있다. 엔터를 치고 넘어가면 된다.

========================================================================
 Beginning with XFree86 3.1.2D, you can use the new X11R6.1 XKEYBOARD
 extension to manage the keyboard layout. If you answer 'n' to the following
 question, the server will use the old method, and you have to adjust
 your keyboard layout with xmodmap.

 Please answer the following question with either 'y' or 'n'.
 Do you want to use XKB?
 =========================================================================

키보드의 언어 매핑을 지정하는 부분이다. 대부분 NO를 선택한 후 다음의 키보드에서 선택하기 바란다.

 =========================================================================
 If you want your keyboard to generate non-ASCII characters in X, because
 you want to be able to enter language-specific characters, you can
 set the left Alt key to Meta, and the right Alt key to ModeShift.

 Please answer the following question with either 'y' or 'n'.
 Do you want to enable these bindings for the Alt keys?
 =========================================================================

이것은 왼쪽과 오른쪽 ALT 키를 다르게 지정 할것 인지에 대한 항목이다. 사용자의 선택에 달렸다.

 =========================================================================
 Now we want to set the specifications of the monitor. The two critical
 parameters are the vertical refresh rate, which is the rate at which the
 the whole screen is refreshed, and most importantly the horizontal sync rate,
 which is the rate at which scanlines are displayed.

 The valid range for horizontal sync and vertical sync should be documented
 in the manual of your monitor. If in doubt, check the monitor database
 /usr/X11R6/lib/X11/doc/Monitors to see if your monitor is there.

 Press enter to continue, or ctrl-c to abort.
 =========================================================================

모니터 설정에 앞서 모니터의 수평 동기 주파수와 수직 동기 주파수를 확인하기 바란다. 모니터를 설정하려면 엔터를 치고 넘어간다.

 =========================================================================
 You must indicate the horizontal sync range of your monitor. You can either
 select one of the predefined ranges below that correspond to industry-
 standard monitor types, or give a specific range.

 It is VERY IMPORTANT that you do not specify a monitor type with a horizontal sync range that is beyond the capabilities of your monitor. If in doubt, choose a conservative setting.

   hsync in kHz; monitor type with characteristic modes
1  31.5; Standard VGA, 640x480 @ 60 Hz
2  31.5 - 35.1; Super VGA, 800x600 @ 56 Hz
3  31.5, 35.5; 8514 Compatible, 1024x768 @ 87 Hz interlaced (no 800x600)
4  31.5, 35.15, 35.5; Super VGA, 1024x768 @ 87 Hz interlaced, 800x600 @ 56 Hz
5  31.5 - 37.9; Extended Super VGA, 800x600 @ 60 Hz, 640x480 @ 72 Hz
6  31.5 - 48.5; Non-Interlaced SVGA, 1024x768 @ 60 Hz, 800x600 @ 72 Hz
7  31.5 - 57.0; High Frequency SVGA, 1024x768 @ 70 Hz
8  31.5 - 64.3; Monitor that can do 1280x1024 @ 60 Hz
9  31.5 - 79.0; Monitor that can do 1280x1024 @ 74 Hz
10  31.5 - 82.0; Monitor that can do 1280x1024 @ 76 Hz
11  Enter your own horizontal sync range

 Enter your choice (1-11): 
 =========================================================================
 
이 부분은 자신이 가지고 있는 모니터의 수평 동기 주파수를 설정하는 방식이다. 먼저, 자신의 모니터의 매뉴얼에서 수평 동기 주파수 대역을 확인한 후에 찾아보고 없다면 11번을 선택하여 자신의 주파수 대역을 적어주면 된다. 1-10번 사이를 설정한 사용자를 제외한 11번을 선택하여 직접 수평 동기 주파수를 설정하려는 사람은 다음 장면을 잘 확인하기 바란다.
 ========================================================================
 Please enter the horizontal sync range of your monitor, in the format used
 in the table of monitor types above. You can either specify one or more
 continuous ranges (e.g. 15-25, 30-50), or one or more fixed sync frequencies.

 Horizontal sync range: 
 =========================================================================

11번을 선택하여 나타난 부분이다. 자신의 수평 동기 주파수 대역을 (Horizontal sync range: ) 이 부분에 적어주면된다. 예를 들어서 자신의 수평 동기 주파수 대역이 30-65 사이라면

ex)  Horizontal sync range: 30-65

이런식으로 설정을 해주면 된다. 설정을 다 했다면 다음 수직 동기 주파수를 설정하는 부분으로 이동해 보자.
 ========================================================================
 You must indicate the vertical sync range of your monitor. You can either
 select one of the predefined ranges below that correspond to industry-
 standard monitor types, or give a specific range. For interlaced modes,
 the number that counts is the high one (e.g. 87 Hz rather than 43 Hz).

 1  50-70
 2  50-90
 3  50-100
 4  40-150
 5  Enter your own vertical sync range

 Enter your choice: 
 ========================================================================
 
모니터의 수직 동기 주파수를 설정하는 부분으로써, 자신의 모니터의 매뉴얼에서 수직 동기 주파수 대역을 확인을 한 후에 설정하기 바란다. 자신의 모니터의 수직 동기 주파수 대역을 자세히 아는 사용자라면 5번 항목에서 정확한 모니터 주파수 대역을 적어주는 것을 권장한다. 5번을 선택한 후에 수직 동기 주파수 대역을 설정하는 방법이다.

 ========================================================================
 Vertical sync range: 50-110
 ========================================================================
  
여기서 수직 동기 주파수 대역을 50-110 이라고 설정해주었다. 필자 모니터의 수직 동기 주파수 대역이다. 다 되었으면 엔터를 치고 다음으로 넘어가보자.

========================================================================
 You must now enter a few identification/description strings, namely an
 identifier, a vendor name, and a model name. Just pressing enter will fill
 in default names.

 The strings are free-form, spaces are allowed.
 Enter an identifier for your monitor definition:
 ========================================================================

모니터의 모델 이름을 묻는 항목이다. 적지 않아도 상관없다.
 ========================================================================
 Enter the vendor name of your monitor: 
 ========================================================================

역시 이름을 묻는 항목이다.
 ========================================================================
 Enter the model name of your monitor:
 ========================================================================

적어주지 않아도 된다.
다음은 그래픽 카드를 선택하는 부분이다.
========================================================================
 Now we must configure video card specific settings. At this point you can
 choose to make a selection out of a database of video card definitions.
 Because there can be variation in Ramdacs and clock generators even
 between cards of the same model, it is not sensible to blindly copy
 the settings (e.g. a Device section). For this reason, after you make a
 selection, you will still be asked about the components of the card, with
 the settings from the chosen database entry presented as a strong hint.

 The database entries include information about the chipset, what server to
 run, the Ramdac and ClockChip, and comments that will be included in the
 Device section. However, a lot of definitions only hint about what server
 to run (based on the chipset the card uses) and are untested.

 If you can't find your card in the database, there's nothing to worry about.
 You should only choose a database entry that is exactly the same model as
 your card; choosing one that looks similar is just a bad idea (e.g. a
 GemStone Snail 64 may be as different from a GemStone Snail 64+ in terms of
 hardware as can be).

 Do you want to look at the card database? 
 =======================================================================

이 부분은 그래픽 카드를 선택하는 부분이다. Yes 로 설정하고 엔터하고 넘어가 보자.
 =======================================================================
 
  0  2 the Max MAXColor S3 Trio64V+                    S3 Trio64V+
  1  928Movie                                          S3 928
  2  AGX (generic)                                     AGX-014/15/16
  3  ALG-5434(E)                                       CL-GD5434
  4  ASUS 3Dexplorer                                   RIVA128
  5  ASUS PCI-AV264CT                                  ATI-Mach64
  6  ASUS PCI-V264CT                                   ATI-Mach64
  7  ASUS Video Magic PCI V864                         S3 864
  8  ASUS Video Magic PCI VT64                         S3 Trio64
  9  AT25                                              Alliance AT3D
 10  AT3D                                              Alliance AT3D
 11  ATI 3D Pro Turbo                                  ATI-Mach64
 12  ATI 3D Xpression                                  ATI-Mach64
 13  ATI 3D Xpression+ PC2TV                           ATI-Mach64
 14  ATI 8514 Ultra (no VGA)                           ATI-Mach8
 15  ATI All-in-Wonder                                 ATI-Mach64
 16  ATI Graphics Pro Turbo                            ATI-Mach64
 17  ATI Graphics Pro Turbo 1600                       ATI-Mach64 
 18  ATI Graphics Ultra                                ATI-Mach8
 19  ATI Graphics Ultra Pro                            ATI-Mach32
 20  ATI Graphics Xpression with 68875 RAMDAC          ATI-Mach64
 21  ATI Graphics Xpression with AT&T 20C408 RAMDAC    ATI-Mach64
 22  ATI Graphics Xpression with CH8398 RAMDAC         ATI-Mach64
 23  ATI Graphics Xpression with Mach64 CT (264CT)     ATI-Mach64
 24  ATI Graphics Xpression with STG1702 RAMDAC        ATI-Mach64
 25  ATI Mach32                                        ATI-Mach32
 26  ATI Mach64                                        ATI-Mach64
 27  ATI Mach64 3D RAGE II+, Internal RAMDAC           ATI-Mach64
 28  ATI Mach64 3D RAGE II, Internal RAMDAC            ATI-Mach64
 29  ATI Mach64 CT (264CT), Internal RAMDAC            ATI-Mach64
 30  ATI Mach64 GT (264GT), aka 3D RAGE, Internal RAMDACATI-Mach64
 31  ATI Mach64 VT (264VT), Internal RAMDAC            ATI-Mach64
 32  ATI Mach64 with AT&T 20C408 RAMDAC                ATI-Mach64
 33  ATI Mach64 with CH8398 RAMDAC                     ATI-Mach64
 34  ATI Mach64 with IBM RGB514 RAMDAC                 ATI-Mach64
 35  ATI Pro Turbo+PC2TV, 3D Rage II+DVD               ATI-Mach64
 36  ATI Ultra Plus                                    ATI-Mach32
 37  ATI Video Xpression                               ATI-Mach64
 38  ATI Win Boost with AT&T 20C408 RAMDAC             ATI-Mach64
 39  ATI Win Boost with CH8398 RAMDAC                  ATI-Mach64
 40  ATI Win Boost with Mach64 CT (264CT)              ATI-Mach64
 41  ATI Win Boost with STG1702 RAMDAC                 ATI-Mach64
  .
  .
  .
  .
  .
  .
  .
 415  XGA-1  (ISA bus)                                  XGA-1
 416  XGA-2  (ISA bus)                                  XGA-2
 417  miro miroMedia 3D                                 S3 ViRGE

 Enter a number to choose the corresponding card definition.
 Press enter for the next page, q to continue configuration.
 ================================================================

XFree86 3.3.2 에서는 많은 비디오 카드가 지원되기 시작했다. 특히, 이번 버전부터는 AGP 비디오 카드가 시험적으로 도입이 되었다. 부가적인 설명을 하자면 왼쪽에 있는 것은 비디오 카드 모델명이고, 오른쪽에 있는 것은 비디오 카드의 칩셋이다.
리눅스 상에서의 비디오 카드는 비디오 카드 칩셋에 따라 X 설정이 많이 좌우하게 된다. 목록에서 자신의 비디오 카드를 선택하였다면 다음과 같은 메시지 가 나타날 것이다.
  ===================================================================
  Your selected card definition:

  Identifier: Matrox Mystique
  Chipset:    mga1064sg
  Server:     XF86_SVGA
  Do NOT probe clocks or use any Clocks line.

  Press enter to continue, or ctrl-c to abort.
  =====================================================================

XFree86 3.3.2 에서 추가로 지원되는 비디오 카드 목록은 나중에 보여줄 것이다. 엔터를 치고 넘어가면 다음과 같은 메세지가 나타날 것이다.
  ======================================================================
  Now you must determine which server to run. Refer to the manpages and other
  documentation. The following servers are available (they may not all be
  installed on your system):

 1  The XF86_Mono server. This a monochrome server that should work on any
    VGA-compatible card, in 640x480 (more on some SVGA chipsets).
 2  The XF86_VGA16 server. This is a 16-color VGA server that should work on
    any VGA-compatible card.
 3  The XF86_SVGA server. This is a 256 color SVGA server that supports
    a number of SVGA chipsets. On some chipsets it is accelerated or
    supports higher color depths.
 4  The accelerated servers. These include XF86_S3, XF86_Mach32, XF86_Mach8,
    XF86_8514, XF86_P9000, XF86_AGX, XF86_W32, XF86_Mach64, XF86_I128 and
    XF86_S3V.

These four server types correspond to the four different "Screen" sections in
XF86Config (vga2, vga16, svga, accel).

 5  Choose the server from the card definition, XF86_SVGA.

  Which one of these screen types do you intend to run by default (1-5)? 
  =======================================================================

위의 비디오 카드 항목에서 선택을 하였으면 5번을 선택하지만, 만약, 자신의 비디오 카드가 목록에 없을 경우에는 1-4번 항목을 선택할 수 있다.

1번 항목은 흑백 모드로 X 를 설정하도록 하는 항목이다.
2번 항목은 Mono(즉, 16컬러) 모드로 X 를 설정하도록 하는 항목이다.
3번 항목은 256 컬러 SVGA 모드로 X 를 설정하도록 하는 항목이다.
시스템에 있는 비디오 카드가 목록에 없을 경우에 SVGA 모드로 X 설정할 경우이다.
4번 항목은  accelerated 기능이 있는 비디오 카드를 선택하는 항목이다. 리눅스에서 가장 X 설정하기 쉬운 비디오 카드를 지원하는 항목이다.
  =======================================================================
  The server to run is selected by changing the symbolic link 'X'. For example,
  'rm /usr/X11R6/bin/X; ln -s /usr/X11R6/bin/XF86_SVGA /usr/X11R6/bin/X' selects
  the SVGA server.

  Please answer the following question with either 'y' or 'n'.
  Do you want me to set the symbolic link? 
  ======================================================================
  
이 항목은 선택된 X 서버를 /usr/X11R6/bin/X 로 링크를 시키는 항목이다. YES 로 설정하고 다음으로 넘어가보자.

  =======================================================================
  Now you must give information about your video card. This will be used for
  the "Device" section of your video card in XF86Config.

  You must indicate how much video memory you have. It is probably a good
  idea to use the same approximate amount as that detected by the server you
  intend to use. If you encounter problems that are due to the used server
  not supporting the amount memory you have (e.g. ATI Mach64 is limited to
  1024K with the SVGA server), specify the maximum amount supported by the
  server.

  How much video memory do you have on your video card:

  1  256K
  2  512K
  3  1024K
  4  2048K
  5  4096K
  6  Other

  Enter your choice: 
  =======================================================================

이 항목은 시스템에 부착된 비디오 카드의 메모리를 선택하는 부분이다. 자신의 비디오 카드의 메모리를 살펴보기 바란다.

  =======================================================================
  You must now enter a few identification/description strings, namely an
  identifier, a vendor name, and a model name. Just pressing enter will fill
  in default names (possibly from a card definition).

  Your card definition is Matrox Mystique.

  The strings are free-form, spaces are allowed.
  Enter an identifier for your video card definition:
  =======================================================================

이 항목은 비디오 카드의 회사명을 적어주는 곳이다. 써주지 않아도 상관없다.
=======================================================================
  You can simply press enter here if you have a generic card, or want to
  describe your card with one string.
  Enter the vendor name of your video card: 
  =======================================================================

이 항목은 비디오 카드의 모델명을 적어주는 항목이다. 써주지 않아도 상관없다.

=========================================================================
  Enter the model (board) name of your video card:
  
=========================================================================

이 항목도 마찬가지이다.

=========================================================================
  The RAMDAC setting only applies to the S3, AGX, W32 servers, and some 
  drivers in the SVGA servers. Some RAMDAC's are auto-detected by the server.
  The detection of a RAMDAC is forced by using a Ramdac "identifier" line in
  the Device section. The identifiers are shown at the right of the following
  table of RAMDAC types:

   1  AT&T 20C490 (S3 and AGX servers, ARK driver)                att20c490
   2  AT&T 20C498/21C498/22C498 (S3, autodetected)                att20c498
   3  AT&T 20C409/20C499 (S3, autodetected)                       att20c409
   4  AT&T 20C505 (S3)                                            att20c505
   5  BrookTree BT481 (AGX)                                       bt481
   6  BrookTree BT482 (AGX)                                       bt482
   7  BrookTree BT485/9485 (S3)                                   bt485
   8  Sierra SC15025 (S3, AGX)                                    sc15025
   9  S3 GenDAC (86C708) (autodetected)                           s3gendac
  10  S3 SDAC (86C716) (autodetected)                             s3_sdac
  11  STG-1700 (S3, autodetected)                                 stg1700
  12  STG-1703 (S3, autodetected)                                 stg1703
  13  TI 3020 (S3, autodetected)                                  ti3020
  14  TI 3025 (S3, autodetected)                                  ti3025
  15  TI 3026 (S3, autodetected)                                  ti3026
  16  IBM RGB 514 (S3, autodetected)                              ibm_rgb514
  17  IBM RGB 524 (S3, autodetected)                              ibm_rgb524
  18  IBM RGB 525 (S3, autodetected)                              ibm_rgb525
  19  IBM RGB 526 (S3)                                            ibm_rgb526
  20  IBM RGB 528 (S3, autodetected)                              ibm_rgb528
  21  ICS5342 (S3, ARK)                                           ics5342
  22  ICS5341 (W32)                                               ics5341
  23  IC Works w30C516 ZoomDac (ARK)                              zoomdac
  24  Normal DAC                                                  normal

  Enter a number to choose the corresponding RAMDAC.
  Press enter for the next page, q to quit without selection of a RAMDAC.
 =======================================================================

비디오 카드의 RAMDAC을 설정하는 항목이다. 주로 S3 계열의 비디오 카드가 선택 항목에 들어간다. S3 계열의 비디오 카드 이외의 비디오 카드라면 24번의 Normal DAC 을 선택하던지 q를 선택해서 빠져 나오기 바란다.
 ========================================================================
 A Clockchip line in the Device section forces the detection of a
 programmable clock device. With a clockchip enabled, any required
 clock can be programmed without requiring probing of clocks or a
 Clocks line. Most cards don't have a programmable clock chip.
 Choose from the following list:

  1  Chrontel 8391                                               ch8391
  2  ICD2061A and compatibles (ICS9161A, DCS2824)                icd2061a
  3  ICS2595                                                     ics2595
  4  ICS5342 (similar to SDAC, but not completely compatible)    ics5342
  5  ICS5341                                                     ics5341
  6  S3 GenDAC (86C708) and ICS5300 (autodetected)               s3gendac
  7  S3 SDAC (86C716)                                            s3_sdac
  8  STG 1703 (autodetected)                                     stg1703
  9  Sierra SC11412                                              sc11412
 10  TI 3025 (autodetected)                                      ti3025
 11  TI 3026 (autodetected)                                      ti3026
 12  IBM RGB 51x/52x (autodetected)                              ibm_rgb5xx

  Just press enter if you don't want a Clockchip setting.
  What Clockchip setting do you want (1-12)? 
 =======================================================================

비디오 카드의 클럭 칩셋을 선택하는 부분이다. 주로 S3 계열의 비디오 카드가 이 항목에 들어간다. 비디오 카드의 매뉴얼 을 보아서 자신의 클럭 칩이 여기에 없다면 엔터를 치고 넘어간다.
 =====================================================================
 For most configurations, a Clocks line is useful since it prevents the slow
 and nasty sounding clock probing at server start-up. Probed clocks are
 displayed at server startup, along with other server and hardware
 configuration info. You can save this information in a file by running
 'X -probeonly 2>output_file'. Be warned that clock probing is inherently
 imprecise; some clocks may be slightly too high (varies per run).

 At this point I can run X -probeonly, and try to extract the clock information
 from the output. It is recommended that you do this yourself and add a clocks
 line (note that the list of clocks may be split over multiple Clocks lines) to
 your Device section afterwards. Be aware that a clocks line is not
 appropriate for drivers that have a fixed set of clocks and don't probe by
 default (e.g. Cirrus). Also, for the P9000 server you must simply specify
 clocks line that matches the modes you want to use.  For the S3 server with
 a programmable clock chip you need a 'ClockChip' line and no Clocks line.

 You must be root to be able to run X -probeonly now.

 The card definition says to NOT probe clocks.
 Do you want me to run 'X -probeonly' now?
 ======================================================================

X 설정에 있어서 모니터의 주파수 대역을 선택한 비디오 카드의 클럭 칩과의 상관 관계를 맞추어주는 부분입니다. 만일 맞지 않는다면 에러 메시지를 보여주게 됩니다. 자신의 모니터 설정과 비디오 카드가 맞는지 확인해 보기 위해서 YES 로 설정하고 맞는지 확인해 보시기 바랍니다.
=======================================================================
 The card definition says to NOT probe clocks.
 Do you want me to run 'X -probeonly' now? y

 It is possible that the hardware detection routines in the server will somehow
 cause the system to crash and the screen to remain blank. If this is the
 case, do not choose this option the next time. The server may need a
 Ramdac, ClockChip or special option (e.g. "nolinear" for S3) to probe
 and start-up correctly.

 Press enter to continue, or ctrl-c to abort.
 ========================================================================

YES 로 설정을 하였다면 다음과 같은 메세지가 나온다. 엔터를 치고 넘어가면 몇번 정도 화면이 깜빡이면서 주파수 대역을 찾아내게 된다. 만약, 에러가 난다면 다음과 같은 메세지가 나오게 된다.

 ========================================================================
 Running X -probeonly -pn -xf86config /tmp/XF86Config.tmp.
 X -probeonly call failed.
 No Clocks line inserted.

 Press enter to continue, or ctrl-c to abort.
 ========================================================================

엔터를 쳐서 해상도 설정을 해보자.
 ========================================================================
 For each depth, a list of modes (resolutions) is defined. The default
 resolution that the server will start-up with will be the first listed
 mode that can be supported by the monitor and card.
 Currently it is set to:

  "640x480" "800x600" "1024x768" "1280x1024" for 8bpp
  "640x480" "800x600" "1024x768" "1280x1024" for 16bpp
  "640x480" "800x600" "1024x768" "1280x1024" for 24bpp
  "640x480" "800x600" "1024x768" for 32bpp

 Note that 16, 24 and 32bpp are only supported on a few configurations.
 Modes that cannot be supported due to monitor or clock constraints will
 be automatically skipped by the server.

 1  Change the modes for 8pp (256 colors)
 2  Change the modes for 16bpp (32K/64K colors)
 3  Change the modes for 24bpp (24-bit color, packed pixel)
 4  Change the modes for 32bpp (24-bit color)
 5  The modes are OK, continue.

 Enter your choice: 
 ========================================================================

자신이 원하는 컬러수를 고르는 항목이다. 
 ========================================================================
 Select modes from the following list:

  1  "640x400"
  2  "640x480"
  3  "800x600"
  4  "1024x768"
  5  "1280x1024"
  6  "320x200"
  7  "320x240"
  8  "400x300"
  9  "1152x864"
 10  "1600x1200"
 11  "1800x1400"
 12  "512x384"

  Please type the digits corresponding to the modes that you want to select.
  For example, 432 selects "1024x768" "800x600" "640x480", with a
  default mode of 1024x768.

  Which modes?
 =======================================================================
자신이 원하는 컬러수에 대한 해상도를 설정하는 항목이다.
 =======================================================================
 You can have a virtual screen (desktop), which is screen area that is larger
 than the physical screen and which is panned by moving the mouse to the edge
 of the screen. If you don't want virtual desktop at a certain resolution,
 you cannot have modes listed that are larger. Each color depth can have a
 differently-sized virtual screen

 Please answer the following question with either 'y' or 'n'.
 Do you want a virtual screen that is larger than the physical screen?  
 ========================================================================

X 화면에서의 가상화면을 선택할 수 있도록 하는 항목이다. 가상화면을 사용하고 싶으면 YES 로 설정하고, 필요없으면 NO 로 설정하고 넘어가기 바란다. 만일, YES 로 설정을 하였다면 다음과 같은 메세지가 나올 것이다.
 ========================================================================
 For each depth, a list of modes (resolutions) is defined. The default
 resolution that the server will start-up with will be the first listed
 mode that can be supported by the monitor and card.
 Currently it is set to:

  "640x480" "800x600" "1024x768" "1280x1024" for 8bpp
  "1280x1024" for 16bpp
  "640x480" "800x600" "1024x768" "1280x1024" for 24bpp
  "640x480" "800x600" "1024x768" for 32bpp

 Note that 16, 24 and 32bpp are only supported on a few configurations.
 Modes that cannot be supported due to monitor or clock constraints will
 be automatically skipped by the server.

  1  Change the modes for 8pp (256 colors)
  2  Change the modes for 16bpp (32K/64K colors)
  3  Change the modes for 24bpp (24-bit color, packed pixel)
  4  Change the modes for 32bpp (24-bit color)
  5  The modes are OK, continue.

  Enter your choice: 
 =====================================================================

가상화면의 컬러수를 선택하는 부분인데, 자신이 선택하였던 컬러수와 같은 컬러수를 선택해야만 한다.
 
 가상화면의======================================================================
 Select modes from the following list:

  1  "640x400"
  2  "640x480"
  3  "800x600"
  4  "1024x768"
  5  "1280x1024"
  6  "320x200"
  7  "320x240"
  8  "400x300"
  9  "1152x864"
 10  "1600x1200"
 11  "1800x1400"
 12  "512x384"

  Please type the digits corresponding to the modes that you want to select.
  For example, 432 selects "1024x768" "800x600" "640x480", with a
  default mode of 1024x768.

  Which modes?
 =======================================================================

해상도를 설정하는 부분이다.
 ========================================================================
 You can have a virtual screen (desktop), which is screen area that is larger
 than the physical screen and which is panned by moving the mouse to the edge
 of the screen. If you don't want virtual desktop at a certain resolution,
 you cannot have modes listed that are larger. Each color depth can have a
 differently-sized virtual screen

 Please answer the following question with either 'y' or 'n'.
 Do you want a virtual screen that is larger than the physical screen?
 =======================================================================

가상 화면을 이용할 것인가를 묻는 화면이다. 가상화면을 사용하고자 한다면 YES 로 설정하면 되고, 그렇지 않다면 NO로 설정하고 넘어가기 바란다.
 =======================================================================
 For each depth, a list of modes (resolutions) is defined. The default
 resolution that the server will start-up with will be the first listed
 mode that can be supported by the monitor and card.
 Currently it is set to:

 "640x480" "800x600" "1024x768" "1280x1024" for 8bpp
 "1280x1024" for 16bpp
 "640x480" "800x600" "1024x768" "1280x1024" for 24bpp
 "640x480" "800x600" "1024x768" for 32bpp

 Note that 16, 24 and 32bpp are only supported on a few configurations.
 Modes that cannot be supported due to monitor or clock constraints will
 be automatically skipped by the server.

 1  Change the modes for 8pp (256 colors)
 2  Change the modes for 16bpp (32K/64K colors)
 3  Change the modes for 24bpp (24-bit color, packed pixel)
 4  Change the modes for 32bpp (24-bit color)
 5  The modes are OK, continue.

 Enter your choice: 
 =========================================================================

컬러수와 해상도를 다 설정한 유저는 5번을 선택하고 다음으로 넘어가기 바란다.

 =========================================================================
 I am going to write the XF86Config file now. Make sure you don't accidently
 overwrite a previously configured one.

 Shall I write it to /etc/X11/XF86Config?
 =========================================================================

지금까지의 X 설정을 /etc/X11/XF86Config 파일에 저장을 할 것인지 묻는 항목이다. YES 로 설정하고 xf86config 를 마치면 X 설정은 끝나게 된다.

	< XF86Config 설정 >
	여기서는 X-Window의 심장부라고도 할 수 있는 XF86Config에 대한 간략한 내용과 설정 방법에 대해서 알아보기로 하자.

 ==============================<XF86Config >==============================
 # File generated by XConfigurator.

 # **********************************************************************
 # Refer to the XF86Config(4/5) man page for details about the format of
 # this file.
 # **********************************************************************

 # **********************************************************************
 # Files section.  This allows default font and rgb paths to be set
 # **********************************************************************

 Section "Files"

 # The location of the RGB database.  Note, this is the name of the
 # file minus the extension (like ".txt" or ".db").  There is normally
 # no need to change the default.

    RgbPath     "/usr/X11R6/lib/X11/rgb"

 # Multiple FontPath entries are allowed (they are concatenated together)

 * 이 부분이 폰트의 패스 및 디렉토리를 지정하는곳이다.

    FontPath    "/usr/X11R6/lib/X11/fonts/misc/"
    FontPath    "/usr/X11R6/lib/X11/fonts/Type1/"
    FontPath    "/usr/X11R6/lib/X11/fonts/Speedo/"
    FontPath    "/usr/X11R6/lib/X11/fonts/75dpi/"
    FontPath    "/usr/X11R6/lib/X11/fonts/100dpi/"
    FontPath    "/usr/X11R6/lib/X11/fonts/truetype/"

 EndSection

 # **********************************************************************
 # Server flags section.
 # **********************************************************************

 Section "ServerFlags"

    # Uncomment this to cause a core dump at the spot where a signal is
    # received.  This may leave the console in an unusable state, but may
    # provide a better stack trace in the core dump to aid in debugging
    #NoTrapSignals

    # Uncomment this to disable the <Crtl><Alt><BS> server abort sequence
    # This allows clients to receive this key event.
    #DontZap

    # Uncomment this to disable the <Crtl><Alt><KP_+>/<KP_-> mode switching
    # sequences.  This allows clients to receive these key events.
    #DontZoom

 EndSection

 # **********************************************************************
 # Input devices
 # **********************************************************************

 # **********************************************************************
 # Keyboard section
 # **********************************************************************

 * 시스템의 키보드를 설정하는곳이다.
 
 Section "Keyboard"

    Protocol    "Standard"

    #when using XQUEUE, comment out the above line, and uncomment the
    #following line
    #Protocol   "Xqueue"

    AutoRepeat  500 5
    
    # Let the server do the NumLock processing.  This should only be
    # required when using pre-R6 clients
    #ServerNumLock

    # Specify which keyboard LEDs can be user-controlled (eg, with xset(1))
    #Xleds      1 2 3

    #To set the LeftAlt to Meta, RightAlt key to ModeShift,
    #RightCtl key to Compose, and ScrollLock key to ModeLock:

    * 키보드의 키코드를 설정하는곳이다. 왼쪽, 오른쪽의 ALT 키를 다르게
      지정할수 있다.
 
    LeftAlt        Meta         
    RightAlt        Meta
    ScrollLock      Compose
    RightCtl        Control

 # To disable the XKEYBOARD extension, uncomment XkbDisable.

 #    XkbDisable

 # To customise the XKB settings to suit your keyboard, modify the
 # lines below (which are the defaults).  For example, for a non-U.S.
 # keyboard, you will probably want to use:

 #    XkbModel    "pc102"
 # If you have a US Microsoft Natural keyboard, you can use:
 #    XkbModel    "microsoft"
 #
 # Then to change the language, change the Layout setting.
 # For example, a german layout can be obtained with:
 #    XkbLayout   "de"
 # or:
 #    XkbLayout   "de"
 #    XkbVariant  "nodeadkeys"
 #
 # If you'd like to switch the positions of your capslock and
 # control keys, use:
 #     XkbOptions  "ctrl:swapcaps"

 # These are the default XKB settings for XFree86
 #    XkbRules    "xfree86"
 #    XkbModel    "pc101"
 #    XkbLayout   "us"
 #    XkbVariant  ""
 #    XkbOptions  ""

   XkbKeycodes     "xfree86"
   XkbTypes        "default"
   XkbCompat       "default"
   XkbSymbols      "us(pc101)"
   XkbGeometry     "pc"
   XkbRules        "xfree86"
   XkbModel        "pc101"
   XkbLayout       "us"
 EndSection

 # **********************************************************************
 # Pointer section
 # **********************************************************************

 Section "Pointer"
    Protocol    "ps/2"
    Device      "/dev/mouse"  

 # When using XQUEUE, comment out the above two lines, and uncomment
 # the following line.

 #    Protocol   "Xqueue"

 # Baudrate and SampleRate are only for some Logitech mice

 #    BaudRate   9600
 #    SampleRate 150

 # Emulate3Buttons is an option for 2-button Microsoft mice
 # Emulate3Timeout is the timeout in milliseconds (default is 50ms)

 * 마우스 3버튼 구성을 지정하는 설정이다.

    Emulate3Buttons
    Emulate3Timeout    50      

 # ChordMiddle is an option for some 3-button Logitech mice

 #    ChordMiddle

 EndSection

 # **********************************************************************
 # Xinput section -- this is optional and is required only if you
 # are using extended input devices.  This is for example only.  Refer
 # to the XF86Config man page for a description of the options.
 # **********************************************************************
 #
 # Section "Xinput"
 #    SubSection "WacomStylus"
 #        Port "/dev/ttyS1"
 #        DeviceName "Wacom"
 #    EndSubSection
 #    SubSection "WacomCursor"
 #        Port "/dev/ttyS1"
 #    EndSubSection
 #    SubSection "WacomEraser"
 #        Port "/dev/ttyS1"
 #    EndSubSection
 #
 #    SubSection "Elographics"
 #        Port "/dev/ttyS1"
 #        DeviceName "Elo"
 #        MinimumXPosition 300
 #        MaximumXPosition 3500
 #        MinimumYPosition 300
 #        MaximumYPosition 3500
 #        Screen 0
 #        UntouchDelay 10
 #        ReportDelay 10
 #    EndSubSection
 #
 #    SubSection "Joystick"
 #        Port "/dev/joy0"
 #        DeviceName "Joystick"
 #        TimeOut 10
 #        MinimumXPosition 100
 #        MaximumXPosition 1300
 #        MinimumYPosition 100
 #        MaximumYPosition 1100
 #        # CenterX 700
 #        # CenterY 600
 #        Delta 20
 #    EndSubSection
 #
 # The Mouse Subsection contains the same type of entries as the
 # standard Pointer Section (see above), with the addition of the
 # DeviceName entry.
 #
 #    SubSection "Mouse"
 #        Port "/dev/mouse2"
 #        DeviceName "Second Mouse"
 #        Protocol "Logitech"
 #    EndSubSection
 # EndSection


 # **********************************************************************
 # Monitor section
 # **********************************************************************

 # Any number of monitor sections may be present

 Section "Monitor"
 
 Identifier  "My Monitor"
    VendorName  "Unknown"
    ModelName   "Unknown"

 # HorizSync is in kHz unless units are specified.
 # HorizSync may be a comma separated list of discrete values, or a
 # comma separated list of ranges of values.
 # NOTE:   THE VALUES  HERE ARE   EXAMPLES ONLY.   REFER  TO YOUR 
MONITOR'S
 # USER MANUAL FOR THE CORRECT NUMBERS.

 * 모니터의 수평 동기 주파수를 설정하는 곳이다.

    HorizSync   30-65

 # VertRefresh is in Hz unless units are specified.
 # VertRefresh may be a comma separated list of discrete values, or a
 # comma separated list of ranges of values.
 # NOTE:   THE VALUES  HERE ARE   EXAMPLES ONLY.   REFER  TO YOUR 
MONITOR'S
 # USER MANUAL FOR THE CORRECT NUMBERS.

 * 모니터의 수직 동기 주파수를 설정하는 곳이다.
 
    VertRefresh 50-110

 # Modes can be specified in two formats.  A compact one-line format, or
 # a multi-line format.

 # These two are equivalent

 #    ModeLine "1024x768i" 45 1024 1048 1208 1264 768 776 784 817 Interlace

 #    Mode "1024x768i"
 #        DotClock       45
 #        HTimings       1024 1048 1208 1264
 #        VTimings       768 776 784 817
 #        Flags          "Interlace"
 #    EndMode

 # This is a set of standard mode timings. Modes that are out of monitor spec
 # are automatically deleted by the server (provided the HorizSync and
 # VertRefresh lines are correct), so there's no immediate need to
 # delete mode timings (unless particular mode timings don't work on your
 # monitor). With these modes, the best standard mode that your monitor
 # and video card can support for a given resolution is automatically
 # used.

 # 640x400 @ 70 Hz, 31.5 kHz hsync
 Modeline "640x400"     25.175 640  664  760  800   400  409  411  450
 # 640x480 @ 60 Hz, 31.5 kHz hsync
 Modeline "640x480"     25.175 640  664  760  800   480  491  493  525
 # 800x600 @ 56 Hz, 35.15 kHz hsync
 ModeLine "800x600"     36     800  824  896 1024   600  601  603  625
 # 1024x768 @ 87 Hz interlaced, 35.5 kHz hsync
 Modeline "1024x768"    44.9  1024 1048 1208 1264   768  776  784  817 Interlace

 # 640x400 @ 85 Hz, 37.86 kHz hsync
 Modeline "640x400"     31.5   640  672 736   832   400  401  404  445 -HSync +VS
 # 640x480 @ 72 Hz, 36.5 kHz hsync
 Modeline "640x480"     31.5   640  680  720  864   480  488  491  521
 # 640x480 @ 75 Hz, 37.50 kHz hsync
 ModeLine  "640x480"    31.5   640  656  720  840   480  481  484  500 -HSync -VS
 # 800x600 @ 60 Hz, 37.8 kHz hsync
 Modeline "800x600"     40     800  840  968 1056   600  601  605  628 +hsync +vs

 # 640x480 @ 85 Hz, 43.27 kHz hsync
 Modeline "640x400"     36     640  696  752  832   480  481  484  509 -HSync -VS
 # 1152x864 @ 89 Hz interlaced, 44 kHz hsync
 ModeLine "1152x864"    65    1152 1168 1384 1480   864  865  875  985 Interlace

 # 800x600 @ 72 Hz, 48.0 kHz hsync
 Modeline "800x600"     50     800  856  976 1040   600  637  643  666 +hsync +vs
 # 1024x768 @ 60 Hz, 48.4 kHz hsync
 Modeline "1024x768"    65    1024 1032 1176 1344   768  771  777  806 -hsync -vs
 
 # 640x480 @ 100 Hz, 53.01 kHz hsync
 Modeline "640x480"     45.8   640  672  768  864   480  488  494  530 -HSync -VS
 # 1152x864 @ 60 Hz, 53.5 kHz hsync
 Modeline  "1152x864"   89.9  1152 1216 1472 1680   864  868  876  892 -HSync -VS
 # 800x600 @ 85 Hz, 55.84 kHz hsync
 Modeline  "800x600"    60.75  800  864  928 1088   600  616  621  657 -HSync -VS

 # 1024x768 @ 70 Hz, 56.5 kHz hsync
 Modeline "1024x768"    75    1024 1048 1184 1328   768  771  777  806 -hsync -vs
 # 1280x1024 @ 87 Hz interlaced, 51 kHz hsync
 Modeline "1280x1024"   80    1280 1296 1512 1568  1024 1025 1037 1165 Interlace

 # 800x600 @ 100 Hz, 64.02 kHz hsync
 Modeline  "800x600"    69.65  800  864  928 1088   600  604  610  640 -HSync -VS
 # 1024x768 @ 76 Hz, 62.5 kHz hsync
 Modeline "1024x768"    85    1024 1032 1152 1360   768  784  787  823
 # 1152x864 @ 70 Hz, 62.4 kHz hsync
 Modeline  "1152x864"   92    1152 1208 1368 1474   864  865  875  895
 # 1280x1024 @ 61 Hz, 64.2 kHz hsync
 Modeline "1280x1024"  110    1280 1328 1512 1712  1024 1025 1028 1054

 # 1024x768 @ 85 Hz, 70.24 kHz hsync
 Modeline "1024x768"   98.9  1024 1056 1216 1408   768 782 788 822 -HSync -VSync
 # 1152x864 @ 78 Hz, 70.8 kHz hsync
 Modeline "1152x864"   110   1152 1240 1324 1552   864  864  876  908

 # 1280x1024 @ 70 Hz, 74.59 kHz hsync
 Modeline "1280x1024"  126.5 1280 1312 1472 1696  1024 1032 1040 1068 -HSync -VSy
 # 1600x1200 @ 60Hz, 75.00 kHz hsync
 Modeline "1600x1200"  162   1600 1664 1856 2160  1200 1201 1204 1250 +HSync +VSy
 # 1152x864 @ 84 Hz, 76.0 kHz hsync
 Modeline "1152x864"   135    1152 1464 1592 1776   864  864  876  908

 # 1280x1024 @ 74 Hz, 78.85 kHz hsync
 Modeline "1280x1024"  135    1280 1312 1456 1712  1024 1027 1030 1064

 # 1024x768 @ 100Hz, 80.21 kHz hsync
 Modeline "1024x768"   115.5  1024 1056 1248 1440  768  771  781  802 -HSync -VSy
 # 1280x1024 @ 76 Hz, 81.13 kHz hsync
 Modeline "1280x1024"  135    1280 1312 1416 1664  1024 1027 1030 1064

 # 1600x1200 @ 70 Hz, 87.50 kHz hsync
 Modeline "1600x1200"  189    1600 1664 1856 2160  1200 1201 1204 1250 -HSync -VS
 # 1152x864 @ 100 Hz, 89.62 kHz hsync
 Modeline "1152x864"   137.65 1152 1184 1312 1536   864  866  885  902 -HSync -VS
 # 1280x1024 @ 85 Hz, 91.15 kHz hsync
 Modeline "1280x1024"  157.5  1280 1344 1504 1728  1024 1025 1028 1072 +HSync +VS
 # 1600x1200 @ 75 Hz, 93.75 kHz hsync
 Modeline "1600x1200"  202.5  1600 1664 1856 2160  1200 1201 1204 1250 +HSync +VS
 # 1600x1200 @ 85 Hz, 105.77 kHz hsync
 Modeline "1600x1200"  220    1600 1616 1808 2080  1200 1204 1207 1244 +HSync +VS
 # 1280x1024 @ 100 Hz, 107.16 kHz hsync
 Modeline "1280x1024"  181.75 1280 1312 1440 1696  1024 1031 1046 1072 -HSync -VS

 # 1800x1440 @ 64Hz, 96.15 kHz hsync
 ModeLine "1800X1440"  230    1800 1896 2088 2392 1440 1441 1444 1490 +HSync +VSy
 # 1800x1440 @ 70Hz, 104.52 kHz hsync
 ModeLine "1800X1440"  250    1800 1896 2088 2392 1440 1441 1444 1490 +HSync +VSy

 # 512x384 @ 78 Hz, 31.50 kHz hsync
 Modeline "512x384"    20.160 512  528  592  640   384  385  388  404 -HSync -VSy
 # 512x384 @ 85 Hz, 34.38 kHz hsync
 Modeline "512x384"    22     512  528  592  640   384  385  388  404 -HSync -VSy

 # Low-res Doublescan modes
 # If your chipset does not support doublescan, you get a 'squashed'
 # resolution like 320x400.

 # 320x200 @ 70 Hz, 31.5 kHz hsync, 8:5 aspect ratio
 Modeline "320x200"     12.588 320  336  384  400   200  204  205  225 Doublescan
 # 320x240 @ 60 Hz, 31.5 kHz hsync, 4:3 aspect ratio
 Modeline "320x240"     12.588 320  336  384  400   240  245  246  262 Doublescan
 # 320x240 @ 72 Hz, 36.5 kHz hsync
 Modeline "320x240"     15.750 320  336  384  400   240  244  246  262 Doublescan
 # 400x300 @ 56 Hz, 35.2 kHz hsync, 4:3 aspect ratio
 ModeLine "400x300"     18     400  416  448  512   300  301  302  312 Doublescan
 # 400x300 @ 60 Hz, 37.8 kHz hsync
 Modeline "400x300"     20     400  416  480  528   300  301  303  314 Doublescan
 # 400x300 @ 72 Hz, 48.0 kHz hsync
 Modeline "400x300"     25     400  424  488  520   300  319  322  333 Doublescan
 # 480x300 @ 56 Hz, 35.2 kHz hsync, 8:5 aspect ratio
 ModeLine "480x300"     21.656 480  496  536  616   300  301  302  312 Doublescan
 # 480x300 @ 60 Hz, 37.8 kHz hsync
 Modeline "480x300"     23.890 480  496  576  632   300  301  303  314 Doublescan
 # 480x300 @ 63 Hz, 39.6 kHz hsync
 Modeline "480x300"     25     480  496  576  632   300  301  303  314 Doublescan
 # 480x300 @ 72 Hz, 48.0 kHz hsync
 Modeline "480x300"     29.952 480  504  584  624   300  319  322  333 Doublescan

 EndSection

 # **********************************************************************
 # Graphics device section
 # **********************************************************************

 # Any number of graphics device sections may be present

 # Standard VGA Device:

 Section "Device"
    Identifier  "Generic VGA"
    VendorName  "Unknown"
    BoardName   "Unknown"
    Chipset     "generic"

 #    VideoRam   256

 #    Clocks     25.2 28.3

 EndSection

 # Sample Device for accelerated server:

 # Section "Device"
 #    Identifier "Actix GE32+ 2MB"
 #    VendorName "Actix"
 #    BoardName  "GE32+"
 #    Ramdac     "ATT20C490"
 #    Dacspeed   110
 #    Option     "dac_8_bit"
 #    Clocks      25.0  28.0  40.0   0.0  50.0  77.0  36.0  45.0
 #    Clocks     130.0 120.0  80.0  31.0 110.0  65.0  75.0  94.0
 # EndSection

 # Sample Device for Hercules mono card:

 # Section "Device"
 #    Identifier "Hercules mono"
 # EndSection

 # Device configured by xf86config:

 Section "Device"
    Identifier  "Matrox Mystique"
    VendorName  "Unknown"
    BoardName   "Unknown"
    VideoRam    4096

     # Insert Clocks lines here if appropriate
 EndSection


 # **********************************************************************
 # Screen sections
 # **********************************************************************

 # The Colour SVGA server

 * 지정된 비디오 카드의 설정이 있는 항목이다.
 
 Section "Screen"
    Driver      "svga"
    # Use Device "Generic VGA" for Standard VGA 320x200x256
    #Device      "Generic VGA"
    Device      "Matrox Mystique"
    Monitor     "My Monitor"
    DefaultColorDepth 16 ---> * X-Window가 시작될 시에
				   하이컬러(16bit)로 기본 
	                         설정이 되도록 하는 명령이다.  
    Subsection "Display"
        Depth       8
        # Omit the Modes line for the "Generic VGA" device
        Modes       "1024x768"
        ViewPort    0 0
        # Use Virtual 320 200 for Generic VGA


       Virtual     1024 768
    EndSubsection
    Subsection "Display"
        Depth       16          --> X-Window 의 컬러수를 지정하는곳이다.
        Modes       "1280x1024" --> X-Window 에서의 컬러수에 대한 해상도.
        ViewPort    0 0
        Virtual      1280 1024  --> 가상화면의 해상도를 지정하는 부분이다.
                                     Modes 에서 지정된 화면과 같은 경우에는
                                     가상화면은 실행되지 않는다. 
    EndSubsection
    Subsection "Display"
        Depth       24
        Modes       "1280x1024"
        ViewPort    0 0
        Virtual     1280 1024
    EndSubsection
    Subsection "Display"
        Depth       32
        Modes       "1152x864"
        ViewPort    0 0
        Virtual     1152 864
    EndSubsection
 EndSection

 # The 16-color VGA server --> 16컬러 모드로 비디오 카드가 설정이
				  되었을 경우.                               
 Section "Screen"
    Driver      "vga16"
    Device      "Generic VGA"
    Monitor     "My Monitor"
    Subsection "Display"
        Modes       "640x480" "800x600"
        ViewPort    0 0
        Virtual     800 600
    EndSubsection
 EndSection

 # The Mono server --> 흑백 모드로 설정되어있을 경우.

 Section "Screen"
    Driver      "vga2"
    Device      "Generic VGA"
    Monitor     "My Monitor"
    Subsection "Display"
        Modes       "640x480" "800x600"
        ViewPort    0 0
        Virtual     800 600
    EndSubsection
 EndSection
 
 # The accelerated servers (S3, Mach32, Mach8, 8514, P9000, AGX, W32, Mach64)
    --> accelerated 가 지원되는 비디오 카드의 설정 경우.

Section "Screen"
    Driver      "accel"
    Device      "Matrox Mystique"
    Monitor     "My Monitor"
    Subsection "Display"
        Depth       8
        Modes       "1024x768"
        ViewPort    0 0
        Virtual     1024 768
    EndSubsection
    Subsection "Display"
        Depth       16
        Modes       "1280x1024"
        ViewPort    0 0
        Virtual     1280 1024
    EndSubsection
    Subsection "Display"
        Depth       24
        Modes       "1024x768"
        ViewPort    0 0
        Virtual     1024 768
      EndSubsection
    Subsection "Display"
        Depth       32
        Modes       "1152x864"
        ViewPort    0 0
        Virtual     1152 864
    EndSubsection
 EndSection
 =========================================================================
 
	< X 한글 로케일 설정 >
	X에서 한글 로케일을 기본으로 설정하게 하기 위해서는 다음과 같은 항목이 /etc/X11/xinit/xinit 에 설정이 되어야 한다.

========================<xinit >=================================
   export LANG
   LANG=ko
 ==================================================================

저장한 후에 다시 X 서버를 구동시키면 한글 로케일을 기본으로 읽어들이게 된다.

	< XFree86 3.3.2 에서 지원되는 VGA 목록 >
☞ Support for ET6100 has been added to the Tseug driver.
☞ Acceleration has been added for W32 and W32i.
☞ Test performance has been improved for the Tseug driver.
☞ Support for new RAMDACs, including the ch8398, the ch8391, and the
   MUSIC MU9C4910 has been added to the Tseug driver.
☞ Accelerated support fot the AT3D and AT25 has been added to the NY driver.
☞ Support for accelerated NY1 and accelerated Riva128 has been added to
   the NY driver.
☞ Support for the Matrox Millennium II AGP has been included into the
   MGA driver.
☞ New support for several Trident chips has been added, including 
   Cyber9397, 3DImage975 and 3DImage985 (unaccelerated and not completed yet)
   , TGUI9685.
☞ CrealTV support has been added for the TGUI9685.
☞ Acceleration of all TGUI chipsets has been improved.
☞ Support for Rage Pro based PCI and AGP cards has been added.
☞ Maximum dorclock for newer Mach64 cards has been increased.
☞ Support for 1600x1200 and 1600x1280 mode has been added for VT and newer
   Mach64 chips.
☞ Support for the auxiliary register apertune fot newer Mach64 cards has
   been added.
☞ Support for the I128 Revolution (T2R) has been added.
☞ Additional acceleration for the I128 server has been added.
☞ Support for sw cursor, pci, retry, 24bpp, HW cursor has been added to
   cirrus Laguna chipsets.
☞ S3 VIRGE/MX and VIRGE/G X2 support has been added (SVGA server only).
☞ support for S3 VIRGE hardware cursor added in SVGA server.
☞ An S3 driver has been added to the SVGA server.
☞ S3 server and SVGA/S3 server now recognize some fake S3 chips and print  
   out a warning message.
☞ XAA has been extended to support hardware cursor and provide accelerated
   support dashed lines and trapezoid fills.
☞ Several new mouse protocols have been added to all servers.
   They should now support Kensington ThinkingMouse, ALPS GlidePoint,
   Genius NetScroll, Genius NetMouse, ASCII MieMouse, Logitech MouseMan+,
   Logitech FirstMouse+.
   This includes all buttons on these mice as well as the wheels.
   The wheel can be used to either create additional buttons or for z-axis
   indication.
☞ XF86Setup now supports setting the default color depth and choosing
   the modes the user wants to use.
☞ XF86Setup allows to select all the new mouse protocols (depending on 
   the OS it is running on).
■ 리눅스 상에서의 컴퓨터 통신과 인터넷 사용하기
[세연에서의 통신]
일단 모뎀을 설정을 해야한다.
모뎀이 com4로 설정되어 있다고 가정하고 모뎀을 설정해 보겠다.
포트가 com4 번이면 Linux로 표시하면 cua3이 된다
"ln -s /dev/cua3 /dev/modem" 이라 입력하시면 cua3가 modem이라는 파일로 링크가 됩니다.
모뎀설정이 끝난 후 세연 options를 수정해주셔야 할 곳이 있는데, 아래와 같이 되게 해주시면 됩니다.

# lock
38400
/dev/modem
defaultroute

다음에는 Control Panel에서 Network Configuration이라는 아이콘을 더블클릭한 후에, names의 domain항목에는 dacom.co.kr을 적으시고, name servers에는 164.124.101.2를, hosts에 ip에는 164.124.101.2와 name에는 dacom.co.kr을 채워넣으시면 됩니다.

그럼  seyon을 실행 시켜 화면을 보면서 하겠습니다.

터미널모드(hanterm)에서 "seyon"을 입력합니다.
아래의 화면이 세연의 초기 화면입니다.

?전화번호부?에서 사용하시고자하는 BBS번호를 선택하시거나 직접 입력하셔서, 연결을 하겠습니다. 01421번 천리안으로 연결을 하겠습니다.

그럼 CONNECT란 말이 나오고 난 다음에

Chollian Net________________
1. 천리안 (Chollian)
11. 매직링크 (EDI,펌/홈뱅킹서비스)
x. 종료 (Disconnect)

가 나오는 화면이 보입니다.
그럼 1번을 선택하면 사용자 아이디와 비밀번호를 물어 봅니다.
   ④ Wabi
	Description : 리눅스에서 마이크로 소프트 Windows 3.x 응용프로그램을
		      돌리기 위한 데스크탑 솔루션.
	URL : http://www.caldera.com/tech-ref/wabi/resources.html
   ⑤ Wine
	Description : 리눅스에서 Windows 3.x 응용프로그램을 돌릴 수 있도록
		     해주는 리눅스 어플리케이션.
	URL : http://www.winehq.com/

4. FTP Sites
   sunsite.unc.edu		Chapel Hill에 있는 North Carolina대학교.
   tsx-11.mit.edu		Massachusetts Institute of Technology(MIT)
   alpha.gnu.org		
   ftp.gnu.org
   ftp.kreonet.re.kr
   ftp.kaist.ac.kr		한국과학기술연구소
   ftp.sogang.ac.kr		서강대학교

5. Graphics
   ① Ansi
	Description : Ansi drawer 이다.
	URL : ftp://sunsite.unc.edu/pub/Linux/apps/graphics/draw/
② Gimp
	Description : 그래픽 프로그램의 최고이다. 많은 사람들이 마지막
		     버전의 Photoshop보다 Gimp 1.0이 더 좋다고 할 정도이다.
	URL : http://xcf.berkeley.edu/~gimp/
   ③ ImageMagick
	Description : Image converter/viewer 이다. 매우 훌륭한 툴이다.
	URL : ftp://ftp.wizards.dupont.com/pub/ImageMagick/linux/
   ④ Mind's Eye
	Description : 만일 Gimp가 2-D 그래픽의 최고라면, 이것은 3-D 그래픽의
		     최고이다.
	URL : http://www.ptf.hro.nl/free-d/
   ⑤ PostShop
	Description : 이것은 Postscript와 PDF와 이미지 파일등을 쉽게 프린트하게
		     해준다.
	URL : http://www.vividata.com/postshop.html
   ⑥ Scanshop
	Description : 이것은 70종의 스캐너 모델을 제공하는 드라이버를 가지고
		     있다.
	URL : http://www.vividaya.com/scanshop.html
   ⑦ X-LoadImage(XLi)
	Description : 이것은 xv보다 빠르고 큰 그림을 다루기 쉽다. 그러나 매우
		      간단한 프로그램이다.
	URL : ftp://sunsite.unc.edu/Linux/apps/graphics/viewers/X/Related
   ⑧ XV
	Description : 이것은 벌써 당신이 가지고 있을 만큼 너무나 일반적인
		     그래픽 프로그램이다.  빠르고 picture viewer의 모든 특성을
		     지니고 있다.
	URL : http://www.sun.com/sunsoft/catlink/xv/xv.html

6. Link
   ① LAUP (Linux Application and Utilities Page)
	Description : Shell, Desk and File Utilities가 링크되어 있다..
	URL : http://www.xnet.com/~blatura/Linapp2.html#file
   ② Linux Application
	Description : Linux software가 분야별로 링크되어 있다.
	URL : http://www.linuxapps.com
   ③ Linux Database List
	Description : Linux/Uinx Database List. 
	URL : http://linas.org/linux/db.html
   ④ Linux FTP Watcher
	Description : 리눅스 어플리케이션들이 있는 FTP가 링크 되어있다.
	URL : http://lfw.linuxhq.com/
   ⑤ Linux Link by Good
	Description : 분야별로 링크 되어있다.
	URL : http://www.linuxlinks.com/
   ⑥ Linux-OS of the Future
	Description : 링크 사이트.
	URL : http://www.microgear.net/xo/
   ⑦ Linux Software Encyclopedia
	Description : A-Z까지의 Linux software가 정리, 링크 되어있다.
	URL : http://stommel.tamu.edu/~baum/linuxlist/linuxlist/linuxlist.html
   ⑧ Linux Software Map
	Description : Linux Software들이 분야별로 링크 되어있다. 다른 링크
		     사이트도 링크 되어있어 굉장히 정보가 풍부하다.
	URL : http://www.linuxresources.com/apps/index.html
   ⑨ Linux Software Map
	Description : Linux Software들이 링크 되어있다. 검색 가능하다.
	URL : http://www.boutell.com/lsm/
   ⑩ SAL (Scientific Applications on Linux)
	Description : 이곳은 과학자나 가술자들이 흥미있을 만한 Linux
	 	      software들이 링크되어있고, 정보가 모아져 있다.
	URL : http://bioinfo.bioneer.com/sal/

7. Multimedia
   ① TK3Play
	Description : 매우 훌륭한 Mpeg3 Player이다. 제어가 용이하다. 
	URL : http://www.mpeg3.org/main.html
   ② WorkMan
	Description : 매우 훌륭한 XView CD Player이다. 
	URL : ftp://sunsite.unc.edu/pup/Linux/apps/sound/cdrom/X/
   ③ X-Anim
	Description : X를 위한 animation player이다. 다양한 포맷을 지원한다.
		     빠르고 안정적이다.
	URL : http://smurfland.cit.buffalo.edu/xanim/home.html
   ④ XView Mpeg
	Description : mpeg movie player이다. 특별한 것은 없다.
	URL : ftp://sunsite.unc.edu/pub/Linux/apps/graphics/viewers/X/
   ⑤ X11amp
	Description : X용 mp3 player이다. 모양은 winamp와 같다.
	URL : http://www.x11amp.bz.nu/

8. Office
   ① Andrew
	Description : 워드프로세서이다.
	URL : http://www.cs.cmu.edu/~AUIS/
   ② Applixware
	Description : office suite 패키지이다.
	URL : http://www.applixware.com/
   ③ Emacs
	Description : 굉장히 다기능 에디터이다. 
	URL : http://www.xemacs.org/
   ④ LyX
	Description : LaTeX을 사용하는 워드프로세서이다.
	URL : http://www.lehigh.edu/~dlj0/Lyrix.html
   ⑤ MacroCalc
	Description : 스프레드시트이다. Lotus123와의 호환성이 있다.
	URL : http://home.t-online.de/home/Axel-Reihold/#mc
   ⑥ StarOffice for Linux
	Description : StarDivision에서 나온 완벽한 office suite 패키지이다. 용량이
		     꽤 크고 매우 느리다.
	URL : http://www.stardivision.com/

9. 한글 & 문서
   ① GNU Documentation
	Description : GNU Program의 모든 문서가 있다.
	URL : http://www.delorie.com/gnu/docs/
   ② KIMS (Korean Input Method Server)
	Description : KIMS for Linux는 말 그대로 Linnux XFree86
		     3.1.2이상(X1186)에서 사용가능한 한글입력기이다.
		     한글 입력기란 XIM(X Input Method)이란 프로토콜의 교환을
		     통해 I18N된 X Client의 수정 없이 한글을 입력 할 수 있는
		     어플리케이션이다.
	URL : http://www.iworld.net/~bumchul/kims.html
   ③ KLDP (Korean Linux Documentation Project)
	Description : 영문문서 번역 또는 창작원고, 또는 여러 리눅스 동호회나
		     뉴스 그룹등에서 제공되었던 각종 강좌 등의 문서들을
		     정리해서 모아 놓은 곳이다. 
	URL : http://kldp.linux-kr.org/
   ④ Linux Gazette
	Description : 비상업성의 인터넷 매거진이다.
	URL : http://www.redhat.com/linux-info/lg/
   ⑤ Linux Journal
	Description : Linux잡지인 Linux Jounal의 인터넷 사이트이다.
	URL : http://www.linuxjournal.com/
   ⑥ Linux Weekly News
	Description : Linux World로부터 최신 뉴스를 전해준다.
	URL : http://lwn.net/
   ⑦ MIZI Research
	Description : 미지리서치는 유닉스 운영체제에서 한글 처리에 대한 제반
		     기술을 다른 개발자들이 사용할 수 있는 형태로 제공한다.
	URL : http://mizi.co.kr/
   ⑧ 벼루
	Description : X1186용 한글 입력기이다.
	URL : http://entropy.kaist.ac.kr/~jhpa가/byeoroo/

10. Others
   ① Caldera
	Description : Caldera Homepage
	URL : http://www.caldera.com/
   ② Debian
	Description : Debian Homepage
	URL : http://www.debian.org/
   ③ GNU's Not Unix
	Description : GNU 사이트.
	URL : http://www.gnu.org/
   ④ LinuxHQ
	Description : kernel patches. 
	URL : http://www.linuxhq.com/
   ⑤ Linux Mall
	Description : Linux superstore.  
	URL : http://www.LinuxMall.com/
   ⑥ Linux News Group
	Description : 많은 리눅스 뉴스그룹이 링크되어있다. 
	URL : http://www.ameritech.net/users/dbarber/links.html
   ⑦ Linux Now
	Description : 가장 완벽한 리눅스 참고사이트.
	URL : http://www.Linuxnow.com/
   ⑧ Linux Online
	Description : Linux home page이다. ?리눅스란 무엇인가? 에 대한 내용부터
		     유즈넷 뉴스그룹, FTP사이트, 최신 뉴스, 저널 등의 종합적인
		     리눅스 정보로 운영되는 곳이다.
	URL : http://www.linux.org/
   ⑨ Redhat
	Description : Red-Hat Homepage
	URL : http://www.redhat.com